[
  {
    "id": "/api-reference#api-reference",
    "title": "API Reference",
    "text": "The Brisa API reference is divided into the following sections:",
    "titles": []
  },
  {
    "id": "/api-reference#components",
    "title": "Components",
    "text": "Context Provider",
    "titles": [
      "API Reference"
    ]
  },
  {
    "id": "/api-reference#functions",
    "title": "Functions",
    "text": "createContext\ncreatePortal\ndangerHTML\nnavigate\nnotFound",
    "titles": [
      "API Reference"
    ]
  },
  {
    "id": "/api-reference#extended-properties",
    "title": "Extended Properties",
    "text": "debounceEvent\nindicateEvent\nkey\nref\nskipSSR\nrenderOn\nrenderMode",
    "titles": [
      "API Reference"
    ]
  },
  {
    "id": "/api-reference#server-apis",
    "title": "Server APIs",
    "text": "renderInAction\nrenderToReadableStream\nrenderToString\ngetServeOptions\nfileSystemRouter\nRenderInitator\nserve\nSSRWebComponent\nNode.js APIs\n\nserve\nhandler",
    "titles": [
      "API Reference"
    ]
  },
  {
    "id": "/api-reference#compiler-apis",
    "title": "Compiler APIs",
    "text": "compileWC",
    "titles": [
      "API Reference"
    ]
  },
  {
    "id": "/api-reference/brisa-cli#brisa-cli",
    "title": "Brisa CLI",
    "text": "The Brisa CLI allows you to develop, build, start your application, and more. To get a list of the available CLI commands, run the following command inside your project directory: brisa --help The output should look like this: Usage: brisa [options] <command>\nOptions:\n --help        Show help\nCommands:\n dev           Start development server\n build         Build for production\n start         Start production server\n add           Add integrations (e.g., mdx, tailwindcss)",
    "titles": []
  },
  {
    "id": "/api-reference/brisa-cli#commands",
    "title": "Commands",
    "text": "Development (brisa dev)\nBuilding (brisa build)\nStarting (brisa start)\nAdding integrations (brisa add)",
    "titles": []
  },
  {
    "id": "/api-reference/brisa-cli/brisa-add#adding-integrations-brisa-add",
    "title": "Adding integrations (brisa add)",
    "text": "brisa add allows you to add integrations to your project. To get a list of the available options with brisa add, run the following command inside your project directory: brisa add --help The output should look like this: Usage: brisa add <integration>\nIntegrations:\n mdx          Add mdx integration\n tailwindcss  Add tailwindcss integration\nOptions:\n --help       Show help",
    "titles": []
  },
  {
    "id": "/api-reference/brisa-cli/brisa-add#mdx-integration",
    "title": "MDX integration",
    "text": "The MDX integration allows you to use MDX files in your project. To add the MDX integration to your project, run the following command inside your project directory: brisa add mdx Take a look at the MDX integration documentation to learn more about the MDX integration.",
    "titles": [
      "Adding integrations (brisa add)"
    ]
  },
  {
    "id": "/api-reference/brisa-cli/brisa-add#tailwind-css-integration",
    "title": "Tailwind CSS integration",
    "text": "The Tailwind CSS integration allows you to use Tailwind CSS in your project. To add the Tailwind CSS integration to your project, run the following command inside your project directory: brisa add tailwindcss Take a look at the Tailwind CSS integration documentation to learn more about the Tailwind CSS integration.",
    "titles": [
      "Adding integrations (brisa add)"
    ]
  },
  {
    "id": "/api-reference/brisa-cli/brisa-build#building-brisa-build",
    "title": "Building (brisa build)",
    "text": "brisa build creates an optimized production build of your application. The output displays information about each route: [ info ]   Route                           | JS server | JS client (gz)\n[ info ]   ---------------------------------------------------------------\n[ info ]   Î» /pages/index                  | 41 kB     | 12 kB\n[ info ]   Î» /pages/about-us               | 1 kB      | 7 kB \n[ info ]   Î» /pages/user/[username]        | 244 B     | 2 kB \n[ info ]   Î» /api/user/[username]          | 105 B     |               \n[ info ]   Æ’ /middleware                   | 401 B     |               \n[ info ]   Î” /layout/index                 | 759 B     |               \n[ info ]   Î© /i18n                         | 737 B     |               \n[ info ]   Î¨ /websocket                    | 8 B       |               \n[ info ]   Î˜ /web-components/_integrations | 528 B     |               \n[ info ]  \n[ info ]   Î»  Server entry-points\n[ info ]   Î”  Layout\n[ info ]   Æ’  Middleware\n[ info ]   Î©  i18n\n[ info ]   Î¨  Websocket\n[ info ]   Î˜  Web components integrations\n[ info ]        - client code already included in each page\n[ info ]        - server code is used for SSR\n[ info ]  \n[ info ]   Î¦  JS shared by all\n[ info ]  \n[ info ]   âœ“   Compiled successfully!\n[ info ]   âœ¨  Done in 253.72ms. JS server: The number of bytes of JavaScript code that will be executed on the server.\nJS client (gz): The number of bytes of JavaScript code that will be sent to the client, after being compressed with gzip. Only the JS client code is compressed with gzip. The JS server code size is without compression. To get a list of the available options with brisa build, run the following command inside your project directory: brisa build --help The output should look like this: Usage: brisa build [options]\nOptions:\n -d, --dev           Build for development (useful for custom server)\n -w, --web-component Build standalone web component to create a library\n -c, --component     Build standalone server component to create a library\n -s, --skip-tauri    Skip open tauri app when 'output': 'desktop' | 'android' | 'ios' in brisa.config.ts\n --help              Show help",
    "titles": []
  },
  {
    "id": "/api-reference/brisa-cli/brisa-build#build-different-outputs",
    "title": "Build different outputs",
    "text": "If you want to build your application for different outputs, you can use the output field in the brisa.config.ts file. The available outputs are: server: The default output. It generates a server-side application.\nstatic: Generates a static application.\ndesktop: Generates a desktop application.\nandroid: Generates an Android application.\nios: Generates an iOS application. If you want to make a desktop app for Windows, another one for Mac, also android and ios, all at the same time. We recommend you do this in an array inside a pipeline and use an environment variable to decide the output. The good thing is that if you are on Windows, it will use the native Windows stuff for the Destkop app build, the same with Linux and Mac.",
    "titles": [
      "Building (brisa build)"
    ]
  },
  {
    "id": "/api-reference/brisa-cli/brisa-build#development-build",
    "title": "Development build",
    "text": "brisa build -d creates a development build of your application. This build is useful for custom servers.",
    "titles": [
      "Building (brisa build)"
    ]
  },
  {
    "id": "/api-reference/brisa-cli/brisa-build#web-component-build",
    "title": "Web component build",
    "text": "Brisa is more than a framework; it is a Web Component Compiler. You can create web components using Brisa and build them to create a library. brisa build -w path/web-component.tsx creates a standalone web component to create a library. The path to the file can be relative or absolute. The output will be: The name of the web component is going to be the name of the file. For example, if your file is\ncustom-counter.tsx, the name of the web component will be custom-counter. The output will be: [ wait ]  ðŸš€ building your standalone components...\n[ info ]\n[ info ]   Standalone components:\n[ info ]   - build/custom-counter.server.js (646.00 B)\n[ info ]   - build/custom-counter.client.js (425.00 B)\n[ info ]\n[ info ]   âœ¨  Done in 59.78ms. In the case that you need to build more than one web component, you can use the --web-component flag multiple times: brisa build -w path/web-component1.tsx -w path/web-component2.tsx After running the command, you will have a web-component1.client.js, web-component1.server.ts, web-component2.client.js, and web-component2.server.ts file. [ wait ]  ðŸš€ building your standalone components...\n[ info ]\n[ info ]   Standalone components:\n[ info ]   - build/web-component1.server.js (646.00 B)\n[ info ]   - build/web-component1.client.js (425.00 B)\n[ info ]   - build/web-component2.server.js (646.00 B)\n[ info ]   - build/web-component2.client.js (425.00 B)\n[ info ]\n[ info ]   âœ¨  Done in 153.72ms. Why theses files? *.client.js: The client-side code of the web component.\n*.server.ts: The server-side code of the web component, used for SSR. Even though it is called \"server\", it does not mean that it is a \"server component\", it is still a \"web component\", which is transformed to be able to do SSR of it, taking into account the Declarative Shadow DOM and the access to the WebContext.",
    "titles": [
      "Building (brisa build)"
    ]
  },
  {
    "id": "/api-reference/brisa-cli/brisa-build#client-side-code-usage",
    "title": "Client-side code usage",
    "text": "Example using these web components in Vanilla JavaScript: <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Example</title>\n   <script type=\"importmap\">\n    {\n      \"imports\": {\n        \"brisa/client\": \"https://unpkg.com/brisa@latest/client-simplified/index.js\"\n      }\n    }\n  </script>\n  <script type=\"module\" src=\"web-component1.client.js\"></script>\n  <script type=\"module\" src=\"web-component2.client.js\"></script>\n</head>\n<body>\n  <web-component1></web-component1>\n  <web-component2></web-component2>\n</body>\n</html> The import map is necessary outside of the Brisa framework to map brisa/client to brisa/client-simplified. This is because the Brisa client is internally used by the Brisa framework and we did a simplified version to be used outside of the framework.",
    "titles": [
      "Building (brisa build)",
      "Web component build"
    ]
  },
  {
    "id": "/api-reference/brisa-cli/brisa-build#ssr-of-web-component",
    "title": "SSR of Web Component",
    "text": "Example server-side rendering these web components in a different JSX framework: import { renderToString } from 'brisa/server';\nimport WebComponent1 from './web-component1.server.ts';\nimport WebComponent2 from './web-component1.server.ts';\n\nconst htmlWC1 = await renderToString(<WebComponent1 foo=\"bar\" />);\nconst htmlWC2 = await renderToString(<WebComponent2 foo=\"bar\" />); In the case of incompatibilties with the jsx-runtime, you can use the jsx function: import { renderToString } from 'brisa/server';\nimport { jsx } from 'brisa/jsx-runtime';\nimport WebComponent1 from './web-component1.server.ts';\nimport WebComponent2 from './web-component1.server.ts';\n\nconst htmlWC1 = await renderToString(jsx(WebComponent1, { foo: \"bar\" }));\nconst htmlWC2 = await renderToString(jsx(WebComponent2, { foo: \"bar\" })); The Web Components during SSR are transformed into Declarative Shadow DOM.",
    "titles": [
      "Building (brisa build)",
      "Web component build"
    ]
  },
  {
    "id": "/api-reference/brisa-cli/brisa-build#component-build",
    "title": "Component build",
    "text": "brisa build -c path/component.ts creates a standalone server component to create a library. The path to the file can be relative or absolute. The output will be: [ wait ]  ðŸš€ building your standalone components...\n[ info ]\n[ info ]   Standalone components:\n[ info ]   - build/component.server.js (446.00 B)\n[ info ]\n[ info ]   âœ¨  Done in 53.71ms. In the case that you need to build more than one component, you can use the --component flag multiple times: brisa build -c path/component1.ts -c path/component2.ts After running the command, you will have a component1.server.ts and a component2.server.ts file. [ wait ]  ðŸš€ building your standalone components...\n[ info ]\n[ info ]   Standalone components:\n[ info ]   - build/component1.server.js (446.00 B)\n[ info ]   - build/component2.server.js (426.00 B)\n[ info ]\n[ info ]   âœ¨  Done in 72.31ms.",
    "titles": [
      "Building (brisa build)"
    ]
  },
  {
    "id": "/api-reference/brisa-cli/brisa-build#how-to-use-the-server-component",
    "title": "How to use the server component",
    "text": "Example using this server component in a different framework: import { renderToString } from 'brisa/server';\nimport { Component } from 'path/component.server.ts';\n\nconst html = await renderToString(<Component foo=\"bar\" />); In the case of incompatibilties with the jsx-runtime, you can use the jsx function: import { renderToString } from 'brisa/server';\nimport { jsx } from 'brisa/jsx-runtime';\n\nconst html = await renderToString(jsx(Component, { foo: 'bar' })); Server Actions are not supported in standalone components for security reasons.",
    "titles": [
      "Building (brisa build)",
      "Component build"
    ]
  },
  {
    "id": "/api-reference/brisa-cli/brisa-build#skip-open-tauri-app",
    "title": "Skip open Tauri app",
    "text": "When the output is set to desktop, ios, or android in brisa.config.ts, the build is done twice: The first build is for the statics files.\nThe second build is for the desktop, ios, or android app (Integration with Tauri). brisa build -s skips the integration with Tauri and only builds the static files. Learn more about the app strategy (server, static, desktop, android, ios) here.",
    "titles": [
      "Building (brisa build)"
    ]
  },
  {
    "id": "/api-reference/brisa-cli/brisa-dev#development-brisa-dev",
    "title": "Development (brisa dev)",
    "text": "brisa dev starts the application in development mode with hot-code reloading, error reporting, and more. To get a list of the available options with brisa dev, run the following command inside your project directory: brisa dev --help The output should look like this: Usage: brisa dev [options]\nOptions:\n -p, --port         Specify port\n -d, --debug        Enable debug mode\n -s, --skip-tauri   Skip open tauri app when 'output': 'desktop' | 'android' | 'ios' in brisa.config.ts\n --help             Show help",
    "titles": []
  },
  {
    "id": "/api-reference/brisa-cli/brisa-dev#changing-the-port",
    "title": "Changing the port",
    "text": "The application will start at http://localhost:3000 by default. The default port can be changed via process.env.PORT or with -p flag, like so: brisa dev -p 8080",
    "titles": [
      "Development (brisa dev)"
    ]
  },
  {
    "id": "/api-reference/brisa-cli/brisa-dev#debug-mode",
    "title": "Debug mode",
    "text": "brisa dev -d enables debug mode. See more about debugging documentation.",
    "titles": [
      "Development (brisa dev)"
    ]
  },
  {
    "id": "/api-reference/brisa-cli/brisa-dev#skip-tauri",
    "title": "Skip tauri",
    "text": "brisa dev -s skips opening the desktop app when output is set to desktop, ios, or android in brisa.config.ts. Learn more about the app strategy (server, static, desktop, android, ios) here.",
    "titles": [
      "Development (brisa dev)"
    ]
  },
  {
    "id": "/api-reference/brisa-cli/brisa-start#production-server-brisa-start",
    "title": "Production Server (brisa start)",
    "text": "brisa start starts the application in production mode. To get a list of the available options with brisa start, run the following command inside your project directory: brisa start --help The output should look like this: Usage: brisa start [options]\nOptions:\n -p, --port    Specify port brisa start cannot be used with different output than server (the default one). For output set to static, you can use alternatives like bunx serve out to run the build output and try the production assets locally.",
    "titles": []
  },
  {
    "id": "/api-reference/brisa-cli/brisa-start#changing-the-port",
    "title": "Changing the port",
    "text": "The application will start at http://localhost:3000 by default. The default port can be changed via process.env.PORT or with -p flag, like so: brisa start -p 8080",
    "titles": [
      "Production Server (brisa start)"
    ]
  },
  {
    "id": "/api-reference/compiler-apis/compileWC#compilewc",
    "title": "compileWC",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/compiler-apis/compileWC#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "compileWC"
    ]
  },
  {
    "id": "/api-reference/compiler-apis/compileWC#compilewccode-string-string",
    "title": "compileWC(code: string): string",
    "text": "The compileWC function transpiles a JSX web component to be compatible with the browser. It is very likely that in your day to day with Brisa you will not need to use this function, but if you need to do something more advanced, such as a Bundler plugin, or a Playground, this function can be useful. The Web Component is expected to be defined in the same way as it is defined inside src/web-components, that is, with an export default.",
    "titles": [
      "compileWC",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/compiler-apis/compileWC#parameters",
    "title": "Parameters",
    "text": "code: The code of the web component.",
    "titles": [
      "compileWC",
      "Reference",
      "compileWC(code: string): string"
    ]
  },
  {
    "id": "/api-reference/compiler-apis/compileWC#returns",
    "title": "Returns",
    "text": "The transpiled code of the web component.",
    "titles": [
      "compileWC",
      "Reference",
      "compileWC(code: string): string"
    ]
  },
  {
    "id": "/api-reference/compiler-apis/compileWC#example",
    "title": "Example",
    "text": "import { compileWC } from \"brisa/compiler\";\n\nconst code = `\n\texport default function MyComponent() { \n\t\treturn <div>Hello World</div>;\n\t}\n`;\nconst finalCode = compileWC(code);\nconsole.log(finalCode);\n/*\n\timport {brisaElement} from \"brisa/client\";\n\t\t\t\n\tfunction MyComponent() {\n\t\treturn [\"div\", {}, \"Hello World\"];\n\t}\n\t\t\t\n\texport default brisaElement(MyComponent);\n*/",
    "titles": [
      "compileWC"
    ]
  },
  {
    "id": "/api-reference/compiler-apis/compileWC#outside-bunjs",
    "title": "Outside Bun.js",
    "text": "This function is intended to be used within the Bun runtime, as it uses the Bun transpiler to convert TSX to JS. However, if you want to use it in other environments, such as Node.js or in the browser, you can do so, but you will need to transpile the TSX to JS beforehand, for example with @swc/wasm-web. Bun.Transpiler is not applied when the environment is not Bun.js, so you will need to transpile the code before using compileWC to convert it to js.",
    "titles": [
      "compileWC"
    ]
  },
  {
    "id": "/api-reference/compiler-apis/compileWC#example-with-swcwasm-web",
    "title": "Example with @swc/wasm-web",
    "text": "import { compileWC } from \"brisa/compiler\";\nimport initSwc, { transformSync } from \"@swc/wasm-web\";\n\nasync function main() {\n\tawait initSwc();\n\tconst code = `\n\t\texport default function MyComponent() { \n\t\t\treturn <div>Hello World</div>;\n\t\t}\n\t`;\n\tconst transpiledCode = transformSync(code, {\n\t\tjsc: {\n\t\t\tparser: {\n\t\t\t\tsyntax: \"typescript\",\n\t\t\t\ttsx: true,\n\t\t\t},\n\t\t},\n\t});\n\tconst finalCode = compileWC(transpiledCode.code);\n\tconsole.log(finalCode);\n}",
    "titles": [
      "compileWC",
      "Outside Bun.js"
    ]
  },
  {
    "id": "/api-reference/components/context-provider#context-provider",
    "title": "context-provider",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/components/context-provider#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "context-provider"
    ]
  },
  {
    "id": "/api-reference/components/context-provider#lesscontext-provider-contextcontext-valuefoogreaterlesscontext-providergreater",
    "title": "<context-provider context={Context} value=\"foo\">...</context-provider>",
    "text": "The context-provider component is required to propagate a value from some context to a sub-tree of components. The context-provider does not need any import. You can use the custom element context-provider by passing the context and value. It is a web component because this way the value is going to be shared with the web components and also you can use the same provider in web components. Server component: import { createContext } from \"brisa\";\nimport AnotherComponent from \"@/components/another-component\";\n\nconst ctx = createContext(\"foo\");\n\nexport default function ServerComponent() {\n  <context-provider context={ctx} value=\"bar\">\n    <AnotherComponent />\n  </context-provider>;\n} Web component: import { createContext } from \"brisa\";\n\nconst ctx = createContext(\"foo\");\n\nexport default function WebComponent() {\n  <context-provider context={ctx} value=\"bar\">\n    <another-component />\n  </context-provider>;\n}",
    "titles": [
      "context-provider",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/components/context-provider#parameters",
    "title": "Parameters:",
    "text": "SomeContext: The context that youâ€™ve previously created with createContext. The context itself does not hold the information, it only represents the kind of information you can provide or read from components.",
    "titles": [
      "context-provider",
      "Reference",
      "<context-provider context={Context} value=\"foo\">...</context-provider>"
    ]
  },
  {
    "id": "/api-reference/components/context-provider#returns",
    "title": "Returns:",
    "text": "useContext returns the context value inside a signal for the calling component. It is determined as the value passed to the closest context-provider above the calling component in the tree. If there is no such provider, then the returned value will be the defaultValue you have passed to createContext for that context. The returned value is up-to-date, reactive under a signal.",
    "titles": [
      "context-provider",
      "Reference",
      "<context-provider context={Context} value=\"foo\">...</context-provider>",
      "Parameters:"
    ]
  },
  {
    "id": "/api-reference/components/context-provider#support",
    "title": "Support",
    "text": "Component\nSupport\n\n\n\n\nServer Component\nâœ…\n\n\nWeb Component\nâœ…\n\n\nSSR Web Component\nâœ…",
    "titles": [
      "context-provider",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/components/request-context#request-context",
    "title": "Request Context",
    "text": "The RequestContext is a set of utilities provided by Brisa to facilitate the development of server components. It is a Request with some extra functionalities such as managing store, handling context, i18n, and more. import type { RequestContext } from \"brisa\";\n\nexport default function ServerComponent(props, requestContext: RequestContext) {\n  const {\n    // Shared data across server/web components\n    store,\n    useContext,\n\n    // Useful to control pending state in server components\n    indicate,\n\n    // Data of the current route\n    route,\n\n    // Consume translations and control internationalization\n    i18n,\n\n    // Access to websockets\n    ws,\n\n    // Get the user IP\n    getIp,\n\n    // The `finalURL` is the path of your page file\n    finalURL,\n\n    // Request id\n    id,\n\n    // The initiator of the render (\"SERVER_ACTION\", \"SPA_NAVIGATION\", \"INITIAL_REQUEST\")\n    renderInitiator,\n\n    // Add styles\n    css,\n  } = requestContext;\n  // ... Server component implementation ...\n} Being an extension of the Request, you also have access to all fields of the Request. In contrast to other frameworks that necessitate imports, our methodology incorporates all these properties directly within each server component.",
    "titles": []
  },
  {
    "id": "/api-reference/components/request-context#store",
    "title": "store",
    "text": "The store property is an extended map where values can be stored and shared among all web components. It serves as a global state accessible by all components. Values can be set and retrieved using the store.set and store.get methods. Example setting a value: store.set(\"count\", 0); Example getting a value: <div>{store.get(\"count\")}</div> The server store only lives at request time so that any server component can access the store unless you use transferToClient, which extends the life of the store.",
    "titles": [
      "Request Context"
    ]
  },
  {
    "id": "/api-reference/components/request-context#transfertoclient",
    "title": "transferToClient",
    "text": "The store data from request context is only available on the server. So you can store sensitive data without worrying. However, you can transfer certain data to the client side (web-components) using store.transferToClient method. import { type RequestContext } from \"brisa\";\n\nexport default async function SomeComponent({}, request: RequestContext) {\n  const data = await getData(request);\n\n  request.store.set(\"data\", data);\n\n  // Transfer \"data\" from store to client\n  request.store.transferToClient([\"data\"]);\n\n  // ..\n} This allows access to these values from the web component store. This setup also enables subsequent server actions to access the same store, as the communication flows through the client: server render â†’ client â†’ server action â†’ client It is a way to modify in a reactive way from a server action the web components that consume this store. You can encrypt store data if you want to transfer sensitive data to the server actions so that it cannot be accessed from the client.",
    "titles": [
      "Request Context",
      "store"
    ]
  },
  {
    "id": "/api-reference/components/request-context#usecontext",
    "title": "useContext",
    "text": "useContext: <T>(context: BrisaContext<T>) => { value: T } The useContext method is used to consume a context value. It takes a BrisaContext as a parameter and returns a signal containing the context value. The context value is often used for passing data between a provider and multiple consumers within a component tree. Example: const foo = useContext(context);\nreturn <div>{foo.value}</div>; For more details, refer to the context documentation. When referring to useContext, it is essential to note that this term should not be confused with the broader concept of RequestContext mentioned earlier. The useContext is a Brisa Hook for consuming context value, that is piece of data that can be shared across multiple Brisa components. The RequestContext denotes the overall environment and configuration specific to each server component, offering a unique and more comprehensive control mechanism. Understanding this distinction is crucial for a clear comprehension of our framework's architecture.",
    "titles": [
      "Request Context"
    ]
  },
  {
    "id": "/api-reference/components/request-context#indicate",
    "title": "indicate",
    "text": "indicate(actionName: string): IndicatorSignal The indicate method is used to add it in the indicator HTML extended attribute. This indicator automatically set the brisa-request class while the indicated server action is pending. const pending = indicate('some-server-action-name');\n// ...\ncss`\n span { display: none }\n span.brisa-request { display: inline }\n`\n// ...\n<>\n  <button onClick={someAction} indicateClick={pending}>\n    Run some action\n  </button>\n  <span indicator={pending}>Pending...</span>\n</>",
    "titles": [
      "Request Context"
    ]
  },
  {
    "id": "/api-reference/components/request-context#parameters",
    "title": "Parameters:",
    "text": "string - Indicator name. It can refer to the server action. The idea is that you can use the same indicator in other components (both server and web) using the same name to relate it to the same server action. For more details, take a look to: indicate in web components, similar method but from WebContext.\nindicate[Event] HTML extended attribute to use it in server components to register the server action indicator.\nindicator HTML extended attribute to use it in any element of server/web components.",
    "titles": [
      "Request Context",
      "indicate"
    ]
  },
  {
    "id": "/api-reference/components/request-context#route",
    "title": "route",
    "text": "The route is the matched route of the request. You can access to: params - for dynamic routes like /[user] you can access to params.user.\nfilePath - path of your page file.\npathname - path portion of the URL.\nquery - A record of query parameters extracted from the URL.\nname - The name associated with the route.\nkind- The type of route: exact, catch-all, optional-catch-all, or dynamic.\nsrc- The source string representing the route. Example of object: {\n  filePath: \"/Users/aralroca/Documents/brisa/fun/pages/blog/[slug].tsx\",\n  kind: \"dynamic\",\n  name: \"/blog/[slug]\",\n  pathname: \"/blog/my-cool-post\",\n  src: \"/blog/[slug].js\",\n  params: {\n    slug: \"my-cool-post\"\n  }\n} Example consuming: <div>{route.pathname}</div>",
    "titles": [
      "Request Context"
    ]
  },
  {
    "id": "/api-reference/components/request-context#i18n",
    "title": "i18n",
    "text": "i18n: I18n The i18n object provides utilities for accessing the locale and consuming translations within components. Example: const { t, locale } = i18n;\nreturn <div>{t(\"hello-world\")}</div>; For more details, refer to the i18n documentation.",
    "titles": [
      "Request Context"
    ]
  },
  {
    "id": "/api-reference/components/request-context#ws",
    "title": "ws",
    "text": "In case you have configured WebSockets, you can access them from any server component, api route, middleware, etc. The ws is of type ServerWebSocket, where is: interface ServerWebSocket {\n  readonly data: any;\n  readonly readyState: number;\n  readonly remoteAddress: string;\n  send(message: string | ArrayBuffer | Uint8Array, compress?: boolean): number;\n  close(code?: number, reason?: string): void;\n  subscribe(topic: string): void;\n  unsubscribe(topic: string): void;\n  publish(topic: string, message: string | ArrayBuffer | Uint8Array): void;\n  isSubscribed(topic: string): boolean;\n  cork(cb: (ws: ServerWebSocket) => void): void;\n} Example: import { type RequestContext } from \"brisa\";\n\nexport function GET({ ws, i18n }: RequestContext) {\n  const message = i18n.t(\"hello-world\");\n\n  // Sending a WebSocket message from an API route\n  ws.send(message);\n\n  return new Response(message, {\n    headers: { \"content-type\": \"text/plain\" },\n  });\n} For more information see Bun's WebSockets documentation.",
    "titles": [
      "Request Context"
    ]
  },
  {
    "id": "/api-reference/components/request-context#getip",
    "title": "getIP",
    "text": "The IP address of a given Request can be retrieved via getIP. Below it calls Bun's server.requestIP.",
    "titles": [
      "Request Context"
    ]
  },
  {
    "id": "/api-reference/components/request-context#finalurl",
    "title": "finalURL",
    "text": "The finalURL is the URL of your page, regardless of the fact that for the users it is another one. Example, an user enter to: /es/sobre-nosotros/ But the finalURL is: /about-us Because your page is in src/pages/about-us/index.tsx",
    "titles": [
      "Request Context"
    ]
  },
  {
    "id": "/api-reference/components/request-context#id",
    "title": "id",
    "text": "The id is the unique identifier of the request. This id is used internally by Brisa, but we expose it to you because it can be useful for tracking. Example: console.log(id); // 1edfa3c2-e101-40e3-af57-8890795dacd4",
    "titles": [
      "Request Context"
    ]
  },
  {
    "id": "/api-reference/components/request-context#renderinitiator",
    "title": "renderInitiator",
    "text": "The renderInitiator is a string that represents the initiator of the render. It can be: RenderInitiator.SERVER_ACTION - When is the rerender by a server action.\nRenderInitiator.SPA_NAVIGATION - When the render is initiated by a SPA navigation.\nRenderInitiator.INITIAL_REQUEST - When the render is initiated by the initial request. The default value is RenderInitiator.INITIAL_REQUEST. This is useful to know how the render was initiated and to make decisions based on it, for example initializing the store only in the RenderInitiator.INITIAL_REQUEST. For API routes, the renderInitiator is always RenderInitiator.INITIAL_REQUEST. Example: import { RenderInitiator } from \"brisa/server\";\n\nexport default function ServerComponent(props, requestContext) {\n  if (requestContext.renderInitiator === RenderInitiator.INITIAL_REQUEST) {\n    requestContext.store.set(\"count\", 0);\n  }\n\n  return <div>{requestContext.store.get(\"count\")}</div>;\n}",
    "titles": [
      "Request Context"
    ]
  },
  {
    "id": "/api-reference/components/request-context#css",
    "title": "css",
    "text": "css(strings: TemplateStringsArray, ...values: string[]): void The css template literal is used to inject CSS into the DOM. It allows developers to define styles directly within server components using a template literal. Unlike web components, this css template literal in server components does not encapsulate. This code would affect all divs on the page: Example: css`\n  div {\n    background-color: ${color};\n  }\n`; We recommend using the css template literal for specific cases such as generating CSS animations based on dynamic JavaScript variables. For more details, refer to the Template literal css documentation.",
    "titles": [
      "Request Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#web-context",
    "title": "Web Context",
    "text": "The WebContext is a set of utilities provided by Brisa to facilitate the development of web components. It encompasses various functionalities such as managing state, handling context, performing effects, and more. This context allows developers to create reactive web components in Brisa applications. import type { WebContext } from \"brisa\";\n\nexport default function WebComponent(props, webContext: WebContext) {\n  const {\n    // Shared data across web components\n    store,\n    useContext,\n\n    // Internal state of this web component\n    state,\n    derived,\n\n    // Manage web component effects\n    effect,\n    cleanup,\n    onMount,\n    reset,\n\n    // Generate unique identifiers (server/client)\n    useId,\n\n    // Add reactive styles\n    css,\n\n    // Consume translations and control internationalization\n    i18n,\n\n    // Access to the name, pathname, params, and query of the current\n    // page route (also available in SSR)\n    route,\n\n    // Access to the web component DOM element\n    self,\n  } = webContext;\n  // ... Web component implementation ...\n} In contrast to other frameworks that necessitate state imports, our methodology incorporates all state properties directly within each web component. This distinctive design empowers enhanced control over the web component's lifecycle, facilitating the expansion of the web context through precise core management using plugins.",
    "titles": []
  },
  {
    "id": "/api-reference/components/web-context#store",
    "title": "store",
    "text": "store: ReactiveMap The store property is a reactive map where values can be stored and shared among all web components. It serves as a global state accessible by all components. Values can be set and retrieved using the store.set, store.delete, store.get and store.has methods. Example setting a value: store.set(\"count\", 0); Example getting a value: <div>{store.get(\"count\")}</div> For more details, refer to the store documentation.",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#setoptimistic",
    "title": "setOptimistic",
    "text": "",
    "titles": [
      "Web Context",
      "store"
    ]
  },
  {
    "id": "/api-reference/components/web-context#usecontext",
    "title": "useContext",
    "text": "useContext: <T>(context: BrisaContext<T>) => { value: T } The useContext method is used to consume a context value. It takes a BrisaContext as a parameter and returns a signal containing the context value. The context value is often used for passing data between a provider and multiple consumers within a component tree. Example: const foo = useContext(context);\nreturn <div>{foo.value}</div>; For more details, refer to the context documentation. When referring to useContext, it is essential to note that this term should not be confused with the broader concept of WebContext mentioned earlier. The useContext is a Brisa Hook for consuming context value, that is piece of data that can be shared across multiple Brisa components. The WebContext denotes the overall environment and configuration specific to each web component, offering a unique and more comprehensive control mechanism. Understanding this distinction is crucial for a clear comprehension of our framework's architecture.",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#state",
    "title": "state",
    "text": "state<T>(initialValue?: T): Signal<T> The state method is used to declare reactive state variables. It returns a Signal that represents the state, and any changes to the state trigger reactivity updates in the associated components. Example declaration: const count = state<number>(0); Example usage: <div>{count.value}</div> Example mutation: count.value += 1; For more details, refer to the state documentation.",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#derived",
    "title": "derived",
    "text": "derived<T>(fn: () => T): Signal<T> The derived method is useful for creating signals derived from other signals, such as state or props. It allows developers to compute values based on existing signals. Example of declaration: const doubleCount = derived(() => count.value * 2); Example of usage: <div>{doubleCount.value}</div> For more details, refer to the derived documentation.",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#effect",
    "title": "effect",
    "text": "effect(fn: Effect): void The effect method is used to define functions that will be executed when the component is mounted and every time a registered signal within the effect changes. It helps manage side effects such as data fetching or DOM manipulation. Example: effect(() => {\n  // This log is executed every time someSignal.value changes\n  console.log(`Hello ${someSignal.value}`);\n}); For more details, refer to the effect documentation.",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#cleanup",
    "title": "cleanup",
    "text": "cleanup(fn: Cleanup): void The cleanup method defines functions that will be executed when the component is unmounted or to clean up an effect. It helps prevent memory leaks and ensures proper cleanup. Example: effect(() => {\n  window.addEventListener(\"storage\", handleOnStorage);\n  cleanup(() => window.removeEventListener(\"storage\", handleOnStorage));\n});\n\ncleanup(() => console.log(\"Web Component unmounted!\")); For more details, refer to the cleanup documentation.",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#onmount",
    "title": "onMount",
    "text": "onMount(fn: Effect): void The onMount method is triggered only once when the component is mounted. It is useful for handling actions that should occur during the initial mount, such as setting up document events or accessing rendered DOM elements. While the effect are executed on the fly, the onMount waits until the entire web component has been rendered. Example: onMount(() => {\n  console.log(\"Yeah! Component has been mounted\");\n}); For more details, refer to the onMount documentation.",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#indicate",
    "title": "indicate",
    "text": "indicate(actionName: string): IndicatorSignal The indicate method is used to add it in the indicator HTML extended attribute. This indicator automatically set the brisa-request class while the indicated server action is pending. const pending = indicate('some-server-action-name');\n// ...\ncss`\n span { display: none }\n span.brisa-request { display: inline }\n`\n// ...\n<span indicator={pending}>Pending...</span> You can also consume it as a signal to know if the server action is pending and to have more control inside the web component. const  = indicate('some-server-action-name');\n// ...\n{pending.value && <span>Pending...</span>}",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#parameters",
    "title": "Parameters:",
    "text": "string - Indicator name. It can refer to the server action. The idea is that you can use the same indicator in other components (both server and web) using the same name to relate it to the same server action. For more details, take a look to: indicate in server components, similar method but from RequestContext.\nindicate[Event] HTML extended attribute to use it in server components to register the server action indicator.\nindicator HTML extended attribute to use it in any element of server/web components.",
    "titles": [
      "Web Context",
      "indicate"
    ]
  },
  {
    "id": "/api-reference/components/web-context#reset",
    "title": "reset",
    "text": "reset(): void The reset method is used to invoke all cleanup functions and clear all effects and cleanups from the memory of the web component. It is primarily intended for internal use and is exposed but may have limited applicability in many cases. Example: reset(); The reset method is a powerful tool that should be used judiciously. It clears all effects and cleanups, potentially affecting the web component's behavior. Ensure that its usage aligns with the desired functionality and doesn't compromise the integrity of the web component.",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#useid",
    "title": "useId",
    "text": "useId(): string The useId method generates a unique identifier for the web component. It is useful for creating unique keys for elements in lists or for other purposes that require unique identifiers. The generated ID is unique across all web components and the generation is the same on the server and client. Example: const passwordHintId = useId();\n\nreturn (\n  <>\n    <input type=\"password\" aria-describedby={passwordHintId} />\n    <p id={passwordHintId}>\n  </>\n)",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#css",
    "title": "css",
    "text": "css(strings: TemplateStringsArray, ...values: string[]): void The css template literal is used to inject reactive CSS into the DOM. It allows developers to define styles directly within web components using a template literal. The styles are encapsulated within the Shadow DOM, ensuring that they do not interfere with each other across web components. Example: css`\n  div {\n    background-color: ${color.value};\n  }\n`; For more details, refer to the Template literal css documentation.",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#i18n",
    "title": "i18n",
    "text": "i18n: I18n The i18n object provides utilities for accessing the locale and consuming translations within components. Example: const { t, locale } = i18n;\nreturn <div>{t(\"hello-world\")}</div>; For more details, refer to the i18n documentation.",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#route",
    "title": "route",
    "text": "route: Route The route object provides access to the current route's name, pathname, params, and query. Example: const { name, pathname, params, query } = route; The route object is available in both server-side rendering (SSR) and client-side rendering (CSR).",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#self",
    "title": "self",
    "text": "self: HTMLElement The self property in the WebContext provides access to the DOM element of the web component. It allows developers to interact directly with the component's rendered output, enabling manipulation and customization. Example: self.addEventListener(\"click\", () => {\n  console.log(\"Web component clicked!\");\n}); It is important to exercise caution when directly manipulating the DOM element using the self property. This approach can lead to potential issues, such as conflicts with the reactive nature of Brisa components. Therefore, it is recommended to use this property judiciously and only when necessary. It is an empty object during SSR to use it in some specific cases like reseting shadowRoot.adoptedStyleSheets. Normally it is better to use it inside an effect to ensure that is executed only in the client-side.",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#expanding-the-webcontext",
    "title": "Expanding the WebContext",
    "text": "The WebContext in Brisa is intentionally designed to be extensible, providing developers with the flexibility to enhance its capabilities based on project-specific requirements. This extensibility is achieved through the integration of plugins, which are custom functionalities injected into the core of each web component.",
    "titles": [
      "Web Context"
    ]
  },
  {
    "id": "/api-reference/components/web-context#web-context-plugins",
    "title": "Web Context Plugins",
    "text": "To add plugins, you must add them in the webContextPlugins named export of the /src/web-components/_integrations.(ts|tsx|js|jsx) file. Params: Receives the preceding WebContext. Plugins are executed sequentially; if it is the initial plugin, it will contain the original WebContext, whereas for subsequent plugins, it will incorporate the WebContext modified by the preceding plugin. Return: The output will be the WebContext extended by the functionalities implemented in your plugin. It is imperative to consistently return the remaining context properties to prevent potential disruptions in web-component functionality. Note that the WebContext is utilized in server-side rendering (SSR) as well. Take this into consideration, as certain extensions may not be suitable for server-side usage. Therefore, it is recommended to employ typeof window === 'undefined' to determine if the code is running on the server.",
    "titles": [
      "Web Context",
      "Expanding the WebContext"
    ]
  },
  {
    "id": "/api-reference/components/web-context#example-tab-synchronization",
    "title": "Example: Tab Synchronization",
    "text": "src/web-components/_integrations.tsx: import type { WebContextPlugin } from \"brisa\";\n\nexport const webContextPlugins: WebContextPlugin[] = [\n  (ctx) => {\n    ctx.store.sync = (\n      key: string,\n      storage: \"localStorage\" | \"sessionStorage\" = \"localStorage\",\n    ) => {\n      // Skip execution on server side (SSR)\n      if (typeof window === \"undefined\") return;\n\n      // Sync from storage to store\n      const sync = (event?: StorageEvent) => {\n        if (event && event.key !== key) return;\n        const storageValue = window[storage].getItem(key);\n        if (storageValue != null) ctx.store.set(key, JSON.parse(storageValue));\n      };\n\n      // Add and remove \"storage\" event listener\n      ctx.effect(() => {\n        window.addEventListener(\"storage\", sync);\n        ctx.cleanup(() => window.removeEventListener(\"storage\", sync));\n      });\n\n      // Update storage when store changes\n      ctx.effect(() => {\n        const val = ctx.store.get(key);\n        if (val != null) window[storage].setItem(key, JSON.stringify(val));\n      });\n\n      sync();\n    };\n\n    // The ctx now has a new method \"sync\" that can be used to sync a\n    // store key with localStorage\n    return ctx;\n  },\n]; In this example, the behavior of the store property is modified, enabling any web component to possess the store with an additional sync method. This method facilitates reactive synchronization of a store entry with the localStorage. If another tab modifies the value, the update will be reflected reactively in the DOM. In any web component: export default async function WebComponent({ }, { store }: WebContext) {\n  store.sync(\"count\", 'localStorage');\n\n  // This value will change reactively if the localStorage\n  // \"count\" item is updated.\n  return store.get('count'); The approach to synchronizing tabs can be implemented in various ways: using web sockets, monitoring tab focus, or utilizing storage events, as demonstrated in this example. From Brisa's perspective, implementing specific signals for such scenarios might be too project-specific. Therefore, we offer the flexibility to extend these signals and access web component core extras for greater control.",
    "titles": [
      "Web Context",
      "Expanding the WebContext"
    ]
  },
  {
    "id": "/api-reference/components/web-context#example-reactive-url-params",
    "title": "Example: Reactive URL Params",
    "text": "This is another example to have params of the url reactive, working with SPA navigation, for example for filtering a list of items using the URL query parameters as state: src/web-components/_integrations.tsx import type { WebContext, WebContextPlugin } from \"brisa\";\n\nfunction paramsPlugin(ctx: WebContext) {\n  Object.assign(ctx, {\n    get params() {\n      let params = ctx.state<{ [k: string]: string }>();\n\n      ctx.effect(() => {\n        params.value = Object.fromEntries(\n          new URLSearchParams(window.location.search).entries(),\n        );\n\n        const navigate = (e: any) => {\n          params.value = Object.fromEntries(\n            new URL(e.destination.url).searchParams.entries(),\n          );\n        };\n\n        window.navigation?.addEventListener(\"navigate\", navigate);\n        ctx.cleanup(\n          () => window.navigation?.removeEventListener(\"navigate\", navigate),\n        );\n      });\n\n      return params;\n    },\n  });\n\n  return ctx;\n}\n\nexport const webContextPlugins: WebContextPlugin[] = [paramsPlugin]; Usage: import type { WebContext } from \"brisa\";\n\nexport default function SearchResult({}, { params }: WebContext) {\n  return <div>{params.value?.q}</div>;\n} A web component in the layout is not unmounted after SPA navigation. Therefore, we need the params signal to be reactive and update the component when the URL changes. Ultimately, we believe that the JavaScript community will contribute more refined signals than these examples. We encourage developers to share their signals with the community to enhance the Brisa ecosystem.",
    "titles": [
      "Web Context",
      "Expanding the WebContext"
    ]
  },
  {
    "id": "/api-reference/components/web-context#typescript",
    "title": "TypeScript",
    "text": "To extend the WebContext interface in TypeScript, create a file in the root and define the typings for your extensions: web-context.d.ts: import \"brisa\";\n\ndeclare module \"brisa\" {\n  interface WebContext {\n    /**\n     * Augmented store with sync method\n     */\n    store: BaseWebContext[\"store\"] & {\n      sync: (key: string, storage?: \"localStorage\" | \"sessionStorage\") => void;\n    };\n\n    /**\n     * Reactive URL params\n     */\n    params: Signal<{ [k: string]: string }>;\n  }\n} Modify the WebContext accordingly, and if you wish to utilize elements like the current store, you can leverage the BaseWebContext.",
    "titles": [
      "Web Context",
      "Expanding the WebContext"
    ]
  },
  {
    "id": "/api-reference/extended-props/debounceEvent#debounceevent",
    "title": "debounce[Event]",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/extended-props/debounceEvent#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "debounce[Event]"
    ]
  },
  {
    "id": "/api-reference/extended-props/debounceEvent#debounceevent400",
    "title": "debounce[Event]={400}",
    "text": "Brisa extends all the HTML element events (onInput, onMouseOver, onTouchStart...) to allow to debounce the action call by replacing the on prefix to debounce. <input\n  type=\"text\"\n  onInput={(e) => console.log(e.target.value)}\n  debounceInput={400}\n/> The time unit consistently remains in milliseconds. In this example, the call to the server and consequently the execution of console.log will only take place 400ms after the user ceases typing in the textbox.",
    "titles": [
      "debounce[Event]",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/debounceEvent#parameters",
    "title": "Parameters:",
    "text": "milliseconds - Number of milliseconds to debounce the event. Only works in the HTML elements that trigger the action, if you use it in the components as a prop it will only work if you use it inside the component to link it with the HTML element that triggers the action. The only exception is to use it in a web-component from a server component, as the web components are transformed into real HTML elements that trigger actions, then in this case it does work. This is only implemented for server actions, for browsers events inside web components it does not apply since we do not modify the original event.",
    "titles": [
      "debounce[Event]",
      "Reference",
      "debounce[Event]={400}"
    ]
  },
  {
    "id": "/api-reference/extended-props/debounceEvent#support",
    "title": "Support",
    "text": "Component\nSupport\n\n\n\n\nServer Component\nâœ…\n\n\nWeb Component\nâŒ\n\n\nSSR Web Component\nâŒ",
    "titles": [
      "debounce[Event]",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/indicateEvent#indicateevent",
    "title": "indicate[Event]",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/extended-props/indicateEvent#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "indicate[Event]"
    ]
  },
  {
    "id": "/api-reference/extended-props/indicateEvent#indicateclickindicatorsignal",
    "title": "indicateClick={IndicatorSignal}",
    "text": "Brisa extends all the HTML element events (onInput, onMouseOver, onTouchStart...) to allow to control the pending status of the server action by replacing the on prefix to indicate. The value is the generated IndicatorSignal by the indicate method: Read more docs about indicate in Server Components.\nRead more docs about indicate in Web Components. const indicator = indicate('some-action-name')\n// ...\n<input\n  type=\"text\"\n  onInput={(e) => console.log(e.target.value)}\n  indicateInput={indicator} // IndicatorSignal\n  debouceInput={300}\n/> In this example, we are registering the indicator in the onClick server action through the indicate[Event] attribute.",
    "titles": [
      "indicate[Event]",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/indicateEvent#parameters",
    "title": "Parameters:",
    "text": "IndicatorSignal - Indicator signal generared by indicate method. This indicate[Event] attribute is only implemented in server components, because the server actions are only in server components.",
    "titles": [
      "indicate[Event]",
      "Reference",
      "indicateClick={IndicatorSignal}"
    ]
  },
  {
    "id": "/api-reference/extended-props/indicateEvent#more-docs",
    "title": "More docs",
    "text": "For more details, take a look to: indicate method in server components.\nindicate method in web components.\nindicator HTML extended attribute to use it in any element of server/web components.",
    "titles": [
      "indicate[Event]",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/indicateEvent#support",
    "title": "Support",
    "text": "Component\nSupport\n\n\n\n\nServer Component\nâœ…\n\n\nWeb Component\nâŒ\n\n\nSSR Web Component\nâŒ",
    "titles": [
      "indicate[Event]",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/indicator#indicator",
    "title": "indicator",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/extended-props/indicator#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "indicator"
    ]
  },
  {
    "id": "/api-reference/extended-props/indicator#indicatorindicatorsignalorindicatorsignal",
    "title": "indicator={IndicatorSignal|IndicatorSignal[]}",
    "text": "The indicator attribute allows to pass one or several IndicatorSignal generated by the indicate function. More details about the indicate function: Read more docs about indicate in Server Components.\nRead more docs about indicate in Web Components. These indicators placed in the indicator attribute allow the brisa-request class to be added during the execution of a server action, allowing interactions with CSS from the server components such as disabling buttons, showing spinners, transitions, etc. Example of CSS: const incrementing = indicate(\"increment\");\n\nreturn (\n  <button\n    indicator={incrementing} // It adds .brisa-request in action-time\n    indicateClick={incrementing}\n    onClick={() => store.set(\"count\", store.get(\"count\") + 1)}\n  >\n    Increment\n    <span\n      indicator={incrementing} // It adds .brisa-request in action-time\n      class=\"spinner\"\n    />\n  </button>\n); Example of CSS: button.brisa-request {\n  pointer-events: none;\n  cursor: not-allowed;\n  background-color: rgba(0, 0, 0, 0.1);\n}\n.spinner,\n.btn-text.brisa-request {\n  display: none;\n}\n.spinner.brisa-request {\n  display: inline;\n}",
    "titles": [
      "indicator",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/indicator#parameters",
    "title": "Parameters:",
    "text": "IndicatorSignal |Â IndicatorSignal[] - One or several IndicatorSignal generared by indicate method.",
    "titles": [
      "indicator",
      "Reference",
      "indicator={IndicatorSignal|IndicatorSignal[]}"
    ]
  },
  {
    "id": "/api-reference/extended-props/indicator#more-docs",
    "title": "More docs",
    "text": "For more details, take a look to: indicate method in server components.\nindicate method in web components.\nindicateEvent HTML extended attribute to connect an indicator to a server action.",
    "titles": [
      "indicator",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/indicator#support",
    "title": "Support",
    "text": "Component\nSupport\n\n\n\n\nServer Component\nâœ…\n\n\nWeb Component\nâœ…\n\n\nSSR Web Component\nâœ…",
    "titles": [
      "indicator",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/key#key",
    "title": "key",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/extended-props/key#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "key"
    ]
  },
  {
    "id": "/api-reference/extended-props/key#keystring",
    "title": "key={string}",
    "text": "The key is a special string attribute you need to include when creating lists of elements. Keys help Brisa identify which items have changed, are added, or are removed. Keys should be given to the elements inside the array to give the elements a stable identity: const numbers = [1, 2, 3, 4, 5];\nconst listItems = numbers.map((number) => (\n  <li key={number.toString()}>{number}</li>\n)); The best way to pick a key is to use a string that uniquely identifies a list item among its siblings. Most often you would use IDs from your data as keys: const TodoList = ({ todos }) => {\n  return todos.map((todo) => <li key={todo.id}>{todo.text}</li>);\n}; When you donâ€™t have stable IDs for rendered items, you may use the item index as a key as a last resort. We donâ€™t recommend using indexes for keys if the order of items may change. This can negatively impact performance and may cause issues with component state.",
    "titles": [
      "key",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/key#support",
    "title": "Support",
    "text": "Component\nSupport\n\n\n\n\nServer Component\nâœ…\n\n\nWeb Component\nâœ…\n\n\nSSR Web Component\nâœ…",
    "titles": [
      "key",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/ref#ref",
    "title": "ref",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/extended-props/ref#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "ref"
    ]
  },
  {
    "id": "/api-reference/extended-props/ref#refsignal",
    "title": "ref={Signal}",
    "text": "When the ref attribute is used on an HTML element, you can access the current value of that ref through the ref.value property. export default ({}, { onMount, cleanup, state }: WebContext) => {\n  const ref = state(null);\n\n  function onClick(e) {\n    console.log(\"Event via ref\", e);\n  }\n\n  onMount(() => ref.value.addEventListener(\"click\", onClick));\n  cleanup(() => ref.value.removeEventListener(\"click\", onClick));\n\n  return <div ref={ref}>Example</div>;\n}; If you run it on an effect, keep in mind that they run before it has been mounted and you will not yet have access to the element. If you need multi-refs for an array, you can do it this way: export default (\n  { items = [] }: Props,\n  { effect, state, derived }: WebContext,\n) => {\n  // Every time the \"items\" property change,\n  // the \"derived\" updates the refs\n  const refs = derived(() =>\n    Array.from({ length: items.length }).map(() => state(null)),\n  );\n\n  effect(() => {\n    refs.value.forEach((ref, i) => {\n      if (ref.value) {\n        ref.value.innerHTML = `Updated ${i}`;\n      }\n    });\n  });\n\n  return (\n    <>\n      {items.map((item, i) => (\n        <div ref={refs.value[i]}>{item}</div>\n      ))}\n    </>\n  );\n}; Signals in Brisa, like state(), derived(), and effect() can be used without the rules of hooks. You can use them in any order and in any place in your component. This is why you can use state() inside a derived() function.",
    "titles": [
      "ref",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/ref#support",
    "title": "Support",
    "text": "Component\nSupport\n\n\n\n\nServer Component\nâŒ\n\n\nWeb Component\nâœ…\n\n\nSSR Web Component\nâœ…",
    "titles": [
      "ref",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/renderMode#rendermode",
    "title": "renderMode",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/extended-props/renderMode#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "renderMode"
    ]
  },
  {
    "id": "/api-reference/extended-props/renderMode#rendermodereactivity-or-transition-or-native",
    "title": "renderMode={'reactivity' | 'transition' | 'native'}",
    "text": "The renderMode attribute is present on the <a> element to specify the render mode of the next document after following the link. There are three possible values: reactivity: The next document will be rendered using reactivity. It only changes the parts of the page that have changed, perserving Web Component states.\ntransition: The next document will be rendered using reactivity and also using View Transition API.\nnative: The next document will be rendered using the browser's native rendering engine. By default, the value is reactivity. Note: If the origin of the next document is different from the current document, the value will be ignored, and the next document will be rendered using the browser's native rendering engine. Example: return <a href=\"/\" renderMode=\"transition\" />;",
    "titles": [
      "renderMode",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/renderMode#support",
    "title": "Support",
    "text": "Component\nSupport\n\n\n\n\nServer Component\nâœ…\n\n\nWeb Component\nâœ…\n\n\nSSR Web Component\nâœ…",
    "titles": [
      "renderMode",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/renderOn#renderon",
    "title": "renderOn",
    "text": "Useful for prerendering components in build time. You can mix static and dynamic content in the same page thanks of this partial prerendering attribute. To make this possible, optimizations are made in build-time and the Bun Macros are used connected to our internal rendering to make it easier for you to do it. You have to take into account that it will improve the time to render the page in runtime, but at the same time it will worsen the build time.",
    "titles": []
  },
  {
    "id": "/api-reference/extended-props/renderOn#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "renderOn"
    ]
  },
  {
    "id": "/api-reference/extended-props/renderOn#renderonbuild-or-runtime",
    "title": "renderOn={'build' | 'runtime'}",
    "text": "The renderOn attribute is present on the <Component> element to specify the rendering mode of the component. There are two possible values: build: The component will be prerendered in build time.\nruntime: The component will be rendered in runtime. (default) By default, the value is runtime. Example: Imagine we have this component that makes an external request for static resources: src/components/some-component.tsx: export default async function SomeComponent() {\n   const res = await fetch(/* some external service */);\n\n   return <div>Result: {await res.json()}</div>\n} Then it is consumed from some page or another component with the renderOn prop as build: return <SomeComponent renderOn=\"build\" />; Then, it will be automatically transformed at build-time to a return similar to this: return dangerHTML('<div>Result: foo</div>') You can also use it in Web Components, for example: return <web-component renderOn=\"build\" />; And it will be transformed to: return dangerHTML('<web-component><template shadowroot=\"open\">Result: foo</template></web-component>') Only the initial HTML of the web component can be prerendered, once it is hydrated it will be rendered again from the client. The rest of the properties that are passed to it must be serializable and static, as they are executed at build time. Otherwise, it will throw an error. The attribute in the web components is stripped and will not be visible in the DOM.",
    "titles": [
      "renderOn",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/renderOn#support",
    "title": "Support",
    "text": "Component\nSupport\n\n\n\n\nServer Component\nâœ…\n\n\nSSR Web Component\nâœ…",
    "titles": [
      "renderOn",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/skipSSR#skipssr",
    "title": "skipSSR",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/extended-props/skipSSR#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "skipSSR"
    ]
  },
  {
    "id": "/api-reference/extended-props/skipSSR#skipssrboolean",
    "title": "skipSSR={boolean}",
    "text": "Use skipSSR attribute to run web components only in client-side skipping the server-side rendering (SSR). There are cases where we can avoid the SSR of some web component. It makes sense for these web components that are not available in the initial rendered page, for example they appear after some web interaction, such as a modal. To do this, all web components have available the skipSSR attribute. It's true by default (this attribute does not need to be used when it is true), but you can use it to turn to false. This can be used in any web-component, either consumed from another web-component or from a server component. return <some-web-component skipSSR />;",
    "titles": [
      "skipSSR",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/extended-props/skipSSR#support",
    "title": "Support",
    "text": "It can be used in both Server Components and Web Components, but the attribute must always be in a custom element, i.e. a web component.",
    "titles": [
      "skipSSR",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/functions/createContext#createcontext",
    "title": "createContext",
    "text": "createContext lets you create a context that components can provide or read. It is used to create a context with a default value.",
    "titles": []
  },
  {
    "id": "/api-reference/functions/createContext#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "createContext"
    ]
  },
  {
    "id": "/api-reference/functions/createContext#createcontextdefaultvalue",
    "title": "createContext(defaultValue)",
    "text": "Call createContext outside of any components to create a context. import { createContext } from \"brisa\";\n\nconst defaultValue = \"foo\";\nconst SomeContext = createContext(defaultValue);",
    "titles": [
      "createContext",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/functions/createContext#parameters",
    "title": "Parameters:",
    "text": "defaultValue: The value that you want the context to have when there is no matching context provider in the tree above the component that reads context. If you donâ€™t have any meaningful default value, specify null. The default value is meant as a â€œlast resortâ€ fallback. It is static and never changes over time.",
    "titles": [
      "createContext",
      "Reference",
      "createContext(defaultValue)"
    ]
  },
  {
    "id": "/api-reference/functions/createContext#returns",
    "title": "Returns:",
    "text": "createContext returns a context object. Typically, you will use this context in a context-provider component, or the useContext hook.",
    "titles": [
      "createContext",
      "Reference",
      "createContext(defaultValue)"
    ]
  },
  {
    "id": "/api-reference/functions/createContext#support",
    "title": "Support",
    "text": "Component\nSupport\n\n\n\n\nServer Component\nâœ…\n\n\nWeb Component\nâœ…\n\n\nSSR Web Component\nâœ…",
    "titles": [
      "createContext",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/functions/createPortal#createportal",
    "title": "createPortal",
    "text": "createPortal lets you render some children into a different part of the DOM.",
    "titles": []
  },
  {
    "id": "/api-reference/functions/createPortal#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "createPortal"
    ]
  },
  {
    "id": "/api-reference/functions/createPortal#createportalchildren-domnode",
    "title": "createPortal(children, domNode)",
    "text": "To create a portal, call createPortal, passing some JSX, and the DOM node where it should be rendered: import { createPortal } from \"brisa\";\n\n// ...\n\n<div>\n  <p>This child is placed in the parent div.</p>\n  {createPortal(\n    <p>This child is placed in the document body.</p>,\n    document.body,\n  )}\n</div>; A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the Brisa component that renders it. We recommend cleanup the portal when the component is unmounted. You can do this by using the cleanup function inside the Web Context API.",
    "titles": [
      "createPortal",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/functions/createPortal#parameters",
    "title": "Parameters:",
    "text": "children: Anything that can be rendered with Brisa, such as a piece of JSX (e.g. <div /> or <SomeComponent />), a Fragment (<>...</>), a string or a number, or an array of these.\ndomNode: Some DOM node, such as those returned by document.querySelector(). The node must already exist. Passing a different DOM node during an update will cause the portal content to be recreated.",
    "titles": [
      "createPortal",
      "Reference",
      "createPortal(children, domNode)"
    ]
  },
  {
    "id": "/api-reference/functions/createPortal#returns",
    "title": "Returns:",
    "text": "createPortal returns a node that can be included into JSX or returned from a component. If Brisa encounters it in the render output, it will place the provided children inside the provided domNode.",
    "titles": [
      "createPortal",
      "Reference",
      "createPortal(children, domNode)"
    ]
  },
  {
    "id": "/api-reference/functions/createPortal#support",
    "title": "Support",
    "text": "Component\nSupport\n\n\n\n\nServer Component\nâŒ\n\n\nWeb Component\nâœ…\n\n\nSSR Web Component\nâŒ",
    "titles": [
      "createPortal",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/functions/dangerHTML#dangerhtml",
    "title": "dangerHTML",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/functions/dangerHTML#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "dangerHTML"
    ]
  },
  {
    "id": "/api-reference/functions/dangerHTML#dangerhtmlhtml-string-jsxelement",
    "title": "dangerHTML(html: string): JSX.Element",
    "text": "Make situations that we want to inject HTML that we have in string to the DOM. For these occasions, you can use the dangerHTML function. Since without this function it is escaped by security. import { dangerHTML } from \"brisa\";\n\nexport default function SomeComponent() {\n  return (\n    <>\n      {/* Escaped by default (doesn't work for security): */}\n      {'<script>alert(\"This is escaped and is not going to work\")</script>'}\n\n      {/* Force to inject an string as HTML: */}\n      {dangerHTML(\n        '<script>alert(\"This is injected and is going to work\")</script>',\n      )}\n    </>\n  );\n} Another way to use dangerHTML is to import an HTML file and inject it into the DOM. For this, you can use the with keyword to import the file with the type text. import html from \"./file.html\" with { type: \"text\" };\n\nexport default function Page() {\n  return dangerHTML(html);\n} By serving the HTML in this way, only 1 chunk will be sent during the streaming of the HTML without having to waste time rendering the JSX. A better way to serve static HTML without having to render is prerendering the page or using the renderOn extended property to prerender only some parts of the page.",
    "titles": [
      "dangerHTML",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/functions/dangerHTML#parameters",
    "title": "Parameters:",
    "text": "html: The HTML code in string that you want to inject.",
    "titles": [
      "dangerHTML",
      "Reference",
      "dangerHTML(html: string): JSX.Element"
    ]
  },
  {
    "id": "/api-reference/functions/dangerHTML#returns",
    "title": "Returns:",
    "text": "DangerHTMLOutput It is a JSX element type that Brisa JSX-runtime understands as an element.",
    "titles": [
      "dangerHTML",
      "Reference",
      "dangerHTML(html: string): JSX.Element"
    ]
  },
  {
    "id": "/api-reference/functions/dangerHTML#support",
    "title": "Support",
    "text": "Component\nSupport\n\n\n\n\nServer Component\nâœ…\n\n\nWeb Component\nâœ…\n\n\nSSR Web Component\nâœ…",
    "titles": [
      "dangerHTML",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/functions/navigate#navigate",
    "title": "navigate",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/functions/navigate#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "navigate"
    ]
  },
  {
    "id": "/api-reference/functions/navigate#navigateroute-string-options-rendermode-transition-or-reactivity-or-native-never",
    "title": "navigate(route: string, options?: { renderMode?: 'transition' | 'reactivity' | 'native' }): never",
    "text": "The navigate function is used for imperative navigation. import { navigate } from \"brisa\";\n\n// ...\nnavigate(\"/some-page\"); The navigate function can be used both on the client and on the server. Although there are some differences to be taken into account: If the navigation is done before sending the response (in the middleware, responseHeaders or an API endpoint for example), instead of modifying the navigation history it does a 301 redirect.\nIf it is done during rendering, a soft redirect is made.\nIf used inside a client-event or a server-event (action) a new page is always generated in the navigation history. All i18n navigaton rules apply equally in this function.",
    "titles": [
      "navigate",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/functions/navigate#parameters",
    "title": "Parameters:",
    "text": "route: The string with the page route name. Ex: /about-us\noptions: The object with the navigation options. Ex: { renderMode: 'transition' }\n\nrenderMode: The string with the render mode. Supported: 'transition', 'reactivity', 'native'. (default: 'reactivity' when the render mode is applicable, otherwise 'native') The usage of renderMode is not applicable in the cases that use a hard redirect. Only is applicable in the cases that use a server soft redirect or execute a client-side navigation. Otherwise, always the native render mode is used.",
    "titles": [
      "navigate",
      "Reference",
      "navigate(route: string, options?: { renderMode?: 'transition' | 'reactivity' | 'native' }): never"
    ]
  },
  {
    "id": "/api-reference/functions/navigate#returns",
    "title": "Returns:",
    "text": "Never does not require you to use return navigate('/some') due to using the TypeScript never type. Avoid using the navigate inside a try/catch block. The navigate is a throwable function and will break the execution of the current function.",
    "titles": [
      "navigate",
      "Reference",
      "navigate(route: string, options?: { renderMode?: 'transition' | 'reactivity' | 'native' }): never"
    ]
  },
  {
    "id": "/api-reference/functions/navigate#support",
    "title": "Support",
    "text": "Component\nSupport\n\n\n\n\nServer Component\nâœ…\n\n\nWeb Component\nâœ…\n\n\nSSR Web Component\nâœ…\n\n\nActions\nâœ…\n\n\nMiddleware\nâœ…\n\n\nResponse headers\nâœ…",
    "titles": [
      "navigate",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/functions/notFound#notfound",
    "title": "notFound",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/functions/notFound#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "notFound"
    ]
  },
  {
    "id": "/api-reference/functions/notFound#notfound-never",
    "title": "notFound(): Never",
    "text": "The notFound function allows you to render the 404 page within a route segment as well as inject a <meta name=\"robots\" content=\"noindex\" /> tag. Invoking the notFound() function throws a NotFoundError error and terminates rendering of the route segment in which it was thrown. //src/pages/user/[id].jsx\nimport { notFound } from \"brisa\";\n\nasync function fetchUser(id) {\n  const res = await fetch(\"https://...\");\n  if (!res.ok) return undefined;\n  return res.json();\n}\n\nexport default async function UserProfile({}, req) {\n  const user = await fetchUser(req.route.params.id);\n\n  if (!user) {\n    notFound();\n  }\n\n  // ...\n}\n\n\n\n//src/pages/user/[id].tsx\nimport type { RequestContext } from \"brisa\";\nimport { notFound } from \"brisa\";\n\ntype UserType = {\n  //...\n};\n\nasync function fetchUser(id: number | string) {\n  const res = await fetch(\"https://...\");\n  if (!res.ok) return undefined;\n  return res.json();\n}\n\nexport default async function UserProfile({}, req: RequestContext) {\n  const user: UserType = await fetchUser(req.route.params.id);\n\n  if (!user) {\n    notFound();\n  }\n\n  // ...\n}\n\nUseful to control response status during streaming:\n\nBefore response streaming (middleware, responseHeaders): It's returning the response with 404 status and the 404 page\nDuring response streaming (layout, page, components): Adds the meta tag with noindex, stop rendering the page and sends a client script to replace the page to the 404 page. This redirect is for UX to display the 404 content, here the bots will no longer see that because it has the noindex. However, this soft redirect that is done on the client does not change the browsing history and does receive the 404 status. The browsers normally cache very well the pages that return status 404.\nDuring a server action: (server events captured with actions): as the rendering has already been done and it is a post-render action, the 404 in an action acts similarly as in the middle of the streaming. The same happens if in the action instead of calling notFound() directly you do a rerender and the component calls notFound().\n\nParameters\n\nvoid. It does not support parameters.\n\nReturns\n\nNever does not require you to use return notFound() due to using the TypeScript never type.\n\n\n\nAvoid using the notFound inside a try/catch block. The navigate is a throwable function and will break the execution of the current function.\n\nSupport\n\n\n\nComponent\nSupport\n\n\n\n\nServer Component\nâœ…\n\n\nWeb Component\nâœ…\n\n\nSSR Web Component\nâœ…\n\n\nActions\nâœ…\n\n\nMiddleware\nâœ…\n\n\nResponse headers\nâœ…",
    "titles": [
      "notFound",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/functions/notFound#parameters",
    "title": "Parameters",
    "text": "void. It does not support parameters.",
    "titles": [
      "notFound",
      "Reference",
      "notFound(): Never"
    ]
  },
  {
    "id": "/api-reference/functions/notFound#returns",
    "title": "Returns",
    "text": "Never does not require you to use return notFound() due to using the TypeScript never type. Avoid using the notFound inside a try/catch block. The navigate is a throwable function and will break the execution of the current function.",
    "titles": [
      "notFound",
      "Reference",
      "notFound(): Never"
    ]
  },
  {
    "id": "/api-reference/functions/notFound#support",
    "title": "Support",
    "text": "Component\nSupport\n\n\n\n\nServer Component\nâœ…\n\n\nWeb Component\nâœ…\n\n\nSSR Web Component\nâœ…\n\n\nActions\nâœ…\n\n\nMiddleware\nâœ…\n\n\nResponse headers\nâœ…",
    "titles": [
      "notFound",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#throwable",
    "title": "throwable",
    "text": "throwable is an object that contains methods to check if an error is an internal Brisa trowable. It is used to handle specific scenarios such as re-rendering, navigation, and not-found errors. throwable.is: checks all throwable types.\nthrowable.isRerender checks if an error is a re-render throwable (from rerenderInAction API).\nthrowable.isNavigate checks if an error is a navigate throwable (from navigate API).\nthrowable.isNotFound checks if an error is a not-found throwable (from notFound API).",
    "titles": []
  },
  {
    "id": "/api-reference/functions/throwable#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "throwable"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#throwableiserror-error-boolean",
    "title": "throwable.is(error: Error): boolean",
    "text": "The throwable.is function checks if a given error is some of the Brisa throwables: re-rendering, navigation, and not-found errors.",
    "titles": [
      "throwable",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#example-usage",
    "title": "Example usage",
    "text": "import {throwable} from \"brisa\";\n\n// ...\ncatch (error) {\n  if (throwable.is(error)) throw error;\n}",
    "titles": [
      "throwable"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#parameters",
    "title": "Parameters:",
    "text": "error: The error object that needs to be checked if it's a Throwable.",
    "titles": [
      "throwable",
      "Example usage"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#returns",
    "title": "Returns:",
    "text": "A boolean indicating whether the provided error is an instance of the Throwable class.",
    "titles": [
      "throwable",
      "Example usage"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#submethods",
    "title": "Submethods",
    "text": "",
    "titles": [
      "throwable"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#throwableisrerendererror-error-boolean",
    "title": "throwable.isRerender(error: Error): boolean",
    "text": "Determines if an error is a Throwable instance for re-rendering. import {throwable} from \"brisa\";\n\n// ...\ncatch (error) {\n  if (throwable.isRerender(error)) {\n    console.log(\"It's a rerender throwable!\");\n  }\n}",
    "titles": [
      "throwable",
      "Submethods"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#parameters-1",
    "title": "Parameters:",
    "text": "error: The error object that needs to be checked if it's a rerender throwable.",
    "titles": [
      "throwable",
      "Submethods",
      "throwable.isRerender(error: Error): boolean"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#returns-1",
    "title": "Returns:",
    "text": "A boolean indicating whether the provided error is an instance of the rerender throwable.",
    "titles": [
      "throwable",
      "Submethods",
      "throwable.isRerender(error: Error): boolean"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#throwableisnavigateerror-error-boolean",
    "title": "throwable.isNavigate(error: Error): boolean",
    "text": "Determines if an error is a Throwable instance for navigation. import {throwable} from \"brisa\";\n\n// ...\ncatch (error) {\n  if (throwable.isNavigate(error)) {\n    console.log(\"It's a navigate throwable!\");\n  }\n}",
    "titles": [
      "throwable",
      "Submethods"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#parameters-2",
    "title": "Parameters:",
    "text": "error: The error object that needs to be checked if it's a navigate throwable.",
    "titles": [
      "throwable",
      "Submethods",
      "throwable.isNavigate(error: Error): boolean"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#returns-2",
    "title": "Returns:",
    "text": "A boolean indicating whether the provided error is an instance of the navigate throwable.",
    "titles": [
      "throwable",
      "Submethods",
      "throwable.isNavigate(error: Error): boolean"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#throwableisnotfounderror-error-boolean",
    "title": "throwable.isNotFound(error: Error): boolean",
    "text": "Determines if an error is a Throwable instance for not-found errors. import {throwable} from \"brisa\";\n\n// ...\ncatch (error) {\n  if (throwable.isNotFound(error)) {\n    console.log(\"It's a not-found throwable!\");\n  }\n}",
    "titles": [
      "throwable",
      "Submethods"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#parameters-3",
    "title": "Parameters:",
    "text": "error: The error object that needs to be checked if it's a notFound throwable.",
    "titles": [
      "throwable",
      "Submethods",
      "throwable.isNotFound(error: Error): boolean"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#returns-3",
    "title": "Returns:",
    "text": "A boolean indicating whether the provided error is an instance of the notFound throwable.",
    "titles": [
      "throwable",
      "Submethods",
      "throwable.isNotFound(error: Error): boolean"
    ]
  },
  {
    "id": "/api-reference/functions/throwable#types",
    "title": "Types",
    "text": "interface Throwable {\n  is: (error: Error) => boolean;\n  isRerender: (error: Error) => boolean;\n  isNavigate: (error: Error) => boolean;\n  isNotFound: (error: Error) => boolean;\n}\n\nexport const throwable: Throwable;",
    "titles": [
      "throwable"
    ]
  },
  {
    "id": "/api-reference/server-apis/fileSystemRouter#filesystemrouter",
    "title": "fileSystemRouter",
    "text": "The fileSystemRouter API is used to serve files from the file system. Internally, we use it for pages and API routes. pages\nâ”œâ”€â”€ index.tsx\nâ”œâ”€â”€ settings.tsx\nâ”œâ”€â”€ blog\nâ”‚   â”œâ”€â”€ [slug].tsx\nâ”‚   â””â”€â”€ index.tsx\nâ””â”€â”€ [[...catchall]].tsx The API of fileSystemRouter is the same API of Bun.FileSystemRouter with some differences: You can also use the fileSystemRouter API in Node.js.\nThere are some fixes and improvements in the API.\nThe fileSystemRouter API (with Bun runtime) is faster than the Bun.FileSystemRouter API. The fileSystemRouter API is used internally by the Brisa server to serve files from the file system. However, you can also use it in your Custom Server.",
    "titles": []
  },
  {
    "id": "/api-reference/server-apis/fileSystemRouter#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "fileSystemRouter"
    ]
  },
  {
    "id": "/api-reference/server-apis/fileSystemRouter#filesystemrouteroptions-filesystemrouteroptions-filesystemrouter",
    "title": "fileSystemRouter(options: FileSystemRouterOptions): FileSystemRouter",
    "text": "The fileSystemRouter function creates a new instance of the file system router.",
    "titles": [
      "fileSystemRouter",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/server-apis/fileSystemRouter#parameters",
    "title": "Parameters",
    "text": "options: An object with the following properties:\n\ndir: The directory to serve files from.\nfileExtensions: An array of file extensions to serve. Default: ['.tsx', '.jsx', '.ts', '.mjs', '.cjs', '.js'].",
    "titles": [
      "fileSystemRouter",
      "Reference",
      "fileSystemRouter(options: FileSystemRouterOptions): FileSystemRouter"
    ]
  },
  {
    "id": "/api-reference/server-apis/fileSystemRouter#returns",
    "title": "Returns",
    "text": "A FileSystemRouter object with the following properties:\n\nroutes: Entries with the routes and file paths. [pathname, filePath][].\nmatch(route: string): MatchedBrisaRoute | null: A function to match a route with the file system routes.",
    "titles": [
      "fileSystemRouter",
      "Reference",
      "fileSystemRouter(options: FileSystemRouterOptions): FileSystemRouter"
    ]
  },
  {
    "id": "/api-reference/server-apis/fileSystemRouter#example-usage",
    "title": "Example usage",
    "text": "import path from 'node:path';\nimport { fileSystemRouter } from 'brisa/server';\n\nconst router = fileSystemRouter({\n  dir: path.join(import.meta.dirname, 'pages'),\n});\n\nconst matchedRoute = router.match('/blog/hello-world?foo=bar');\n\nif (matchedRoute) {\n  console.log(matchedRoute); \n  // {\n  //   filePath: 'pages/blog/[slug].tsx',\n  //   kind: 'dynamic',\n  //   name: '/blog/[slug]',\n  //   pathname: '/blog/hello-world',\n  //   src: 'blog/[slug].tsx',\n  //   params: { slug: 'hello-world' },\n  //   query: { foo: 'bar' },\n  // }\n}",
    "titles": [
      "fileSystemRouter"
    ]
  },
  {
    "id": "/api-reference/server-apis/fileSystemRouter#match-method",
    "title": "match method",
    "text": "The match method receives a route and returns a MatchedBrisaRoute object or null.",
    "titles": [
      "fileSystemRouter"
    ]
  },
  {
    "id": "/api-reference/server-apis/fileSystemRouter#matchedbrisaroute",
    "title": "MatchedBrisaRoute",
    "text": "The MatchedBrisaRoute object has the following properties: filePath: The file path of the matched route.\nkind: The kind of route (exact, dynamic, catch-all, optional-catch-all).\nname: The route name.\npathname: The matched pathname.\nsrc: The source file path.\nparams: The route params.\nquery: The route query.",
    "titles": [
      "fileSystemRouter",
      "match method"
    ]
  },
  {
    "id": "/api-reference/server-apis/fileSystemRouter#routes-property",
    "title": "routes property",
    "text": "The routes property is the entries of routes and file paths. routes entries are in alphabetical order import path from 'node:path';\nimport { fileSystemRouter } from 'brisa/server';\n\nconst router = fileSystemRouter({\n  dir: path.join(import.meta.dirname, 'pages'),\n});\n\nconsole.log(router.routes);\n// [\n//   ['/', '/Users/aralroca/my-app/src/pages/index.tsx'],\n//   ['/[[...catchall]]', '/Users/aralroca/my-app/src/pages/[[...catchall]].tsx'],\n//   ['/blog', '/Users/aralroca/my-app/src/pages/blog/index.tsx'],\n//   ['/blog/[slug]', '/Users/aralroca/my-app/src/pages/blog/[slug].tsx'],\n//   ['/settings', '/Users/aralroca/my-app/src/pages/settings.tsx'],\n// ]",
    "titles": [
      "fileSystemRouter"
    ]
  },
  {
    "id": "/api-reference/server-apis/getServeOptions#getserveoptions",
    "title": "getServeOptions",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/server-apis/getServeOptions#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "getServeOptions"
    ]
  },
  {
    "id": "/api-reference/server-apis/getServeOptions#getserveoptions-promiselessserveoptionsgreater",
    "title": "getServeOptions(): Promise<ServeOptions>",
    "text": "The getServeOptions function is used to get the serve options of Brisa to make a custom server.",
    "titles": [
      "getServeOptions",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/server-apis/getServeOptions#returns",
    "title": "Returns:",
    "text": "A Promise that resolves to the Brisa ServeOptions. Example usage: import { getServeOptions, serve } from \"brisa/server\";\n\nconst serveOptions = await getServeOptions();\n\nconst { server, port, hostname } = serve({\n  ...serveOptions,\n  fetch(req, server) {\n    // Your implementation here ...\n\n    // Brisa handler\n    return serveOptions.fetch(req, server);\n  },\n  port: 3001,\n});\n\nconsole.log(\n  \"Server ready ðŸ¥³\",\n  `listening on http://${hostname}:${port}...`,\n);",
    "titles": [
      "getServeOptions",
      "Reference",
      "getServeOptions(): Promise<ServeOptions>"
    ]
  },
  {
    "id": "/api-reference/server-apis/getServeOptions#types",
    "title": "Types",
    "text": "ServeOptions type are all the options to use with Bun.serve.",
    "titles": [
      "getServeOptions",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/server-apis/node/handler#handler",
    "title": "handler",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/server-apis/node/handler#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "handler"
    ]
  },
  {
    "id": "/api-reference/server-apis/node/handler#handlerreq-httpincomingmessage-res-httpserverresponse-promiselessvoidgreater",
    "title": "handler(req: http.IncomingMessage, res: http.ServerResponse): Promise<void>",
    "text": "The handler function is the user Brisa handler to handle the incoming requests. You can use it to create a custom server.",
    "titles": [
      "handler",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/server-apis/node/handler#example-usage",
    "title": "Example usage:",
    "text": "In the next example, we use the handler function to create a built-in http.createServer and set up your own custom server: import http from \"node:http\";\nimport { handler } from \"brisa/server\";\n\nasync function customServer(req, res) {\n  // Your implementation here ...\n  await handler(req, res);\n}\n\nconst server = http.createServer(customServer).listen(3001); Alternatively, you can use the handler function to create a custom server with Express, Connect or Polka: /// file: my-server.js\nimport { handler } from './build/handler.js';\nimport express from 'express';\n\nconst app = express();\n\n// add a route that lives separately from the SvelteKit app\napp.get('/healthcheck', (req, res) => {\n\tres.end('ok');\n});\n\n// let Brisa handle everything else, including serving prerendered pages and static assets\napp.use(handler);\n\napp.listen(3000, () => {\n\tconsole.log('listening on port 3000');\n});",
    "titles": [
      "handler"
    ]
  },
  {
    "id": "/api-reference/server-apis/node/handler#types",
    "title": "Types",
    "text": "export function handler(\n  req: http.IncomingMessage,\n  res: http.ServerResponse,\n): Promise<void>;",
    "titles": [
      "handler"
    ]
  },
  {
    "id": "/api-reference/server-apis/node/serve#serve",
    "title": "serve",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/server-apis/node/serve#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "serve"
    ]
  },
  {
    "id": "/api-reference/server-apis/node/serve#serve-port-port-number-port-number-hostname-string-server-returntypelesstypeof-httpcreateservergreater",
    "title": "serve({ port }: { port: number }): { port: number; hostname: string; server: ReturnType<typeof http.createServer>; }",
    "text": "The serve function is used to start the Node.js server and listen for incoming requests.",
    "titles": [
      "serve",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/server-apis/node/serve#example-usage",
    "title": "Example usage:",
    "text": "In the next example, we use the serve function to start the Node.js server. import { serve } from \"brisa/server/node\";\n\nconst { server, port, hostname } = serve({\n  port: 3001,\n});\n\nconsole.log(\n  \"Node.js Server ready ðŸ¥³\",\n  `listening on http://${hostname}:${port}...`,\n); Keep in mind that the serve for Node.js is not in brisa/server but in brisa/server/node. It only makes sense to use it if you need a custom server for extra things from the serve but if you start the server in the same way as Brisa.",
    "titles": [
      "serve"
    ]
  },
  {
    "id": "/api-reference/server-apis/node/serve#types",
    "title": "Types",
    "text": "export function serve({ port }: { port: number }): {\n  port: number;\n  hostname: string;\n  server: ReturnType<typeof http.createServer>;\n};",
    "titles": [
      "serve"
    ]
  },
  {
    "id": "/api-reference/server-apis/RenderInitiator#renderinitiator",
    "title": "RenderInitiator",
    "text": "Similar to an enum, RenderInitiator is an object that contains the following properties: INITIAL_REQUEST: Indicates that the rendering was initiated by an initial request.\nSPA_NAVIGATION: Indicates that the rendering was initiated by a SPA navigation.\nSERVER_ACTION: Indicates that the rendering was initiated by a server action.",
    "titles": []
  },
  {
    "id": "/api-reference/server-apis/RenderInitiator#example-usage",
    "title": "Example usage:",
    "text": "In the next example, we use RenderInitiator to determine if the render was initiated by a server action. import { RenderInitiator } from 'brisa';\n\nexport default function MyComponent(props, { renderInitiator }) {\n  const isAnAction = renderInitiator === RenderInitiator.SERVER_ACTION;\n  return (\n    <div>\n      {isAnAction ? 'This is a rerender from an action' : 'Another type of render'}\n    </div>\n  );\n}",
    "titles": [
      "RenderInitiator"
    ]
  },
  {
    "id": "/api-reference/server-apis/RenderInitiator#types",
    "title": "Types:",
    "text": "export interface RenderInitiatorType {\n  readonly INITIAL_REQUEST: 'INITIAL_REQUEST';\n  readonly SPA_NAVIGATION: 'SPA_NAVIGATION';\n  readonly SERVER_ACTION: 'SERVER_ACTION';\n}\n\nexport const RenderInitiator: RenderInitiatorType;",
    "titles": [
      "RenderInitiator"
    ]
  },
  {
    "id": "/api-reference/server-apis/renderToReadableStream#rendertoreadablestream",
    "title": "renderToReadableStream",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/server-apis/renderToReadableStream#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "renderToReadableStream"
    ]
  },
  {
    "id": "/api-reference/server-apis/renderToReadableStream#rendertoreadablestreamelement-jsxelement-options-options-readablestreamlessanygreater",
    "title": "renderToReadableStream(element: JSX.Element, options: Options): ReadableStream<any>",
    "text": "The renderToReadableStream function is used to render a JSX element to a stream on the server side.",
    "titles": [
      "renderToReadableStream",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/server-apis/renderToReadableStream#parameters",
    "title": "Parameters:",
    "text": "element: The JSX element to render.\noptions: Options is an object with request, head, log and applySuspense, these is Options the type:type Options = {\n  request: Request | RequestContext;\n  head?: ComponentType;\n  log?: boolean;\n  applySuspense?: boolean;\n}; The request parameter is mandatory here. Meanwhile the head, log and applySuspense are optional. The\ndefault value for log is true. The default value for applySuspense is true because renderToReadableStream is used for streaming and we need to apply suspense to avoid blocking the chunks.",
    "titles": [
      "renderToReadableStream",
      "Reference",
      "renderToReadableStream(element: JSX.Element, options: Options): ReadableStream<any>"
    ]
  },
  {
    "id": "/api-reference/server-apis/renderToReadableStream#returns",
    "title": "Returns:",
    "text": "A Promise that resolves to a string representing the rendered JSX element. Example usage: import { renderToReadableStream } from \"brisa\";\n\nconst stream = renderToReadableStream(<div>Hello, world!</div>, {\n  request: new Request(\"http://localhost\"),\n});\n\nconsole.log(await Bun.readableStreamToText(stream)); // Output: '<div>Hello, world!</div>' In principle you should never use it inside Brisa Framework.",
    "titles": [
      "renderToReadableStream",
      "Reference",
      "renderToReadableStream(element: JSX.Element, options: Options): ReadableStream<any>"
    ]
  },
  {
    "id": "/api-reference/server-apis/renderToString#rendertostring",
    "title": "renderToString",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/server-apis/renderToString#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "renderToString"
    ]
  },
  {
    "id": "/api-reference/server-apis/renderToString#rendertostringelement-jsxelement-request-request-promiselessstringgreater",
    "title": "renderToString(element: JSX.Element, request?: Request): Promise<string>",
    "text": "The renderToString function is used to render a JSX element to a string on the server side.",
    "titles": [
      "renderToString",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/server-apis/renderToString#parameters",
    "title": "Parameters:",
    "text": "element: The JSX element to render.\noptions (optional): An optional object with request and applySuspense. Types: export async function renderToString(\n  element: JSX.Element,\n  options: { request?: Request; applySuspense?: boolean } = {},\n): Promise<string>; The request parameter by default is new Request('http://localhost'). The request object can be used inside the JSX Server Components, for this, you can change the default value to the request object that you want to use. The default value for applySuspense is false. Normally, we only need suspense during HTML streaming, so we don't need to apply it when rendering to a string. However, if you want to apply suspense, you can set applySuspense to true.",
    "titles": [
      "renderToString",
      "Reference",
      "renderToString(element: JSX.Element, request?: Request): Promise<string>"
    ]
  },
  {
    "id": "/api-reference/server-apis/renderToString#returns",
    "title": "Returns:",
    "text": "A Promise that resolves to a string representing the rendered JSX element. Example usage: import { renderToString } from \"brisa\";\n\nconst htmlString = await renderToString(<div>Hello, world!</div>);\nconsole.log(htmlString); // Output: '<div>Hello, world!</div>' In principle you should never use it inside Brisa Framework.",
    "titles": [
      "renderToString",
      "Reference",
      "renderToString(element: JSX.Element, request?: Request): Promise<string>"
    ]
  },
  {
    "id": "/api-reference/server-apis/rerenderInAction#rerenderinaction",
    "title": "rerenderInAction",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/server-apis/rerenderInAction#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "rerenderInAction"
    ]
  },
  {
    "id": "/api-reference/server-apis/rerenderInAction#rerenderinpage-type-rendermode-props-rerenderinaction-never",
    "title": "rerenderInPage({ type, renderMode, props }: RerenderInAction): Never",
    "text": "The rerenderInAction method is used to rerender the component or the page\ninside a server action. Outside of an action, it throws an error. rerenderInAction needs to be called outside of the try/catch block: import { rerenderInAction } from \"brisa/server\";\n\n// Inside a server action\nfunction handleEvent() {\n  try {\n    // ...\n  } catch (error) {\n    // ...\n  }\n\n  // Trigger a full-page rerender\n  rerenderInAction({ type: \"page\" });\n} Example of Component Rerender: export default function MyComponent({ text = \"foo\" }: { text: string }) {\n  function handleClick() {\n    // Trigger a component rerender with new props\n    rerenderInAction({ type: \"targetComponent\", props: { text: \"bar\" } });\n  }\n\n  return (\n    <div>\n      <button onClick={handleClick}>{text}</button>\n    </div>\n  );\n} See the differences between \"Action Signals\" and rerenderInAction in this documentation.",
    "titles": [
      "rerenderInAction",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/server-apis/rerenderInAction#types",
    "title": "Types:",
    "text": "function rerenderInAction<PropsType>(\n  props: RerenderInActionProps<PropsType> = {},\n): never;\n\ntype RerenderInActionProps<T> =\n  | {\n      type?: \"currentComponent\" | \"targetComponent\";\n      renderMode?: RenderMode;\n      props?: T;\n    }\n  | {\n      type?: \"page\";\n      renderMode?: RenderMode;\n    };",
    "titles": [
      "rerenderInAction",
      "Reference",
      "rerenderInPage({ type, renderMode, props }: RerenderInAction): Never"
    ]
  },
  {
    "id": "/api-reference/server-apis/rerenderInAction#parameters",
    "title": "Parameters:",
    "text": "type: The type of the rerender. It can be currentComponent, targetComponent or page. By default, it is currentComponent, this means that it is going to rerender the component that called the rerenderInAction method. When using targetComponent it is going to rerender the component that fired the original action. When using page it is going to rerender the whole page.\nrenderMode: The type of the rerender. It can be reactivity or transition. By default, it is reactivity. When using transition it is done under View Transition API.\nprops: The props to be passed to the component when rerendering.",
    "titles": [
      "rerenderInAction",
      "Reference",
      "rerenderInPage({ type, renderMode, props }: RerenderInAction): Never"
    ]
  },
  {
    "id": "/api-reference/server-apis/rerenderInAction#returns",
    "title": "Returns:",
    "text": "Never does not require you to use return rerenderInPage() due to using the TypeScript never type. Avoid using the rerenderInPage inside a try/catch block. The navigate is a throwable function and will break the execution of the current function. Updating Action Signals by default is going to use a rerenderInAction with component type and reactivity mode without you having to specify it. If you specify it, it will fulfill only the rerenderInAction you specify.",
    "titles": [
      "rerenderInAction",
      "Reference",
      "rerenderInPage({ type, renderMode, props }: RerenderInAction): Never"
    ]
  },
  {
    "id": "/api-reference/server-apis/rerenderInAction#support",
    "title": "Support",
    "text": "Component\nSupport\n\n\n\n\nServer Component\nâŒ\n\n\nWeb Component\nâŒ\n\n\nSSR Web Component\nâŒ\n\n\nActions\nâœ…\n\n\nMiddleware\nâŒ\n\n\nResponse headers\nâŒ",
    "titles": [
      "rerenderInAction",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/server-apis/serve#serve",
    "title": "serve",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/server-apis/serve#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "serve"
    ]
  },
  {
    "id": "/api-reference/server-apis/serve#serveoptions-serveoptions-port-number-hostname-string-server-server",
    "title": "serve(options: ServeOptions): { port: number; hostname: string; server: Server; }",
    "text": "The serve function is used to start the Bun.js server and listen for incoming requests.",
    "titles": [
      "serve",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/server-apis/serve#example-usage",
    "title": "Example usage:",
    "text": "In the next example, we use the serve function to start the Bun.js server. import { getServeOptions, serve } from \"brisa/server\";\n\nconst serveOptions = await getServeOptions();\n\nconst { server, port, hostname } = serve({\n  ...serveOptions,\n  fetch(req, server) {\n    // Your implementation here ...\n\n    // Brisa handler\n    return serveOptions.fetch(req, server);\n  },\n  port: 3001,\n});\n\nconsole.log(\n  \"Server ready ðŸ¥³\",\n  `listening on http://${hostname}:${port}...`,\n); It only makes sense to use it if you need a custom server for extra things from the serve but if you start the server in the same way as Brisa.",
    "titles": [
      "serve"
    ]
  },
  {
    "id": "/api-reference/server-apis/serve#types",
    "title": "Types",
    "text": "export function serve(options: ServeOptions): {\n  port: number;\n  hostname: string;\n  server: Server; // Bun.js server (Bun.serve)\n};",
    "titles": [
      "serve"
    ]
  },
  {
    "id": "/api-reference/server-apis/SSRWebComponent#ssrwebcomponent",
    "title": "SSRWebComponent",
    "text": "",
    "titles": []
  },
  {
    "id": "/api-reference/server-apis/SSRWebComponent#reference",
    "title": "Reference",
    "text": "",
    "titles": [
      "SSRWebComponent"
    ]
  },
  {
    "id": "/api-reference/server-apis/SSRWebComponent#ssrwebcomponent-1",
    "title": "SSRWebComponent",
    "text": "The SSRWebComponent is a component wrapper that allows you to render a web component on the server side taking care of Declarative Shadow DOM and Custom Elements.",
    "titles": [
      "SSRWebComponent",
      "Reference"
    ]
  },
  {
    "id": "/api-reference/server-apis/SSRWebComponent#example-usage",
    "title": "Example usage:",
    "text": "In the next example, we use the SSRWebComponent to render a web component on the server side. import { SSRWebComponent } from \"brisa/server\";\nimport MyComponent from \"@/web-components/my-component\";\n\nexport function MyComponent() {\n  // It's the same than: <my-component someProp=\"foo\" /> \n  // but without compilation process:\n  return (\n    <SSRWebComponent\n      ssr-selector=\"my-component\"\n      ssr-Component={MyComponent}\n      someProp=\"value\"\n    />\n  );\n} This work is usually done by Brisa for you during compilation, so you can use <web-component /> directly in your code without having to do 2 imports and use this wrapper. However, it is exposed in case someone needs to do it manually for some reason. The ssr-selector prop is required and must match the web component's tag name, also the ssr-Component prop is required and must be the web component itself.",
    "titles": [
      "SSRWebComponent"
    ]
  },
  {
    "id": "/api-reference/server-apis/SSRWebComponent#types",
    "title": "Types",
    "text": "export function SSRWebComponent<T>(\n  props: T & { 'ssr-selector': string, 'ssr-Component': ComponentType<T>, children?: JSX.Element },\n): JSX.Element;",
    "titles": [
      "SSRWebComponent"
    ]
  },
  {
    "id": "/building-your-application/authentication#authentication",
    "title": "Authentication",
    "text": "To incorporate authentication in Brisa, acquaint yourself with three fundamental principles: Authentication (Identity Verification) ensures the user's claimed identity. It mandates users to validate their identity with possessions like a username and password.\nAuthorization determines the application areas accessible to the user..\nSession Tracking monitors the user's status (e.g., logged in) across various requests. This page illustrates the utilization of Brisa features to implement prevalent patterns in authentication, authorization, and session management. This empowers you to select optimal solutions tailored to your application's requirements.",
    "titles": []
  },
  {
    "id": "/building-your-application/authentication/authentication#authentication",
    "title": "Authentication",
    "text": "User verification confirms the user's identity, occurring during login via credentials like a username-password combination or through a service such as Google. It focuses on validating that users are indeed who they claim to be, safeguarding both user data and the application from unauthorized access or fraudulent activities.",
    "titles": []
  },
  {
    "id": "/building-your-application/authentication/authentication#authentication-strategies",
    "title": "Authentication Strategies",
    "text": "Contemporary web applications commonly employ various authentication approaches: OAuth/OpenID Connect (OIDC): Facilitates third-party access without disclosing user credentials, ideal for social media logins and Single Sign-On (SSO) solutions. It introduces an identity layer through OpenID Connect.\nCredentials-based login (Email + Password): A standard choice where users log in using email and password, familiar and straightforward to implement, necessitating robust security measures against threats like phishing.\nPasswordless/Token-based authentication: Use email magic links or SMS one-time codes for secure, password-free access. Popular for its convenience and heightened security, though reliant on user email or phone availability.\nPasskeys/WebAuthn: Utilizes site-specific cryptographic credentials, offering strong protection against phishing. While secure, its newness might pose implementation challenges. Choosing an authentication approach should align with your application's specific needs, user interface considerations, and security goals.",
    "titles": [
      "Authentication"
    ]
  },
  {
    "id": "/building-your-application/authentication/authentication#implementing-authentication",
    "title": "Implementing Authentication",
    "text": "In this section, we'll explore the process of adding basic email-password authentication to a web application. While this method provides a fundamental level of security, it's worth considering more advanced options like OAuth or passwordless logins for enhanced protection against common security threats. The authentication flow we'll discuss is as follows: The user submits their credentials through a login form.\nThe form calls a Server Action.\nUpon successful verification, the process is completed, indicating the user's successful authentication.\nIf verification is unsuccessful, an error message is shown. Consider a server component with login form where users can input their credentials: import { navigate, type RequestContext } from \"brisa\";\nimport { rerenderInAction } from \"brisa/server\";\nimport signIn from \"@/utils/auth/sign-in\";\n\nexport default function LoginPage({}, request: RequestContext) {\n  const errorMsg = request.store.get(\"auth-error\");\n\n  async function authenticate(e) {\n    const email = e.formData.get(\"email\");\n    const password = e.formData.get(\"password\");\n    const success = await signIn(email, password);\n\n    if (success) navigate(\"/admin\");\n\n    request.store.set(\"auth-error\", \"Invalid credentials\");\n    rerenderInAction({ type: \"page\" });\n  }\n\n  return (\n    <form onSubmit={authenticate}>\n      <input type=\"email\" name=\"email\" placeholder=\"Email\" required />\n      <input type=\"password\" name=\"password\" placeholder=\"Password\" required />\n      <button type=\"submit\">Login</button>\n      {errorMsg && <p>{errorMsg}</p>}\n    </form>\n  );\n} The form above has two input fields for capturing the user's email and password. On submission, it calls the authenticate Server Action. You can then call your Authentication Provider's API in the Server Action to handle authentication: const success = await signIn(email, password); In this code, the signIn method checks the credentials against stored user data.\nAfter the authentication provider processes the credentials, there are two possible outcomes: Successful Authentication: This outcome implies that the login was successful. Further actions, such as accessing protected routes and fetching user information, can then be initiated.\nFailed Authentication: In cases where the credentials are incorrect or an error is encountered, the function returns a corresponding error message to indicate the authentication failure. Finally, you can navigate to another page or use the request store to save form errors, and use rerenderInAction to render these errors on the form: if (success) navigate(\"/admin\");\n\nrequest.store.set(\"auth-error\", \"Invalid credentials\");\nrerenderInAction({ type: \"page\" }); Both navigate and rerenderInAction throw an exception returning a Never type, therefore the code after is not executed so there is no need to put an else conditional. It is important to keep this in mind because if it is put in a try-catch they would stop working unless from the catch you throw again these actions.",
    "titles": [
      "Authentication"
    ]
  },
  {
    "id": "/building-your-application/authentication/authorization#authorization",
    "title": "Authorization",
    "text": "Once a user is authenticated, you'll need to ensure the user is allowed to visit certain routes, and perform operations such as mutating data with Server Actions and calling Route Handlers.",
    "titles": []
  },
  {
    "id": "/building-your-application/authentication/authorization#protecting-routes-with-middleware",
    "title": "Protecting Routes with Middleware",
    "text": "Middleware in Brisa helps you control who can access different parts of your website. This is important for keeping areas like the user dashboard protected while having other pages like marketing pages be public. It's recommended to apply Middleware across all routes and specify exclusions for public access. Here's how to implement Middleware for authentication in Brisa: src/middleware.ts: import type { RequestContext } from \"brisa\";\nimport parseCookies from \"@/utils/auth/parse-cookies\";\n\nexport default async function middleware(req: RequestContext) {\n  // Early return for assets (no route) and api endpoints\n  if (!req.route || req.route.name.startsWith(\"/api/\")) return;\n\n  const cookies = parseCookies(req.headers.get(\"cookie\"));\n  const currentUser = cookies.get(\"currentUser\");\n  const pathname = req.route.pathname ?? \"\";\n\n  if (currentUser && !pathname.startsWith(\"/dashboard\")) {\n    return new Response(\"\", {\n      status: 302,\n      headers: {\n        Location: new URL(\"/dashboard\", req.url).toString(),\n      },\n    });\n  }\n\n  if (!currentUser && !pathname.startsWith(\"/login\")) {\n    return new Response(\"\", {\n      status: 302,\n      headers: {\n        Location: new URL(\"/login\", req.url).toString(),\n      },\n    });\n  }\n  // ...\n} This example returns a Response for handling redirects early in the request pipeline, making it efficient and centralizing access control. In Brisa the middleware works in a different way than in many frameworks. If you return nothing or undefined, it continues processing the route as if it had not entered the middleware, similar to the next() function of many frameworks. Another thing you can return, is a Response, then the middleware cuts and finishes processing the route here. If what you want to do is to modify the response headers that route will have, you have to do it using the responseHeaders method. After successful authentication, it's important to manage user navigation based on their roles. For example, an admin user might be redirected to an admin dashboard, while a regular user is sent to a different page. This is important for role-specific experiences and conditional navigation, such as prompting users to complete their profile if needed. When setting up authorization, it's important to ensure that the main security checks happen where your app accesses or changes data. While Middleware can be useful for initial validation, it should not be the sole line of defense in protecting your data. The bulk of security checks should be performed in the Data Access Layer (DAL). This approach advocates for consolidating all data access within a dedicated DAL. This strategy ensures consistent data access, minimizes authorization bugs, and simplifies maintenance. To ensure comprehensive security, consider the following key areas: Server Actions: Implement security checks in server-side processes, especially for sensitive operations.\nRoute Handlers: Manage incoming requests with security measures to ensure access is limited to authorized users.\nData Access Layer (DAL): Directly interacts with the database and is crucial for validating and authorizing data transactions. It's vital to perform critical checks within the DAL to secure data at its most crucial interaction pointâ€”access or modification.",
    "titles": [
      "Authorization"
    ]
  },
  {
    "id": "/building-your-application/authentication/authorization#protecting-server-actions",
    "title": "Protecting Server Actions",
    "text": "It is important to treat Server Actions with the same security considerations as public-facing API endpoints. Verifying user authorization for each action is crucial. Implement checks within Server Actions to determine user permissions, such as restricting certain actions to admin users. In the example below, we check the user's role before allowing the action to proceed: import type { RequestContext } from \"brisa\";\nimport parseCookies from \"@/utils/auth/parse-cookies\";\nimport db from \"./lib/db\";\n\nasync function getSession(req: RequestContext) {\n  const cookies = parseCookies(req.headers.get(\"cookie\"));\n  const sessionId = cookies.get(\"sessionId\")?.value;\n  return sessionId ? await db.findSession(sessionId) : null;\n}\n\nexport default function AdminDashboard({}, request: RequestContext) {\n  async function someAction(e) {\n    const session = await getSession(request);\n    const userRole = session?.user?.role;\n\n    if (userRole !== \"admin\") {\n      throw new Error(\n        \"Unauthorized access: User does not have admin privileges.\",\n      );\n    }\n    // ...\n  }\n\n  return (\n    <div>\n      <button onClick={someAction}>Run an action</button>\n    </div>\n  );\n} The component request param is different when rendered during the SSR than when the action is called. When the action is called, it can be used as the request of the action.",
    "titles": [
      "Authorization"
    ]
  },
  {
    "id": "/building-your-application/authentication/authorization#protecting-route-handlers",
    "title": "Protecting Route Handlers",
    "text": "Route Handlers in Brisa play a vital role in managing incoming requests. Just like Server Actions, they should be secured to ensure that only authorized users can access certain functionalities. This often involves verifying the user's authentication status and their permissions. Here's an example of securing a Route Handler: src/api/route.ts: import type { RequestContext } from \"brisa\";\nimport parseCookies from \"@/utils/auth/parse-cookies\";\nimport db from \"./lib/db\";\n\nasync function getSession(req: RequestContext) {\n  const cookies = parseCookies(req.headers.get(\"cookie\"));\n  const sessionId = cookies.get(\"sessionId\")?.value;\n  return sessionId ? await db.findSession(sessionId) : null;\n}\n\nexport async function GET(request: RequestContext) {\n  // User authentication and role verification\n  const session = await getSession(request);\n\n  // Check if the user is authenticated\n  if (!session) {\n    // User is not authenticated\n    return new Response(null, { status: 401 });\n  }\n\n  // Check if the user has the 'admin' role\n  if (session.user.role !== \"admin\") {\n    // User is authenticated but does not have the right permissions\n    return new Response(null, { status: 403 });\n  }\n\n  // Data fetching for authorized users\n}",
    "titles": [
      "Authorization"
    ]
  },
  {
    "id": "/building-your-application/authentication/authorization#protecting-server-components",
    "title": "Protecting Server Components",
    "text": "Like actions and API routes, you can manage authorization within Server Components. Server Components in Brisa are designed for server-side execution and offer a secure environment for integrating complex logic like authorization. They enable direct access to back-end resources, optimizing performance for data-heavy tasks and enhancing security for sensitive operations. In Server Components, a common practice is to conditionally render UI elements based on the user's role. This approach enhances user experience and security by ensuring users only access content they are authorized to view. import type { RequestContext } from \"brisa\";\nimport parseCookies from \"@/utils/auth/parse-cookies\";\nimport AdminDashboard from \"@/components/admin-dashboard\";\nimport UserDashboard from \"@/components/user-dashboard\";\nimport AccessDenied from \"@/components/access-denied\";\nimport db from \"./lib/db\";\n\ntype Props = {\n  /* .... */\n};\n\nasync function getSession(req: RequestContext) {\n  const cookies = parseCookies(req.headers.get(\"cookie\"));\n  const sessionId = cookies.get(\"sessionId\")?.value;\n  return sessionId ? await db.findSession(sessionId) : null;\n}\n\nexport default async function Dashboard(props: Props, request: RequestContext) {\n  const session = await getSession(request);\n  const userRole = session?.user?.role; // Assuming 'role' is part of the session object\n\n  if (userRole === \"admin\") {\n    return <AdminDashboard />; // Component for admin users\n  } else if (userRole === \"user\") {\n    return <UserDashboard />; // Component for regular users\n  } else {\n    return <AccessDenied />; // Component shown for unauthorized access\n  }\n}",
    "titles": [
      "Authorization"
    ]
  },
  {
    "id": "/building-your-application/authentication/session-tracking#session-tracking",
    "title": "Session Tracking",
    "text": "Session tracking involves monitoring and managing a user's interaction with the application over time, ensuring the preservation of their authenticated state across different parts of the application. This eliminates the need for repeated logins, thereby enhancing both security and user convenience. There are two primary methods used for session tracking: Cookie-based\nDatabase sessions",
    "titles": []
  },
  {
    "id": "/building-your-application/authentication/session-tracking#cookie-based",
    "title": "Cookie-based",
    "text": "Cookie-based session tracking relies on HTTP cookies to store and retrieve session identifiers. When a user logs in, a unique session identifier is generated and stored within a cookie on the user's device. Subsequently, with each request sent to the server, this identifier is transmitted back, allowing the server to associate the request with the corresponding session data. Advantages: Lightweight implementation.\nWidely supported by web browsers.\nRequires minimal server-side storage. Limitations: Vulnerable to security risks such as session hijacking and cross-site scripting (XSS) attacks.\nDependency on client-side storage, which can be manipulated or disabled by users.",
    "titles": [
      "Session Tracking"
    ]
  },
  {
    "id": "/building-your-application/authentication/session-tracking#database-sessions",
    "title": "Database Sessions",
    "text": "Database session tracking involves storing session data directly within a database on the server-side. Upon user authentication, a unique session identifier is generated and associated with a record in the database containing relevant session information. Subsequent requests from the user include this identifier, allowing the server to retrieve the associated session data from the database. Advantages: Enhanced security compared to cookie-based sessions, as session data is stored securely on the server-side.\nGreater flexibility in managing and manipulating session data.\nSuitable for applications requiring robust session management capabilities. Limitations: Increased server-side resource utilization, particularly for high-traffic applications.\nPotential performance overhead due to database operations.\nComplexity in implementation and maintenance compared to cookie-based sessions.",
    "titles": [
      "Session Tracking"
    ]
  },
  {
    "id": "/building-your-application/building#building",
    "title": "Building",
    "text": "Congratulations, it's time to build your application in production.",
    "titles": []
  },
  {
    "id": "/building-your-application/building#production-builds",
    "title": "Production Builds",
    "text": "Running brisa build generates an optimized version of your application for production. HTML, CSS, and JavaScript files are created based on your pages. JavaScript is compiled and browser bundles are minified using the Bun Compiler to help achieve the best performance.",
    "titles": [
      "Building"
    ]
  },
  {
    "id": "/building-your-application/building#bun-server",
    "title": "Bun Server",
    "text": "Brisa can be deployed to any hosting provider that supports Bun. Ensure your package.json has the \"build\" and \"start\" scripts: {\n  \"scripts\": {\n    \"dev\": \"brisa dev\",\n    \"build\": \"brisa build\",\n    \"start\": \"brisa start\"\n  }\n} Then, run bun run build to build your application. Finally, run bun run start to start the Bun server. This server supports all Brisa features.",
    "titles": [
      "Building",
      "Production Builds"
    ]
  },
  {
    "id": "/building-your-application/building#app-strategy-static-server-desktop-android-ios",
    "title": "App Strategy (Static, Server, Desktop, Android, iOS)",
    "text": "Brisa supports multiple output strategies to build your application. You can choose between: Build a Bun Server App\nBuild a Node.js Server App\nBuild a Static Site App\nBuild a Desktop App\nBuild a Android App\nBuild a iOS App",
    "titles": [
      "Building"
    ]
  },
  {
    "id": "/building-your-application/building#web-component-compiler",
    "title": "Web Component Compiler",
    "text": "Brisa is more than a framework; it is a Web Component Compiler. You can create web components using Brisa and build them to create a library. Web Component Compiler",
    "titles": [
      "Building"
    ]
  },
  {
    "id": "/building-your-application/building/android-app#android-app",
    "title": "Android app",
    "text": "",
    "titles": []
  },
  {
    "id": "/building-your-application/building/android-app#brisa-android-applications-tauri-integration",
    "title": "Brisa Android Applications (Tauri integration)",
    "text": "This documentation outlines the process of building a Brisa android application using Tauri. Tauri is seamlessly integrated into Brisa by configuring the brisa.config.ts file as follows: import type { Configuration } from \"brisa\";\n\nexport default {\n  output: \"android\",\n} satisfies Configuration; To initialize the development environment, run the following command: brisa dev Prerequisits: You need to download Android Studio and follow these steps from Tauri documentation. Executing this command launches a android app, integrating your web application. The development environment supports hot-reloading, mirroring the behavior of a browser. Notably, the integration creates a src-tauri folder, representing the fusion of Brisa with Tauri. Customizing the icons, title, and other attributes can be achieved by modifying the src-tauri/tauri.conf.json file. Explore Tauri's configuration fields here.",
    "titles": [
      "Android app"
    ]
  },
  {
    "id": "/building-your-application/building/android-app#building-your-brisa-android-app",
    "title": "Building your Brisa Android App",
    "text": "When the output: \"android\" configuration is set in your brisa.config.ts, execute the following command to build the application: bun run build This command generates the corresponding .apk. The build behavior is akin to static export, as there won't be an active server, and the android app is created with the bundled assets (HTML, CSS, JS). Pure server-related functionalities, such as API endpoints and server interactions, will not function at runtime. All interactions should be encapsulated within web components.",
    "titles": [
      "Android app"
    ]
  },
  {
    "id": "/building-your-application/building/bun-server#bun-server",
    "title": "Bun Server",
    "text": "Brisa by default is a Bun.js web service application. This means that when you run brisa build, Brisa generates a Bun server that serves your application on the port 3000 by default, it can be changed with the flag --port. This server is capable of serving your application with all the features that Brisa offers, such as i18n, routing, server actions and middleware.",
    "titles": []
  },
  {
    "id": "/building-your-application/building/bun-server#configuration-optional",
    "title": "Configuration (Optional)",
    "text": "To enable a web service application, change the output mode inside brisa.config.ts (optional since it is the default value): import type { Configuration } from \"brisa\";\n\nexport default {\n  output: \"bun\", // It is the default value\n} satisfies Configuration; After running brisa build, Brisa will generate a Bun server that serves your application on the port 3000 by default.",
    "titles": [
      "Bun Server"
    ]
  },
  {
    "id": "/building-your-application/building/bun-server#changing-the-port",
    "title": "Changing the port",
    "text": "To change the port, you can use the flag --port: brisa start --port 8080 The default port is process.env.PORT or 3000. After running brisa build, Brisa will generate a Bun server that serves your application on the port 8080. If you want, you can use NODE_ENV=production bun run build/server.js to start your application with Bun.js without Brisa CLI.",
    "titles": [
      "Bun Server"
    ]
  },
  {
    "id": "/building-your-application/building/bun-server#custom-server",
    "title": "Custom server",
    "text": "If you want to use a custom server, you can follow this guide: Custom Server.",
    "titles": [
      "Bun Server"
    ]
  },
  {
    "id": "/building-your-application/building/desktop-app#desktop-app",
    "title": "Desktop app",
    "text": "",
    "titles": []
  },
  {
    "id": "/building-your-application/building/desktop-app#brisa-desktop-applications-tauri-integration",
    "title": "Brisa Desktop Applications (Tauri integration)",
    "text": "This documentation outlines the process of building a Brisa desktop application using Tauri. Tauri is seamlessly integrated into Brisa by configuring the brisa.config.ts file as follows: import type { Configuration } from \"brisa\";\n\nexport default {\n  output: \"desktop\",\n} satisfies Configuration; To initialize the development environment, run the following command: brisa dev Executing this command launches a desktop app, integrating your web application. The development environment supports hot-reloading, mirroring the behavior of a browser. Notably, the integration creates a src-tauri folder, representing the fusion of Brisa with Tauri. Customizing the window size, icons, title, and other attributes can be achieved by modifying the src-tauri/tauri.conf.json file. Explore Tauri's configuration fields here.",
    "titles": [
      "Desktop app"
    ]
  },
  {
    "id": "/building-your-application/building/desktop-app#building-your-brisa-desktop-app",
    "title": "Building your Brisa Desktop App",
    "text": "When the output: \"desktop\" configuration is set in your brisa.config.ts, execute the following command to build the application: bun run build This command generates the corresponding executables tailored to your operating system. The supported platforms include: Windows: -setup.exe, .msi\nmacOS: .app, .dmg\nLinux: .deb, .appimage The build behavior is akin to static export, as there won't be an active server, and the desktop app is created with the bundled assets (HTML, CSS, JS). Pure server-related functionalities, such as API endpoints and server interactions, will not function at runtime. All interactions should be encapsulated within web components.",
    "titles": [
      "Desktop app"
    ]
  },
  {
    "id": "/building-your-application/building/desktop-app#cross-platform-build",
    "title": "Cross-Platform Build",
    "text": "Tauri relies on native libraries for each OS, preventing a direct cross-platform build. A cross-platform build can be achieved through a matrix-based pipeline. # ...\nstrategy:\n  fail-fast: false\n  matrix:\n    platform: [macos-latest, ubuntu-20.04, windows-latest]\nruns-on: ${{ matrix.platform }}\n# ... Here's the full example YAML configuration for GitHub Actions. The GitHub Token is automatically issued by GitHub for each workflow run without further configuration, ensuring no risk of secret leakage. For more details, refer to the Tauri documentation on cross-platform builds.",
    "titles": [
      "Desktop app",
      "Building your Brisa Desktop App"
    ]
  },
  {
    "id": "/building-your-application/building/ios-app#ios-app",
    "title": "iOS app",
    "text": "",
    "titles": []
  },
  {
    "id": "/building-your-application/building/ios-app#brisa-ios-applications-tauri-integration",
    "title": "Brisa iOS Applications (Tauri integration)",
    "text": "This documentation outlines the process of building a Brisa ios application using Tauri. Tauri is seamlessly integrated into Brisa by configuring the brisa.config.ts file as follows: import type { Configuration } from \"brisa\";\n\nexport default {\n  output: \"ios\",\n} satisfies Configuration; To initialize the development environment, run the following command: brisa dev Prerequisits: You need to download iOS targets and follow these steps from Tauri documentation. Executing this command launches a ios app, integrating your web application. The development environment supports hot-reloading, mirroring the behavior of a browser. Notably, the integration creates a src-tauri folder, representing the fusion of Brisa with Tauri. Customizing the icons, title, and other attributes can be achieved by modifying the src-tauri/tauri.conf.json file. Explore Tauri's configuration fields here.",
    "titles": [
      "iOS app"
    ]
  },
  {
    "id": "/building-your-application/building/ios-app#building-your-brisa-ios-app",
    "title": "Building your Brisa iOS App",
    "text": "When the output: \"ios\" configuration is set in your brisa.config.ts, execute the following command to build the application: bun run build This command generates the corresponding .ipa (iOS App Store Package). The build behavior is akin to Static Site App, as there won't be an active server, and the ios app is created with the bundled assets (HTML, CSS, JS). Pure server-related functionalities, such as API endpoints and server interactions, will not function at runtime. All interactions should be encapsulated within web components.",
    "titles": [
      "iOS app"
    ]
  },
  {
    "id": "/building-your-application/building/node-server#nodejs-server",
    "title": "Node.js Server",
    "text": "Brisa enables starting as a Node.js Server to serve your app by changing the output to node. It generates a Node.js server that serves your application on the port 3000 by default, it can be changed with the flag --port. This server is capable of serving your application with all the features that Brisa offers, such as i18n, routing, server actions and middleware. You need a different output type than bun since during the build your application is optimized to be served on a Node.js server.",
    "titles": []
  },
  {
    "id": "/building-your-application/building/node-server#configuration-optional",
    "title": "Configuration (Optional)",
    "text": "To enable a web service application, change the output mode inside brisa.config.ts: import type { Configuration } from \"brisa\";\n\nexport default {\n  output: \"node\",\n} satisfies Configuration; After running brisa build, Brisa will generate a Node.js server that serves your application on the port 3000 by default.",
    "titles": [
      "Node.js Server"
    ]
  },
  {
    "id": "/building-your-application/building/node-server#changing-the-port",
    "title": "Changing the port",
    "text": "To change the port, you can use the flag --port: brisa start --port 8080 The default port is process.env.PORT or 3000. After running brisa build, Brisa will generate a Bun server that serves your application on the port 8080. Although you can still use the Bun tooling to start your application in Node.js, if you want, you can use NODE_ENV=production node build/server.js to start your application with Node.js without Brisa CLI.",
    "titles": [
      "Node.js Server"
    ]
  },
  {
    "id": "/building-your-application/building/node-server#custom-server",
    "title": "Custom server",
    "text": "If you want to use a custom server, you can follow this guide: Custom Server.",
    "titles": [
      "Node.js Server"
    ]
  },
  {
    "id": "/building-your-application/building/static-site-app#static-site-app",
    "title": "Static Site App",
    "text": "Brisa enables starting as a static site. When running brisa build, Brisa generates an HTML file per route in SSG (Static Site Generation) mode. This approach helps in reducing the client-side JavaScript code, leading to smaller bundles and faster page loads. Since Brisa supports this static export, it can be deployed and hosted on Content Delivery Networks (CDNs) on any web server that can serve HTML/CSS/JS static assets.",
    "titles": []
  },
  {
    "id": "/building-your-application/building/static-site-app#configuration",
    "title": "Configuration",
    "text": "To enable a static export, change the output mode inside brisa.config.ts: import type { Configuration } from \"brisa\";\n\nexport default {\n  output: \"static\",\n} satisfies Configuration; After running brisa build, Brisa will produce an out folder which contains the HTML/CSS/JS assets for your application. Note that without a server, redirects such as trailingSlash will not work. You will have to manage this type of redirects on the host where you upload your static files. When generating the static files, all pages are called with the request new Request('localhost:3000'), without any configuration option. The middleware (if you have it) will only act during the build and never in runtime. Pure server stuff like api endpoints and server interactions will not work in runtime. All the interaction part should be in web-components only.",
    "titles": [
      "Static Site App"
    ]
  },
  {
    "id": "/building-your-application/building/static-site-app#hard-redirects",
    "title": "Hard redirects",
    "text": "Redirects are no longer done through a server since there is no server once you make a static export. However, to support i18n and let the apps work when you want to put them in a desktop app, by default we do a soft redirect. The soft redirect we apply does not have a 301/307 status. Instead, the /index.html page is loaded and when the browser opens it, the redirect is made to the user's browser language or to the defaultLocale through the client JavaScript. To solve this, you must apply the redirects in the hosting where you host your web application. Here are some links to documentation that may help you depending on the hosting you use: Vercel redirects.\nAWS redirects.\nNetlify redirects",
    "titles": [
      "Static Site App"
    ]
  },
  {
    "id": "/building-your-application/building/web-component-compiler#brisa-as-web-component-compiler",
    "title": "Brisa as Web Component Compiler",
    "text": "Brisa isn't just another framework; it's a powerful tool for developers who need to create highly efficient and portable Web Component libraries. By using Brisa, developers can build standalone web components that work seamlessly across various environments, whether they're integrated into a larger application or used independently. This document focuses on the role of Brisa as a compiler for Web Components, highlighting the value it brings to your development workflow. Related Topics: Brisa CLI brisa build\nExternal Libraries",
    "titles": []
  },
  {
    "id": "/building-your-application/building/web-component-compiler#why-use-brisa-for-web-components",
    "title": "Why Use Brisa for Web Components?",
    "text": "Web Components are a powerful tool for building reusable UI elements that can be easily integrated into any web application, regardless of the framework or environment. However, creating and managing these components can be challenging, especially when considering server-side rendering (SSR), TypeScript support, and compatibility across different platforms. Brisa simplifies this process by providing a robust set of tools and commands that streamline the development and deployment of Web Components.",
    "titles": [
      "Brisa as Web Component Compiler"
    ]
  },
  {
    "id": "/building-your-application/building/web-component-compiler#key-benefits-of-using-brisa-for-web-components",
    "title": "Key Benefits of Using Brisa for Web Components",
    "text": "Integration: Web Components built with Brisa can be used in any framework or vanilla JavaScript, making them highly portable.\nSSR Support: Brisa-generated Web Components are fully compatible with server-side rendering, thanks to its support for Declarative Shadow DOM.\nOptimized Performance: Brisa optimizes Web Components for performance thanks to signals for reactivity.\nBuild optimization: Brisa compiles Web Components into standalone files doing build-time optimizations to reduce the final bundle size.",
    "titles": [
      "Brisa as Web Component Compiler",
      "Why Use Brisa for Web Components?"
    ]
  },
  {
    "id": "/building-your-application/building/web-component-compiler#building-web-components-with-brisa",
    "title": "Building Web Components with Brisa",
    "text": "To create a Web Component using Brisa, you can utilize the brisa build -w command. This command compiles your Web Component into two distinct files: one for the client-side and one for the server-side. These files are optimized for different environments, ensuring that your Web Component performs well in both contexts. Command overview: brisa build -w path/to/your/web-component.tsx web-component.client.js: The client-side JavaScript file for your Web Component, optimized for browser environments.\nweb-component.server.js: The server-side JavaScript file for your Web Component, used for SSR with Declarative Shadow DOM. Example Output [ wait ]  ðŸš€ building your standalone components...\n[ info ]   Standalone components:\n[ info ]   - build/custom-counter.server.js (646.00 B)\n[ info ]   - build/custom-counter.client.js (425.00 B)\n[ info ]   âœ¨  Done in 59.78ms.",
    "titles": [
      "Brisa as Web Component Compiler"
    ]
  },
  {
    "id": "/building-your-application/building/web-component-compiler#using-the-web-component-outside-brisa",
    "title": "Using the Web Component outside Brisa",
    "text": "",
    "titles": [
      "Brisa as Web Component Compiler",
      "Building Web Components with Brisa"
    ]
  },
  {
    "id": "/building-your-application/building/web-component-compiler#client-side-integration",
    "title": "Client-Side Integration",
    "text": "Once built, you can integrate your Web Component into any HTML page or JavaScript application. Hereâ€™s an example of how to use these components in a vanilla JavaScript environment: <!DOCTYPE html>\n<html lang=\"en\">\n<head>\n  <meta charset=\"UTF-8\">\n  <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n  <title>Brisa Web Component Example</title>\n  <script type=\"importmap\">\n    {\n      \"imports\": {\n        \"brisa/client\": \"https://unpkg.com/brisa@latest/client-simplified/index.js\"\n      }\n    }\n  </script>\n  <script type=\"module\" src=\"path/to/web-component.client.js\"></script>\n</head>\n<body>\n  <custom-counter></custom-counter>\n</body>\n</html> The import map is necessary outside of the Brisa framework to map brisa/client to brisa/client-simplified. This is because the Brisa client is internally used by the Brisa framework, and we did a simplified version to be used outside of the framework.",
    "titles": [
      "Brisa as Web Component Compiler",
      "Building Web Components with Brisa",
      "Using the Web Component outside Brisa"
    ]
  },
  {
    "id": "/building-your-application/building/web-component-compiler#server-side-rendering",
    "title": "Server-Side Rendering",
    "text": "For server-side rendering, Brisa's components integrate smoothly with other JSX frameworks. Hereâ€™s how you can render a Brisa Web Component on the server: import { renderToString } from 'brisa/server';\nimport CustomCounter from './path/to/web-component.server.js';\n\nconst html = await renderToString(<CustomCounter start={10} />); If you encounter compatibility issues with the JSX runtime, Brisa offers a jsx function to help resolve these: import { renderToString } from 'brisa/server';\nimport { jsx } from 'brisa/jsx-runtime';\nimport CustomCounter from './path/to/web-component.server.js';\n\nconst html = await renderToString(jsx(CustomCounter, { start: 10 }));",
    "titles": [
      "Brisa as Web Component Compiler",
      "Building Web Components with Brisa",
      "Using the Web Component outside Brisa"
    ]
  },
  {
    "id": "/building-your-application/building/web-component-compiler#using-the-web-component-in-brisa",
    "title": "Using the Web Component in Brisa",
    "text": "To streamline the integration of multiple Web Components, Brisa uses a special integration file located at web-components/_integrations.(tsx|ts|js|jsx). This file maps Web Component selectors to their respective libraries, ensuring they are correctly loaded when needed. import type { WebComponentIntegrations } from \"brisa\";\n\nexport default {\n  \"custom-counter\": {\n    client: \"./path/to/web-component.client.js\",\n    server: \"./path/to/web-component.server.js\",\n    types: \"./path/to/web-component.types.d.ts\",\n  },\n} satisfies WebComponentIntegrations; After this integration, you can use the Web Component in your Brisa application directly by typing <custom-counter></custom-counter> in your JSX code.",
    "titles": [
      "Brisa as Web Component Compiler",
      "Building Web Components with Brisa"
    ]
  },
  {
    "id": "/building-your-application/building/web-component-compiler#typescript-support",
    "title": "TypeScript Support",
    "text": "When using Brisa Web Components that require TypeScript types, you can create a .d.ts file with the necessary type definitions. This file should be named <library-path>.types.d.ts and exported using an export default statement. export default function CustomCounter({ start }: { start?: number }): JSX.Element; By following these guidelines, you can ensure that your Brisa Web Components are fully typed and compatible with TypeScript.",
    "titles": [
      "Brisa as Web Component Compiler",
      "Building Web Components with Brisa",
      "Using the Web Component in Brisa"
    ]
  },
  {
    "id": "/building-your-application/building/web-component-compiler#example",
    "title": "Example",
    "text": "You can use this example library to create your own web components with Brisa: Simple Counter as Web Component Example If you use the Brisa compiler to create your own web components, add this badge:  <a href=\"https://brisa.build\" target=\"_blank\" rel=\"noopener noreferrer\">\n  <img\n    width=\"150\"\n    height=\"42\"\n    src=\"https://brisa.build/assets/brisa_badge.svg\"\n    alt=\"Made with Brisa\"\n  />\n</a> Into your project's README file, let us know, and we will share your library on the Brisa website.",
    "titles": [
      "Brisa as Web Component Compiler"
    ]
  },
  {
    "id": "/building-your-application/components-details/context#context",
    "title": "Context",
    "text": "Context provides a way to pass data through the component tree without having to pass props down manually at every level. It works for both server and web components. In a typical Brisa application, data is passed top-down (parent to child) via props, but such usage can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.",
    "titles": []
  },
  {
    "id": "/building-your-application/components-details/context#create-context-createcontext",
    "title": "Create Context (createContext)",
    "text": "createContext lets you create a context that components can provide or read. import { createContext } from \"brisa\";\n\nconst defaultValue = \"foo\";\nconst SomeContext = createContext(defaultValue); Parameters: defaultValue: The value that you want the context to have when there is no matching context provider in the tree above the component that reads context. If you donâ€™t have any meaningful default value, specify null. The default value is meant as a â€œlast resortâ€ fallback. It is static and never changes over time.",
    "titles": [
      "Context"
    ]
  },
  {
    "id": "/building-your-application/components-details/context#provider",
    "title": "Provider",
    "text": "The context-provider component is required to propagate a value from this context to a sub-tree of components. The context-provider does not need any import. You can use the custom element context-provider by passing the context and value. It is a web component because this way the value is going to be shared with the web components and also you can use the same provider in web components. Server component: import { createContext } from \"brisa\";\nimport AnotherComponent from \"@/components/another-component\";\n\nconst ctx = createContext(\"foo\");\n\nexport default function ServerComponent() {\n  <context-provider context={ctx} value=\"bar\">\n    <AnotherComponent />\n  </context-provider>;\n} Web component: import { createContext } from \"brisa\";\n\nconst ctx = createContext(\"foo\");\n\nexport default function WebComponent() {\n  <context-provider context={ctx} value=\"bar\">\n    <another-component />\n  </context-provider>;\n} Parameters: SomeContext: The context that youâ€™ve previously created with createContext. The context itself does not hold the information, it only represents the kind of information you can provide or read from components. Returns: useContext returns the context value inside a signal for the calling component. It is determined as the value passed to the closest context-provider above the calling component in the tree. If there is no such provider, then the returned value will be the defaultValue you have passed to createContext for that context. The returned value is up-to-date, reactive under a signal.",
    "titles": [
      "Context"
    ]
  },
  {
    "id": "/building-your-application/components-details/context#serveronly-property",
    "title": "serverOnly property",
    "text": "In many cases we want to share sensitive data on the server components-tree and that this data never reaches the client. To do this, the provider supports the serverOnly property and during SSR it is extripated so that it is never part of the final HTML. import { createContext } from \"brisa\";\nimport AnotherComponent from \"@/components/another-component\";\n\nconst ctx = createContext(\"foo\");\n\nexport default function ServerComponent() {\n  <context-provider serverOnly context={ctx} value=\"bar\">\n    <AnotherComponent />\n  </context-provider>;\n} This means: <context-provider serverOnly context={ctx} value=\"bar\">\n  <div>Hello</div>\n</context-provider> Is going to be transformed to just this HTML: <div>Hello</div>. Without the context-provider on top. The serverOnly property in runtime always works and there is no need to worry. However, if you don't use any client context and you don't want to carry the context-provider code in the client we recommend that you use literal values, like true|false directly, since during the build we don't evaluate if there are dynamic values, then in this case the provider code will be carried in the client even if it is not used later and you will never see any sensitive data.",
    "titles": [
      "Context",
      "Provider"
    ]
  },
  {
    "id": "/building-your-application/components-details/context#consume-context-usecontext",
    "title": "Consume Context (useContext)",
    "text": "useContext is a Brisa Hook that lets you read and subscribe to context from your component. export default function MyComponent(props, { useContext }) {\n  const theme = useContext(ThemeContext);\n  return <div style={{ color: theme.value.color }}>Hello world</div> useContext() call in a component is not affected by providers returned from the same component. The corresponding <context-provider> needs to be above the component doing the useContext() call.\nInstead of an import it is inside the RequestContext or WebContext. In the case of server the context is stored inside the request, since each request is different and it is better that it is not global to avoid concurrency problems. In the case of web is needed within the WebContext to generate a reactive signal that is cleared when the web component is disconnected.",
    "titles": [
      "Context"
    ]
  },
  {
    "id": "/building-your-application/components-details/context#when-to-use-context-instead-of-storebuilding-your-applicationcomponents-detailsweb-componentsstore-store-method",
    "title": "When to use context instead of store",
    "text": "Using Context instead of store comes at a price, since it generates a DOM element (context-provider web component) unless you have set serverOnly attribute. The difference is that store is a state shared with your entire app, while context is shared only between a tree of components. And the same context can have different values for different sub-trees. We recommend that you use store whenever possible. For specific cases that for example you have a list of components and you want to avoid prop-drilling and pass to each item its values through a context, then feel free to use context because this is its purpose. Example: import Ctx from \"@/some-context\";\n\nexport default function ItemListProvider({ items }) {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <context-provider context={Ctx} key={index} value={item}>\n          {/* Avoid prop-drilling to the list-item component */}\n          <list-item />\n        </context-provider>\n      ))}\n    </ul>\n  );\n}",
    "titles": [
      "Context"
    ]
  },
  {
    "id": "/building-your-application/components-details/external-libraries#external-libraries",
    "title": "External Libraries",
    "text": "When working on a Brisa project, you may encounter scenarios where you need to integrate external libraries. This documentation outlines the process of installing and using external libraries in different contexts within your project: standalone libraries, server components, and web components.",
    "titles": []
  },
  {
    "id": "/building-your-application/components-details/external-libraries#common-installation",
    "title": "Common Installation",
    "text": "For all types of libraries, including standalone, server components, and web components, you can use the bun install command to install them. This command fetches and installs the library, making it available for use throughout your project. bun install <library-name>",
    "titles": [
      "External Libraries"
    ]
  },
  {
    "id": "/building-your-application/components-details/external-libraries#standalone-libraries",
    "title": "Standalone Libraries",
    "text": "",
    "titles": [
      "External Libraries"
    ]
  },
  {
    "id": "/building-your-application/components-details/external-libraries#import-and-usage",
    "title": "Import and Usage",
    "text": "Once installed, you can import the library wherever needed in your project and use its functionalities accordingly. import myLibrary from \"<library-name>\";\n\n// Use library functions or classes as needed,\n// whether inside web components, server\n// components, middleware, etc. This addition emphasizes the versatility of standalone libraries, making it clear that developers can utilize them in various parts of their project, depending on the specific needs of each component type.",
    "titles": [
      "External Libraries",
      "Standalone Libraries"
    ]
  },
  {
    "id": "/building-your-application/components-details/external-libraries#server-components-dependencies",
    "title": "Server Components Dependencies",
    "text": "",
    "titles": [
      "External Libraries"
    ]
  },
  {
    "id": "/building-your-application/components-details/external-libraries#import-and-usage-1",
    "title": "Import and Usage",
    "text": "When dealing with server components, import the library and use its functionalities within your server-side code: import ServerComponent from \"<server-component-library>\";\n\nexport default function MyPage() {\n  // Use server components as needed inside the JSX\n  return <ServerComponent />;\n} While both server components and web components can leverage external libraries, the key distinction lies in how they are used. In server components, the integration is more straightforward, as you can directly import and use the libraries within JSX.",
    "titles": [
      "External Libraries",
      "Server Components Dependencies"
    ]
  },
  {
    "id": "/building-your-application/components-details/external-libraries#creating-a-server-component-library",
    "title": "Creating a Server Component Library",
    "text": "To create a server component library, you can use the brisa build -c component-path.tsx command. This command generates a new server component library, which you can then publish and install in your project. brisa build -c <component-path> See the CLI documentation for more information on the brisa build command.",
    "titles": [
      "External Libraries",
      "Server Components Dependencies"
    ]
  },
  {
    "id": "/building-your-application/components-details/external-libraries#web-components-dependencies",
    "title": "Web Components Dependencies",
    "text": "",
    "titles": [
      "External Libraries"
    ]
  },
  {
    "id": "/building-your-application/components-details/external-libraries#import-and-usage-2",
    "title": "Import and Usage",
    "text": "To integrate a web component library, create a file named web-components/_integrations.(tsx|ts|js|jsx). Export an object where each key is the selector of the web component, and the corresponding value is the path (in string format) to the library, similar to what you would use in an import statement. import type { WebComponentIntegrations } from \"brisa\";\n\nexport default {\n  \"custom-element\": \"<library-path>\",\n  // Add more mappings as needed\n} satisfies WebComponentIntegrations; Usage of web components within server components does not require additional imports. Simply include the web component tags directly in your server component code (or inside another web component): // Inside a server component or inside another web-component\n<div>\n  <custom-element></custom-element>\n</div> This approach allows seamless integration of web components within your server components, maintaining a clean and concise code structure. Note for Developers: The web components specified in web-components/_integrations will be dynamically included in the client-side code only when they are used on a particular page.",
    "titles": [
      "External Libraries",
      "Web Components Dependencies"
    ]
  },
  {
    "id": "/building-your-application/components-details/external-libraries#ssr-of-external-web-components",
    "title": "SSR of external Web Components",
    "text": "Using this declaration: import type { WebComponentIntegrations } from \"brisa\";\n\nexport default {\n  \"custom-element\": \"<library-path>\",\n  // Add more mappings as needed\n} satisfies WebComponentIntegrations; It only do SSR in the case of Brisa web components without any transpilation, not in the case of native web components or transpiled Brisa web components. However, there is a solution. Brisa is more than a framework, it is also a tool to create Web Component libraries, so all web components created with this Brisa tool can be used in any framework or VanillaJS, and apart, you can use the file with the suffix .server.js to do SSR of the web components. So all web components made with Brisa can be imported with this other declaration: import type { WebComponentIntegrations } from \"brisa\";\n\nexport default {\n  \"custom-element\": {\n    client: \"<library-path>.client\",\n    server: \"<library-path>.server\",\n    types: \"<library-path>.types\",\n  },\n  // Add more mappings as needed\n} satisfies WebComponentIntegrations; If your favorite Web Component library is not compatible with SSR, tell them to contact us so they can make it compatible, we want the web to be a better and more accessible place for everyone so we are willing to help any library to be compatible with Brisa.",
    "titles": [
      "External Libraries",
      "Web Components Dependencies"
    ]
  },
  {
    "id": "/building-your-application/components-details/external-libraries#typescript-types",
    "title": "TypeScript Types",
    "text": "Using this declaration: import type { WebComponentIntegrations } from \"brisa\";\n\nexport default {\n  \"custom-element\": '<library-path>',\n  // Add more mappings as needed\n} satisfies WebComponentIntegrations; It only use types when <library-path> is a Brisa Web Component without transpilation and has .ts extension. If it is a native web component or a Brisa Web Component with transpilation, you have to create a .d.ts file with the types of the web component. In order to specify the types you need to change the declaration to: import type { WebComponentIntegrations } from \"brisa\";\n\nexport default {\n  \"custom-element\": {\n    client: \"<library-path>.client\",\n    types: \"<library-path>.types.d.ts\",\n  },\n  // Add more mappings as needed\n} satisfies WebComponentIntegrations; And create a file with the name <library-path>.types.d.ts with the types of the web component. Example of types for a web component: export default function CustomCounter({ start }: { start?: number }): JSX.Element; Note for library creators: Use an export default in the .d.ts file to export the types of the web component.",
    "titles": [
      "External Libraries",
      "Web Components Dependencies"
    ]
  },
  {
    "id": "/building-your-application/components-details/external-libraries#creating-a-web-component-library",
    "title": "Creating a Web Component Library",
    "text": "To create a server component library, you can use the brisa build -w web-component-path.tsx command. This command generates a new server component library, which you can then publish and install in your project. brisa build -w <web-component-path> This is going to create two files: web-component-path.client.js and web-component-path.server.js. The first one is for the client-side, and the second one is for the server-side (SSR with Declarative Shadow DOM). You can use the web component in any framework or VanillaJS. See the CLI documentation for more information on the brisa build command.",
    "titles": [
      "External Libraries",
      "Web Components Dependencies"
    ]
  },
  {
    "id": "/building-your-application/components-details/external-libraries#third-party-brisa-web-components-vs-native-web-components",
    "title": "Third party Brisa web components vs native web components",
    "text": "For both, you can use the web-components/_integrations.(tsx|ts|js|jsx): export default {\n  \"brisa-element\": \"<library-path>\",\n  \"native-web-component\": {\n    client: \"<library-path>.client\",\n    server: \"<library-path>.server\",\n    types: \"<library-path>.types\",\n  },\n}; As a note for those who create open-source libraries, the difference is that if there is a default export, it interprets it as a Brisa web component, so you can create any Brisa library with it: export default function BrisaElement() {\n  return <div>My Brisa Element</div>;\n} So then, you don't need any transpilation and with only this declaration: \"brisa-element\": \"<library-path>\", it works for SSR and types. However, you can use transpilation to allow the same code to be used in any framework or VanillaJS. Doing this, it's converted to native web components, so then you need to load the .client.js file in the client-side and the .server.js file in the server-side: \"brisa-element\": {\n  client: \"<library-path>.client\",\n  server: \"<library-path>.server\",\n  types: \"<library-path>.types\",\n}, In the case you want to create a native web component, you don't need to export it, and you can use the customElements.define method: customElements.define(\n  \"native-web-component\",\n  class extends HTMLElement {\n    connectedCallback() {\n      this.innerHTML = \"My Native Web Component\";\n    }\n  },\n); About the definition of the name: Be careful that the selector name inside customElements.define should be the same as the one in the web-components/_integrations file.",
    "titles": [
      "External Libraries",
      "Web Components Dependencies"
    ]
  },
  {
    "id": "/building-your-application/components-details/forms#forms",
    "title": "Forms",
    "text": "Forms play a crucial role in user interaction. When dealing with forms, developers often come across the concepts of controlled and uncontrolled components.",
    "titles": []
  },
  {
    "id": "/building-your-application/components-details/forms#uncontrolled-forms-recommended",
    "title": "Uncontrolled Forms (recommended ðŸ‘Œ)",
    "text": "",
    "titles": [
      "Forms"
    ]
  },
  {
    "id": "/building-your-application/components-details/forms#server-component-recommended",
    "title": "Server Component (recommended ðŸ‘Œ)",
    "text": "An uncontrolled form is a form where the values are not bound to the component's state, allowing for a more straightforward and less verbose approach. Uncontrolled forms are useful in scenarios where the form is relatively simple, and the overhead of managing form state through the component is unnecessary. Uncontrolled forms can be created in both web components and server components. The browser events in Brisa can be handled in the server. In fact, we recommend that if you use uncontrolled forms, use a server component. This way: You make the app lighter, less JS code to the client.\nYou can handle directly the form on the server. export default function UncontrolledFormServer() {\n  return (\n    <form\n      onSubmit={(e) => {\n        // This code runs on the server in server components!\n        console.log(\"Username:\", e.formData.get(\"username\"));\n      }}\n    >\n      <label>\n        Username:\n        <input type=\"text\" name=\"username\" />\n      </label>\n      <br />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n} The onSubmit on the server works like the submit event (triggered by the client) merged with the formdata event (is fired after the FormData invocation). The difference with the client onSubmit are: The e.preventDefault() is always done automatically in the server actions.\nThe FormData is built to send and process it from the server, modifying the event from onSubmitEvent to FormDataEvent.\nSince the event is FormDataEvent, you can access the form data directly through e.formData.\ne.target.reset() and e.currentTarget.reset() instead of being executed right away, they are executed when the server action ends. In fact, it is now even easier to deal with form server interactions from the server than with the client.",
    "titles": [
      "Forms",
      "Uncontrolled Forms (recommended ðŸ‘Œ)"
    ]
  },
  {
    "id": "/building-your-application/components-details/forms#reset-form",
    "title": "Reset form",
    "text": "The browser events inside server actions are serialized. However, e.target.reset() and e.currentTarget.reset() still works in the server. The only difference is that it is not executed at the right time, but is marked to reset it when the server action is finished and returns the response to the client. export default function UncontrolledFormServer() {\n  return (\n    <form\n      onSubmit={(e) => {\n        // This code runs on the server\n        e.target.reset(); // Reset the form\n        console.log(\"Username:\", e.formData.get(\"username\"));\n      }}\n    >\n      <label>\n        Username:\n        <input type=\"text\" name=\"username\" />\n      </label>\n      <br />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n} Adds 0 bytes of JS client. Only the Brisa RPC client is needed which is ~2kB.",
    "titles": [
      "Forms",
      "Uncontrolled Forms (recommended ðŸ‘Œ)"
    ]
  },
  {
    "id": "/building-your-application/components-details/forms#web-component-not-recomended",
    "title": "Web component (not recomended ðŸ‘Ž)",
    "text": "The client code of a uncontrolled form would be as follows: export default function UncontrolledFormClient() {\n  return (\n    <form\n      onSubmit={(e) => {\n        e.preventDefault();\n        const formData = new FormData(e.currentTarget);\n        console.log(\"Username:\", formData.get(\"username\"));\n      }}\n    >\n      <label>\n        Username:\n        <input type=\"text\" name=\"username\" />\n      </label>\n      <br />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n} If you are making an uncontrolled form in a web component it is a sign that you are writing code on the client that could be written on the server. Use only uncontrolled form in web components only if you don't need to make a request to the server after the submit. Otherwise use a server component. Using uncontrolled form in web components adds client JS code, not only the event JS, but also the JS of the web component itself.",
    "titles": [
      "Forms",
      "Uncontrolled Forms (recommended ðŸ‘Œ)"
    ]
  },
  {
    "id": "/building-your-application/components-details/forms#controlled-forms-not-recomended",
    "title": "Controlled Forms (not recomended ðŸ‘Ž)",
    "text": "A controlled form in Brisa is a form whose state is controlled by the Brisa web component. In other words, the form elements such as input fields, checkbox, radio buttons, etc have their values bound to the component's state. This allows to manage and control the form's behavior and be able to give instant feedback to the user about errors. Despite the benefits of controlled forms, it's important to note that Brisa doesn't necessarily recommend their use in all scenarios. The decision to opt for controlled or uncontrolled forms should be driven by specific requirements and architectural considerations. In certain cases, controlled forms may introduce unnecessary complexity, especially when dealing with large forms or integrating with external libraries. Developers should carefully assess the trade-offs and choose the approach that aligns best with their application's needs. import { type WebContext } from \"brisa\";\n\nexport default function ControlledFormExample({}, { state }: WebContext) {\n  const username = state<string>(\"\");\n\n  return (\n    <form\n      onSubmit={(e) => {\n        e.preventDefault();\n        console.log(\"Username:\", username.value);\n      }}\n    >\n      <label>\n        Username:\n        <input\n          type=\"text\"\n          name=\"username\"\n          value={username.value}\n          onInput={(e) => {\n            username.value = e.currentTarget.value;\n          }}\n        />\n      </label>\n      <br />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n} If you want to use controlled forms, we recommend that you use it in the web components and not in the server components. If you want to manage the onSubmit for the server, you can manage it through a prop and the parent server component capture and handle the event. import { type WebContext } from \"brisa\";\n\n// Web component:\nexport default function ControlledFormExample(\n  { onFormSubmit }, // Event captured and handled by server component\n  { state }: WebContext,\n) {\n  const username = state<string>(\"\");\n\n  return (\n    <form onSubmit={() => onFormSubmit({ username })}>\n      <label>\n        Username:\n        <input\n          type=\"text\"\n          name=\"username\"\n          value={username.value}\n          onInput={(e) => {\n            username.value = e.currentTarget.value;\n          }}\n        />\n      </label>\n      <br />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n} And: // Server component:\nexport default function Page() {\n  const onFormSubmit = ({ username }) => {\n    // This event is handled in the server, we can save it to the DB.\n  };\n\n  return <controlled-form-example onFormSubmit={onFormSubmit} />;\n} Controlled forms introduce additional complexity and more client-side JavaScript code. Developers should carefully weigh these factors when choosing between controlled and uncontrolled forms. The Brisa team recommends using controlled forms primarily when providing instant feedback to users for each modification during form interactions. Otherwise, it is advisable to opt for uncontrolled forms with a server component.",
    "titles": [
      "Forms"
    ]
  },
  {
    "id": "/building-your-application/components-details/forms#mixing-controlled-and-uncontrolled-fields",
    "title": "Mixing controlled and uncontrolled fields",
    "text": "In scenarios where a form is implemented within a server component due to the static nature of most fields, an exception arises when a dynamic field is included through a Web Component. Since Web Components use a separate Shadow DOM, the value of this dynamic field, encapsulated within the Shadow DOM, is not automatically included when capturing FormData from the parent form.",
    "titles": [
      "Forms"
    ]
  },
  {
    "id": "/building-your-application/components-details/forms#associated-web-component",
    "title": "Associated Web Component",
    "text": "To address this issue, the ElementInternals API must be employed within Brisa to ensure that the Web Component is properly integrated as a form field. This approach allows the Web Component to be recognized as part of the form, ensuring that its value is included when FormData is collected from the form. Example: import type { WebContext } from \"brisa\";\n\nexport default function SomeDynamicInput({ }, { self }: WebContext) {\n  const internals = self.attachInternals();\n\n  function onInput(e) {\n    internals.setFormValue(e.target.value);\n  }\n\n  return <input type=\"text\" onInput={onInput} />\n} Doing internals.setFormValue(e.target.value) we are setting the value of the Web Component to the form field. This way, the value of the dynamic field will be included when capturing FormData from the parent form. self.attachInternals() can be used without an effect, it is supported on SSR without any problem. Think when you are using self.attachInternals() you are extending a default Element Internals class. And therefore default values are set. For example, if you try to use an input type=\"email\" or required, no actions will happen from the browser unless you define Validity. import type { WebContext } from \"brisa\";\n\nexport default function WebComponent({ }, { self }: WebContext) {\n  const internals = self.attachInternals();\n\n  return (\n    <input\n      type=\"text\"\n      required\n      onInput={(e) => {\n        const input = e.currentTarget;\n        // Updates the validation of the internal element (input)\n        internals.setValidity(input.validity, input.validationMessage);\n        console.log('isValid', internals.checkValidity());\n      }}\n    />\n  );\n} The ValidityState object is used to represent the validity states of an element. It contains properties that indicate whether the element meets its validation criteria, and the reason why it doesn't.",
    "titles": [
      "Forms",
      "Mixing controlled and uncontrolled fields"
    ]
  },
  {
    "id": "/building-your-application/components-details/forms#usage-in-a-form",
    "title": "Usage in a Form",
    "text": "After attaching the Web Component to the form, the value of the dynamic field will be included when capturing FormData from the parent form. Example of usage on a Server Component: export default function Page() {\n  return (\n    <form onSubmit={(e) => {\n      console.log(\"Username:\", e,formData.get(\"username\"));\n      // The dynamic field is included in the FormData\n      console.log(\"Dynamic:\", e.formData.get(\"dynamic\"));\n    }}>\n      <label>\n        Username:\n        <input type=\"text\" name=\"username\" />\n      </label>\n      <some-dynamic-input name=\"dynamic\" required />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n} The name attribute is required in the Web Component to be recognized as a form field. For more information on the ElementInternals API, take a look these docs:\n\nElementInternals MDN Web Docs\nForm-associated custom elements\nElementInternals and Form-Associated Custom Elements",
    "titles": [
      "Forms",
      "Mixing controlled and uncontrolled fields"
    ]
  },
  {
    "id": "/building-your-application/components-details/reactivity#reactivity",
    "title": "Reactivity",
    "text": "The reactivity in Brisa is based on signals. The signals are the state, the props, the store, the derived and the context. The signals are reactive, that is, when they change, they automatically update the parts of the DOM where they are used. In order to don't break the reactivity, you have to use the .value clause when you want to consume the signal. For example: export default function Counter({}, { state }: WebContext) {\n  const count = state<number>(0);\n\n  return (\n    <>\n      <button onClick={() => count.value++}>+</button>\n      <span> Counter: {count.value} </span>\n      <button onClick={() => count.value--}>-</button>\n    </>\n  );\n} It is important to know that using .value outside the return of the component will break the reactivity. For example: export default function Counter({}, { state }: WebContext) {\n  const count = state<number>(0);\n\n  // âŒ variable is no longer reactive\n  const currentCount = count.value;\n\n  return (\n    <>\n      <button onClick={() => count.value++}>+</button>\n      <span> Counter: {currentCount} </span>\n      <button onClick={() => count.value--}>-</button>\n    </>\n  );\n} However, thanks to compilation-time optimizations, we allow the use of early returns in Brisa without breaking reactivity: export default function Counter({}, { state }: WebContext) {\n  const count = state<number>(0);\n\n  // âœ… variable is still reactive\n  if (count.value === 0) {\n    return <div>Counter is zero</div>;\n  }\n\n  return (\n    <>\n      <button onClick={() => count.value++}>+</button>\n      <span> Counter: {count.value} </span>\n      <button onClick={() => count.value--}>-</button>\n    </>\n  );\n}",
    "titles": []
  },
  {
    "id": "/building-your-application/components-details/reactivity#are-signals-readonly",
    "title": "Are signals readonly?",
    "text": "Only the props signals are readonly, otherwise are writable. However, you can't mutate them directly. You have to use the .value clause to mutate them setting a new value. For example: count.value = 10; // âœ…\ncount = 10; // âŒ\n\nuser.value = { username: \"Aral\" }; // âœ…\nuser = { username: \"Aral\" }; // âŒ\nuser.value.username = \"Aral\"; // âŒ To update the value of a signal, you need to provoke a setter to the value property. For example: user.value = { username: 'Aral' };. If you try to update the inner properties of the signal directly, the reactivity will not work, because doing user.value.username = 'Aral' will trigger a getter (user.value.username) and not a setter.",
    "titles": [
      "Reactivity"
    ]
  },
  {
    "id": "/building-your-application/components-details/reactivity#are-props-reactive",
    "title": "Are props reactive?",
    "text": "Props are an special kind of signals optimized in compilation-time. You don't need to use the .value clause to consume them. They are readonly. So, this means that you can't mutate them. This also allows to define a default value for a prop in a easy way: export default function Counter({ initialValue = 0 }, { state }: WebContext) {\n  const count = state<number>(initialValue);\n\n  return (\n    <>\n      <button onClick={() => count.value++}>+</button>\n      <span> Counter: {count.value} </span>\n      <button onClick={() => count.value--}>-</button>\n    </>\n  );\n} In Brisa we are doing optimizations in build-time to allow you to declare props inside the component arguments without losing reactivity. For example username and displayName are reactive in the following component: export default function UserCard({\n  user: { username, displayName } = { username: \"Unknown\" },\n}) {\n  return (\n    <>\n      <span> Username: {username} </span>\n      <span> Display Name: {displayName} </span>\n    </>\n  );\n} An alternative way to do it outside the component arguments is consuming directly the signal inside the JSX: export default function UserCard({ user }) {\n  return (\n    <>\n      <span> Username: {user.username ?? \"Unknown\"} </span>\n      <span> Display Name: {user.displayName} </span>\n    </>\n  );\n} However, this way is not recommended because it breaks the reactivity: export default function Counter({ user }) {\n  const { username, displayName } = user;\n\n  return (\n    <>\n      <span> Username: {username} </span>\n      <span> Display Name: {displayName} </span>\n    </>\n  );\n} For derived props, you can use the derived method: export default function Counter({ user }, { derived }: WebContext) {\n  const username = derived(() => user.username.toUpperCase());\n  const displayName = derived(() => user.displayName.toUpperCase());\n\n  return (\n    <>\n      <span> Username: {username.value} </span>\n      <span> Display Name: {displayName.value} </span>\n    </>\n  );\n} In the last example, username and displayName are derived signals from the user prop signal to display the username and display name in uppercase.",
    "titles": [
      "Reactivity"
    ]
  },
  {
    "id": "/building-your-application/components-details/reactivity#can-i-create-a-signal-from-a-signal",
    "title": "Can I create a signal from a signal?",
    "text": "Yes, you can create a signal from a signal using the derived method. This method is useful to create a signal that depends on other signals. export default function DoubleCounter({}, { state, derived }: WebContext) {\n  const count = state(0);\n  const double = derived(() => count.value * 2);\n\n  return (\n    <div>\n      <button onClick={() => count.value--}>Decrement</button>\n      {double.value}\n      <button onClick={() => count.value++}>Increment</button>\n    </div>\n  );\n} In this example, double is a signal that depends on count. When count changes, double will automatically update. If you want to create a custom signal inside the WebContext to re-use it in multiple components, you can use expand the WebContext.",
    "titles": [
      "Reactivity"
    ]
  },
  {
    "id": "/building-your-application/components-details/reactivity#can-i-use-signals-in-the-server",
    "title": "Can I use signals in the server?",
    "text": "No directly. The signals are reactive and they are used in the client-side. However, action-signals concept exists and you can use the server store method and transfer some store fields to the client-side and reactively update them on a server action. import type { RequestContext } from \"brisa\";\nimport { rerenderInAction } from \"brisa/server\";\n\nexport default function ServerComponent({}, { store }: RequestContext) {\n  // Setting store\n  if (!store.has(\"user\")) {\n    store.set(\"user\", { username: \"foo\", displayName: \"Foo\" });\n  }\n\n  // Extends the life of the store property beyond request-time\n  // (Necessary to use it in a server action)\n  store.transferToClient([\"user\"]);\n\n  function updateName() {\n    // Update the store inside a server action\n    store.set(\"user\", { username: \"bar\", displayName: \"Bar\" });\n    rerenderInAction({ type: \"page\" });\n  }\n\n  // Consuming store\n  return (\n    <>\n      Hello {store.get(\"user\").displayName}\n      <button onClick={updateName}>Update name</button>\n    </>\n  );\n} The natural lifecycle of the server store is: Middleware\nRendering (layout, page, components) But thanks to store.transferToClient method, you extend the lifecycle of some store fields to: Middleware\nRendering (layout, page, components)\nClient side (as signal)\nServer Actions\nClient side (as signal)\netc ... And modifing the value on server actions, is reflected in a reactive way on the client side signals.",
    "titles": [
      "Reactivity"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#server-components",
    "title": "Server Components",
    "text": "Remember that everything in Brisa (pages, layout, middleware, api...) runs on the server. The only exception are the web-components folder, so, the rest of Brisa components will be Server Components. Brisa applies Server Side Rendering (SSR) of the server components and does not carry JavaScript code to the client. They should be imported and consumed in JSX, This is how you can distinguish between a server-component and a web-component; Server components will always be consumed in PascalCase in the JSX, while web components are in kebab-case without import, like other HTML Elements. import ServerComponent from \"@/components/server-component\";\n\n// ...\n<body>\n  <ServerComponent />\n  <web-component />\n</body>; It is a way for your server components to have only server code. You can be 100% sure that all the code here runs ONLY on the server. All events that are captured in the Server Components are Server Actions, therefore they are executed on the server without needing JS code on the client: <ServerComponent onClick={e => console.log('This console.log is on the server', e)} />\n<web-component onAction={(e) => console.log('Capturing a web-component event on the server', e)} />\n<button onClick={() => console.log('click handled in the server')}>Click</button>",
    "titles": []
  },
  {
    "id": "/building-your-application/components-details/server-components#differences-with-web-components",
    "title": "Differences with Web Components",
    "text": "Although the server components are interactive in Brisa, the interactivity of the server components is more focused on interactivity where the server is involved. It would not make sense to do the interactivity on the server for Spreadsheet cell components, since all this interactivity could be on the client avoiding constant calls to the server. Web components are fully reactive thanks to signals, and you can access the Web API.",
    "titles": [
      "Server Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#creating-a-server-component",
    "title": "Creating a Server Component",
    "text": "Server Components can be created anywhere except inside the web-components folder. Example: .\nâ””â”€â”€ components\n    â””â”€â”€ server-component.tsx And it has to be a JSX component: export default function ServerComponent({ children }) {\n  return (\n    <main>\n      <h1>Hello World</h1>\n      {children}\n    </main>\n  );\n}",
    "titles": [
      "Server Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#props",
    "title": "Props",
    "text": "Brisa components use props to communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions (server actions).",
    "titles": [
      "Server Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#step-1-pass-props-to-the-child-component",
    "title": "Step 1: Pass props to the child component",
    "text": "First, pass some props to user-images. For example, letâ€™s pass three props: urls (array of strings), width and height (number): src/components/user-info.tsx: import UserImages from \"@/components/user-images\";\n\nexport default function UserInfo() {\n  return (\n    <UserImages\n      urls={[\"some-image.jpg\", \"another-url.jpg\"]}\n      width={300}\n      height={300}\n    />\n  );\n} Now you can read these props inside the UserImages component.",
    "titles": [
      "Server Components",
      "Props"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#step-2-read-props-inside-the-child-component",
    "title": "Step 2: Read props inside the child component",
    "text": "You can read these props by listing their names urls, width, height separated by the commas inside ({ and }) directly after function UserImages. This lets you use them inside the UserImages code, like you would with a variable. src/components/user-images.tsx: export default function UserImages({ urls, width, height }) {\n  // urls, width and height are available here\n  return urls.map((imageUrl) => (\n    <img\n      class=\"avatar\"\n      key={imageUrl}\n      src={imageUrl}\n      alt=\"probably we can add this 'alt' to prop also\"\n      width={width}\n      height={height}\n    />\n  ));\n}",
    "titles": [
      "Server Components",
      "Props"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#specifying-a-default-value-for-a-prop",
    "title": "Specifying a default value for a prop",
    "text": "If you want to give a prop a default value to fall back on when no value is specified, you can do it with the destructuring by putting = and the default value right after the parameter: export default function UserImages({ urls = [], width = 300, height = 300 }) {\n  // ...\n}",
    "titles": [
      "Server Components",
      "Props"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#key-property",
    "title": "key property",
    "text": "Each child in a list should have a unique \"key\" prop. Keys tell Brisa which array item each component corresponds to, so that it can match them up later after the execution of a server action that does a rerenderInAction. This becomes important if your array items can move (e.g. due to sorting), get inserted, or get deleted. A well-chosen key helps Brisa infer what exactly has happened, and make the correct updates to the DOM tree after the server action execution. export default function List({ people }) {\n  return (\n    <ul>\n      {people.map((person) => (\n        <li key={person.id}>\n          <img src={getImageUrl(person)} alt={person.name} />\n          <p>\n            <b>{person.name}</b>\n            {\" \" + person.profession + \" \"}\n            known for {person.accomplishment}\n          </p>\n        </li>\n      ))}\n    </ul>\n  );\n} The key property is also an attribute to identify the instance of a web component. When the value of key changes, it forces a unmount + mount of the web component again, resetting the state of the component. Therefore, from the rendering of a server action executed in a Server Component you can control whether to reset the internal state of a web component (by changing the key) or keep it (without changing the key). export default function ExampleOfKey({}, { i18n }) {\n  // If locale change, some-component is going to be unmounted + mounted\n  return <some-component key={i18n.locale} />;\n}",
    "titles": [
      "Server Components",
      "Props"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#children",
    "title": "Children",
    "text": "In Brisa, the children prop is a special prop that allows components to pass elements, components, or even plain text as children to another component. It provides a flexible way to compose and structure Brisa applications. The children prop is implicitly available and can be accessed as an argument. Let's take a look at a simple example: src/components/my-component.tsx: const MyComponent = ({ children }) => {\n  return (\n    <div>\n      <p>This is my component</p>\n      {children}\n    </div>\n  );\n};\n\nexport default MyComponent; src/components/parent-component.tsx: const ParentComponent = () => {\n  return (\n    <MyComponent>\n      <p>These are the child components!</p>\n    </MyComponent>\n  );\n};\n\nexport default ParentComponent; In this example, the MyComponent component can render its content and any child components passed to it using the children prop.",
    "titles": [
      "Server Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#events-server-actions",
    "title": "Events (server actions)",
    "text": "In Brisa Components there is a convention that events must start with on prefix. Ex: onNext, onPrev. After following this convention you can use events in Server Components like browser events, with some differences: The browser event is serialized\nThe code is executed on the server\nIt's not adding JS client code src/components/password.tsx: export default function Password({ onValidatePassword }) {\n  return (\n    <div>\n      <input\n        type=\"password\"\n        onInput={(e) => {\n          console.log(\"this code is executed on the server!\");\n          // Send data to another server action:\n          onValidatePassword(e.target.value);\n        }}\n        // Debounce the browser event 300ms\n        debounceInput={300}\n      />\n    </div>\n  );\n} Consuming the onValidatePassword server action of this Server Component from another component: src/components/example.tsx: import { navigate } from \"brisa\";\n\nexport default function Example() {\n  function validatePassword(password) {\n    if (password === \"foo\") navigate(\"/bar\");\n  }\n\n  return <Password onValidatePassword={validatePassword} />;\n} For more information about Server Actions, read the documentation about Server Actions.",
    "titles": [
      "Server Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#store-store-method",
    "title": "Store (store method)",
    "text": "The store is a shared state among all server-components (possible to transfer some store values on web-components also). The store is a Map that lives at request time (inside the request).",
    "titles": [
      "Server Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#example",
    "title": "Example:",
    "text": "src/components/shared-store.tsx: import type { RequestContext } from \"brisa\";\nimport { rerenderInAction } from \"brisa/server\";\n\nexport default function SharedStore({}, { store }: RequestContext) {\n  // Setting store\n  if (!store.has(\"user\")) {\n    store.set(\"user\", { username: \"foo\", displayName: \"Foo\" });\n  }\n\n  // Extends the life of the store property beyond request-time\n  // (Necessary to use it in a server action)\n  store.transferToClient([\"user\"]);\n\n  function updateName() {\n    // Update the store inside a server action\n    store.set(\"user\", { username: \"bar\", displayName: \"Bar\" });\n    rerenderInAction({ type: \"page\" });\n  }\n\n  // Consuming store\n  return (\n    <>\n      Hello {store.get(\"user\").displayName}\n      <button onClick={updateName}>Update name</button>\n    </>\n  );\n} For more information about store, read the documentation about RequestContext.",
    "titles": [
      "Server Components",
      "Store (store method)"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#context",
    "title": "Context",
    "text": "To share context between Server Components without prop drilling you can use context. To use context take a look to: createContext\ncontext-provider\nuseContext Example parent: import { createContext } from \"brisa\";\n\nconst ctx = createContext({});\n\nexport default function ThemeProvider({ color, children }) {\n  <context-provider context={ctx} value={{ color }}>\n    {children}\n  </context-provider>;\n} Example sub-tree child component: export default function SomeChildComponent(props, { useContext }) {\n  const theme = useContext(ThemeContext);\n  return <div style={{ color: theme.value.color }}>Hello world</div> Learn more about it here.",
    "titles": [
      "Server Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#template-literal-css",
    "title": "Template literal css",
    "text": "You can write CSS in your components using the template literal named css. The return value of css is nothing. As it runs, the css is injected during the render. import { RequestContext } from \"brisa\";\n\nexport default function Component(\n  { color }: { color: string },\n  { css }: RequestContext,\n) {\n  css`\n    .color {\n      color: ${color};\n    }\n  `;\n\n  return <p class=\"color\">{color}</p>;\n} You can run this literal template several times and the styles will accumulate.",
    "titles": [
      "Server Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#inject-html-dangerhtml",
    "title": "Inject HTML (dangerHTML)",
    "text": "Make situations that we want to inject HTML that we have in string to the DOM. For these occasions, you can use the dangerHTML function. Since without this function it is escaped by security. import { dangerHTML } from \"brisa\";\n\nexport default function SomeComponent() {\n  return (\n    <>\n      {/* Escaped by default (doesn't work for security): */}\n      {'<script>alert(\"This is escaped and is not going to work\")</script>'}\n\n      {/* Force to inject an string as HTML: */}\n      {dangerHTML(\n        '<script>alert(\"This is injected and is going to work\")</script>',\n      )}\n    </>\n  );\n}",
    "titles": [
      "Server Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#suspense-component-phase",
    "title": "Suspense component phase",
    "text": "You can generate a suspense phase if your component is async and you want to show something while the promise is pending. It also works during HTML streaming. export default async function MyServerComponent({}, { state }) {\n  const foo = await fetch(/* ... */).then((r) => r.text());\n\n  return <div>{foo}</div>;\n}\n\nMyServerComponent.suspense = (props, reqContext) => <div>loading...</div>; See more details here to learn more.",
    "titles": [
      "Server Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/server-components#handle-component-error",
    "title": "Handle component error",
    "text": "You can generate a error phase if your server component throws an error and you want to show something without crash the rest of the page. import { RequestContext } from \"brisa\";\n\nexport default function SomeComponent() {\n  /* some code */\n}\n\nSomeComponent.error = ({ error, ...props }, requestContext: RequestContext) => {\n  return <p>Oops! {error.message}</p>;\n}; See more details here to learn more.",
    "titles": [
      "Server Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#web-components",
    "title": "Web Components",
    "text": "Remember that everything in Brisa (pages, layout, middleware, api...) runs on the server. The page components are server-components. However, we support a connection to the Web Components through the src/web-components folder. Web Components is a suite of different technologies allowing you to create reusable custom elements â€” with their functionality encapsulated away from the rest of your code â€” and utilize them in the rest of the app. Similar to the pages, the file names will be the names of the web components. There is no routing here, but you have to take this into account when adding the names. .\nâ””â”€â”€ web-components\n    â”œâ”€â”€ form\n    â”‚   â””â”€â”€ error-feedback.tsx\n    â”œâ”€â”€ sidebar-menu.tsx\n    â””â”€â”€ user-card.tsx They can now be used directly as HTML tags in the rest of the web-components and server-components: <body>\n  <sidebar-menu />\n  <user-card />\n  <form>\n    <input type=\"text\" />\n    <form-error-feedback />\n    <button>Submit</button>\n  </form>\n</body> We support type-safe, so TypeScript can make your life easier when using them.",
    "titles": []
  },
  {
    "id": "/building-your-application/components-details/web-components#differences-with-server-components",
    "title": "Differences with Server Components",
    "text": "In order to make it easy during development, we support the fact that creating web-components is very similar to the rest of the components (Brisa mode). However there are some differences. Although the server components are interactive in Brisa, the interactivity of the server components is more focused on interactivity where the server is involved. It would not make sense to do the interactivity on the server for Spreadsheet cell components, since all this interactivity could be on the client avoiding constant calls to the server. Web components are fully reactive thanks to signals. There are no rerenders, no virtual DOM and no reconciliation. And of course, unlike Server Components, you can access the Web API: import { WebContext } from \"brisa\";\n\nexport default function SomeWebComponent({}, { onMount, cleanup }: WebContext) {\n  onMount(() => document.addEventListener(\"scroll\", onScroll));\n  cleanup(() => document.removeEventListener(\"scroll\", onScroll));\n\n  function onScroll(event) {\n    // some implementation of the scroll event\n  }\n\n  return <div>{/* some content */}</div>;\n} In the last example, the scroll event is recorded when the web component is mounted and deleted when the web component is unmounted.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#creating-a-web-component",
    "title": "Creating a Web Component",
    "text": "",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#step-1-create-the-file",
    "title": "Step 1: Create the file",
    "text": "Unlike Server Components that can be created anywhere, web components must be inside the src/web-component folder. For example, let's create this file: src/web-component/some-example.tsx. Here the file name is very important, since it will be the name of the web-component selector. That is, we will be able to use it in other web/server components with the tag: <some-example>Some example</some-example> The names of the Web Components, as a convention, must be created in kebab-case and at least 2 batches to avoid conflicts with other elements of the web. However, you can group them in folders. Route\nCorrect\nselector\n\n\n\n\nsrc/web-component/some-example.tsx\nâœ…\n<some-example/>\n\n\nsrc/web-component/some/example.tsx\nâœ…\n<some-example/>\n\n\nsrc/web-component/some-complex-example.tsx\nâœ…\n<some-complex-example />\n\n\nsrc/web-component/SomeExample.tsx\nâŒ\n-\n\n\nsrc/web-component/someExample.tsx\nâŒ\n-\n\n\nsrc/web-component/some_complex-example.tsx\nâŒ\n-\n\n\nsrc/web-component/some_complex/example.tsx\nâŒ\n-\n\n\nsrc/web-component/some.tsx\nâŒ\n-",
    "titles": [
      "Web Components",
      "Creating a Web Component"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#step-2-write-and-export-default-the-component",
    "title": "Step 2: Write and export default the component",
    "text": "Once we have created the file, we can write our Web Component. The only thing we need to do to make it available is to make a export default of the component. export default function HelloWorld() {\n  return <div>Hello World</div>;\n}",
    "titles": [
      "Web Components",
      "Creating a Web Component"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#props",
    "title": "Props",
    "text": "Brisa components use props to communicate with each other. Every parent component can pass some information to its child components by giving them props. Props might remind you of HTML attributes, but you can pass any JavaScript value through them, including objects, arrays, and functions. The properties are signals but can be used directly without using the .value, because they are readonly. Good to know: Since props are signals, consume them directly or use derived method. Doing so breaks the reactivity:\nexport default function UserImages({ urls }, { derived }) {\n  // âŒ variable is no longer reactive\n  const firstImage = urls[0];\n  // âœ… Instead, use derived:\n  const reactiveFirstImage = derived(() => urls[0]);\n}\n\nIn Brisa we are doing optimizations in build-time to avoid losing the reactivity of the props declared on the parameters. So the last example can be solved without the derived method with these props declaration:\nexport default function UserImages({ urls: [firstImage] }) {\n  // firstImage is reactive\n}\n\nHowever, it is important to know that if you declare a variable with the prop, it will not be reactive. Avoid spreading props without specify the prop field:\nexport default function UserImages(props) {\n  // âŒ Brisa can't know what is the prop field to observe\n  return <img {...props} />;\n}\n\nThis is not related with reacitivity, but for web components Brisa needs to specify the observedAttributes.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#step-1-pass-props-to-the-child-component",
    "title": "Step 1: Pass props to the child component",
    "text": "First, pass some props to user-images. For example, letâ€™s pass three props: urls (array of strings), width and height (number): src/web-components/user-info.tsx: export default function UserInfo() {\n  return (\n    <user-images\n      urls={[\"some-image.jpg\", \"another-url.jpg\"]}\n      width={300}\n      height={300}\n    />\n  );\n} Now you can read these props inside the user-images component.",
    "titles": [
      "Web Components",
      "Props"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#step-2-read-props-inside-the-child-component",
    "title": "Step 2: Read props inside the child component",
    "text": "You can read these props by listing their names urls, width, height separated by the commas inside ({ and }) directly after function UserImages. This lets you use them inside the UserImages code, like you would with a variable. src/web-components/user-images.tsx: export default function UserImages({ urls, width, height }) {\n  // urls, width and height are available here\n  return urls.map((imageUrl) => (\n    <img\n      class=\"avatar\"\n      key={imageUrl}\n      src={imageUrl}\n      alt=\"probably we can add this 'alt' to prop also\"\n      width={width}\n      height={height}\n    />\n  ));\n}",
    "titles": [
      "Web Components",
      "Props"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#specifying-a-default-value-for-a-prop",
    "title": "Specifying a default value for a prop",
    "text": "If you want to give a prop a default value to fall back on when no value is specified, you can do it with the destructuring by putting = and the default value right after the parameter: export default function UserImages({ urls = [], width = 300, height = 300 }) {\n  // ...\n} Adding defaults in this way does not break reactivity.",
    "titles": [
      "Web Components",
      "Props"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#key-property",
    "title": "key property",
    "text": "Each child in a list should have a unique \"key\" prop. Keys tell Brisa which array item each component corresponds to, so that it can match them up later. This becomes important if your array items can move (e.g. due to sorting), get inserted, or get deleted. A well-chosen key helps Brisa infer what exactly has happened, and make the correct updates to the DOM tree. export default function List({ people }) {\n  return (\n    <ul>\n      {people.map((person) => (\n        <li key={person.id}>\n          <img src={getImageUrl(person)} alt={person.name} />\n          <p>\n            <b>{person.name}</b>\n            {\" \" + person.profession + \" \"}\n            known for {person.accomplishment}\n          </p>\n        </li>\n      ))}\n    </ul>\n  );\n} The key property is also an attribute to identify the instance of a component. When the value of key changes, it forces a unmount + mount of the component again, resetting the state of the component. For example, if we use the locale as key, changing the locale will reset the state of the component. export default function ExampleOfKey({}, { i18n }) {\n  // If locale change, some-component is going to be unmounted + mounted\n  return <some-component key={i18n.locale} />;\n}",
    "titles": [
      "Web Components",
      "Props"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#children",
    "title": "Children",
    "text": "In Brisa, the children prop is a special prop that allows components to pass elements, components, or even plain text as children to another component. It provides a flexible way to compose and structure Brisa applications. The children prop is implicitly available and can be accessed as an argument. Let's take a look at a simple example: src/web-components/my-component.tsx: const MyComponent = ({ children }) => {\n  return (\n    <div>\n      <p>This is my component</p>\n      {children}\n    </div>\n  );\n};\n\nexport default MyComponent; src/web-components/parent-component.tsx: const ParentComponent = () => {\n  return (\n    <my-component>\n      <p>These are the child components!</p>\n    </my-component>\n  );\n};\n\nexport default ParentComponent; In this example, the my-component component can render its content and any child components passed to it using the children prop.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#slots",
    "title": "Slots",
    "text": "However, Web-components, by their nature, have the possibility to use the slot tag also to define children. You can use it in case you need more than one child. The prop children is an equivalent to an unnamed slot. This is also valid: src/web-components/my-component-using-slots.tsx: const MyComponentUsingSlots = () => {\n  return (\n    <div>\n      <p>This is my component with slots</p>\n      <div>\n        <slot name=\"header\"></slot>\n      </div>\n      <div>\n        <slot name=\"content\"></slot>\n      </div>\n    </div>\n  );\n};\n\nexport default MyComponentUsingSlots; src/web-components/parent-component-using-slots.tsx: const ParentComponentUsingSlots = () => {\n  return (\n    <my-component-using-slots>\n      <div slot=\"header\">Header Content</div>\n      <p slot=\"content\">These are the child components!</p>\n    </my-component-using-slots>\n  );\n};\n\nexport default ParentComponentUsingSlots; Good to know: Slots only work in Web Components. In Server Components only works children prop.",
    "titles": [
      "Web Components",
      "Children"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#props-as-jsx",
    "title": "Props as JSX",
    "text": "You can pass JSX elements as props to a component: export default function Home() {\n  return <web-component someProp={<h1>Server Title</h1>} /> // âœ…\n} Using Server components as props is also valid: export default function Home() {\n  return <web-component someProp={<ServerComp />} /> // âœ…\n} It's just an alternative to slots and children, but slots and children have better performance because it is not necessary to deserialize and render inside the Web Component.",
    "titles": [
      "Web Components",
      "Children"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#events",
    "title": "Events",
    "text": "",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#events-via-attributes",
    "title": "Events via attributes",
    "text": "In Brisa Components there is a convention that events must start with on prefix. Ex: onNext, onPrev. This convention is because it is necessary to distinguish between attributes that are events and those that are not. And as the functions cannot serialize, we came to make this convention. After following this convention you can use events in Web Components as if you were in other frameworks such as React. src/web-components/color-selector.tsx: import { WebContext } from \"brisa\";\n\nexport default function ColorSelector({ color, onChangeColor }) {\n  return (\n    <div>\n      <input\n        type=\"color\"\n        value={color}\n        onInput={(e) => onChangeColor(e.target.value)}\n      />\n      <span style={{ color }}>{color}</span>\n    </div>\n  );\n} Consuming the event onChangeColor of this Web Component from another component: src/web-components/color-circle.tsx: import { WebContext } from \"brisa\";\n\nexport default function ColorSVG({}: any, { state }: WebContext) {\n  const color = state<string>(\"#ff0000\");\n\n  return (\n    <>\n      <b>Select a color: </b>\n      <color-selector\n        color={color.value}\n        onChangeColor={(newColor: string) => (color.value = newColor)}\n      />\n\n      <svg width=\"12cm\" height=\"12cm\" xmlns=\"http://www.w3.org/2000/svg\">\n        <circle\n          cx=\"6cm\"\n          cy=\"2cm\"\n          r=\"100\"\n          fill={color.value}\n          transform=\"translate(0,50)\"\n        />\n      </svg>\n    </>\n  );\n} Good to know: Brisa internally uses CustomEvent to communicate between Web Components. It is also used for communication between Web Components and Server Components via Server Actions.\nAll event listeners are automatically added and cleaned up by Brisa.",
    "titles": [
      "Web Components",
      "Events"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#dom-events",
    "title": "DOM events",
    "text": "As web components are DOM elements, they also automatically have their own events. You can capture an onClick of any Web Component without the need to implement it inside: <color-selector\n  color={color.value}\n  onClick={(e) => console.log(\"onClick event already work? ðŸ¤¯\", e)}\n  onChangeColor={(newColor: string) => (color.value = newColor)}\n/> Good to know: It is important to know this when naming events that do not conflict with existing DOM events, to avoid \"event fires twice\" issues. Also important if you want to overwrite a DOM event, use the e.stopPropagation() to avoid the conflict.",
    "titles": [
      "Web Components",
      "Events"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#events-on-ref",
    "title": "Events on ref",
    "text": "You can register an event after accessing an element with the ref attribute and state: export default ({}, { onMount, cleanup, state }: WebContext) => {\n  const ref = state(null);\n\n  function onClick(e) {\n    console.log(\"Event via ref\", e);\n  }\n\n  onMount(() => ref.value.addEventListener(\"click\", onClick));\n  cleanup(() => ref.value.removeEventListener(\"click\", onClick));\n\n  return <div ref={ref}>Example</div>;\n}; Although we recommend registering events via attributes, we also provide the opportunity to do it this way. The grace of the ref is also that you can have control of the element after mounting, thing that also allows to register events in it. Good to know: For the ref attribute you do not have to put the .value, you have to put the whole state.",
    "titles": [
      "Web Components",
      "Events"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#state-state-method",
    "title": "State (state method)",
    "text": "The state is under a signal. This means that to consume it you have to use the .value clause.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#example",
    "title": "Example:",
    "text": "src/web-components/counter-component.tsx: import { WebContext } from \"brisa\";\n\nexport default function Counter({}, { state }: WebContext) {\n  // Declaring state\n  const count = state<number>(0);\n\n  // Setting state:\n  const inc = () => count.value++;\n  const dec = () => count.value--;\n\n  return (\n    <>\n      <button onClick={inc}>+</button>\n      {/* Consuming state: */}\n      <span> Counter: {count.value} </span>\n      <button onClick={dec}>-</button>\n    </>\n  );\n} Whenever a state mutate (change the .value) reactively updates these parts of the DOM where the signal has been set.",
    "titles": [
      "Web Components",
      "State (state method)"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#store-store-method",
    "title": "Store (store method)",
    "text": "The difference between state and store is that store is a shared state among all web-components. The store is a reactive Map, where the methods get, has, set and delete are reactive. There is no need to use the .value here. But once the .get is done you may lose reactivity and need to add it to a derived.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#example-1",
    "title": "Example:",
    "text": "src/web-components/shared-store.tsx: import { WebContext } from \"brisa\";\n\nexport default function SharedStore({}, { store }: WebContext) {\n  // Setting store\n  store.set(\"user\", { username: \"foo\", displayName: \"Foo\" });\n\n  function updateName() {\n    // Reactive update all web-components that consume the same store entry\n    store.set(\"user\", { username: \"bar\", displayName: \"Bar\" });\n  }\n\n  // Consuming store\n  return (\n    <>\n      Hello {store.get(\"user\").displayName}\n      <button onClick={updateName}>Update name</button>\n    </>\n  );\n}",
    "titles": [
      "Web Components",
      "Store (store method)"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#example-with-derived-and-store",
    "title": "Example with derived and store:",
    "text": "import { WebContext } from \"brisa\";\n\nexport default function SharedStore({}, { store, derived }: WebContext) {\n  const name = derived(() => store.get(\"user\").displayName);\n\n  // Setting store\n  store.set(\"user\", { username: \"foo\", displayName: \"Foo\" });\n\n  function updateName() {\n    // Reactive update all web-components that consume the same store entry\n    store.set(\"user\", { username: \"bar\", displayName: \"Bar\" });\n  }\n\n  // Consuming derived store\n  return (\n    <>\n      Hello {name.value}\n      <button onClick={updateName}>Update name</button>\n    </>\n  );\n}",
    "titles": [
      "Web Components",
      "Store (store method)"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#effects-effect-method",
    "title": "Effects (effect method)",
    "text": "Effects are used to record side effects such as fetching data, setting up a subscription, and manually changing the DOM in Brisa components. Each effect is executed immediately upon registration and also every time a registered signal within the effect changes. There is no need to write the dependencies of these signals separately, since the effect is smart enough to detect the signals. export default ({ foo }: { foo: string }, { effect }: WebContext) => {\n  effect(() => {\n    if (foo === \"bar\") {\n      console.log(\"foo now is bar\");\n    }\n  });\n\n  return <div>Example</div>;\n}; This would be an example using a prop called foo. The props are signals readonly, that's why it doesn't have the .value. You can also use async-await in effects: export default async ({ foo }: { foo: string }, { state, effect }: WebContext) => {\n  const bar = state<any>();\n\n  await effect(async () => {\n    if (foo === \"bar\") {\n      bar.value = await fetch(/* some endpoint */).then((r) => r.json());\n    }\n  });\n\n  return bar.value && <div>{bar.value.someField}</div>;\n}; When using async in an effect, to avoid conflicts and register the effect properly before rendering or other effects, you have to put the await. After putting the await you ensure that the effect has been registered correctly with the corresponding internal dependencies.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#effect-on-mount-onmount-method",
    "title": "Effect on mount (onMount method)",
    "text": "The onMount method is triggered only once, when the component has been mounted. In the case that the component is unmounted and mounted again, it will be called again, although it would be another instance of the component starting with its initial state. It is useful for using things during the life of the component, for example document events, or for accessing rendered DOM elements and having control over them. To delete the events recorded during this lifetime, there is the following cleanup method. import { WebContext } from \"brisa\";\n\nexport default function SomeWebComponent({}, { onMount, cleanup }: WebContext) {\n  onMount(() => {\n    // Register things after mounting the component\n    document.addEventListener(\"scroll\", onScroll);\n  });\n  cleanup(() => {\n    // Unregister when the component unmounts\n    document.removeEventListener(\"scroll\", onScroll);\n  });\n\n  function onScroll(event) {\n    // some implementation of the scroll event\n  }\n\n  return <div>{/* some content */}</div>;\n}",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#clean-effects-cleanup-method",
    "title": "Clean effects (cleanup method)",
    "text": "As discussed above in the onMount method, there is also a cleanup method to clean up the unmount. However, it has more power than just this. The cleanup will be triggered when: When the component is unmounted, it calls up all cleanup used in the component.\nIf you have a cleanup inside an effect, every time the effect is executed before it is executed, the cleanups inside it will be called. import { WebContext } from \"brisa\";\n\nexport default function SomeWebComponent({ foo }, { effect, cleanup }: WebContext) {\n  effect(() => {\n    const interval = setInterval(() => console.log(foo), 100)\n\n    // - Triggered before each effect execution (when \"foo\" change)\n    // - Triggered also on unmount\n    cleanup(() => clearInterval(interval)) //\n  });\n\n  cleanup(() => /* Triggered on unmount */);\n\n  return <div>{/* some content */}</div>;\n}",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#derived-state-and-props-derived-method",
    "title": "Derived state and props (derived method)",
    "text": "The derived method is useful to create signals derived from other signals such as state or props. Example derived from props: src/web-components/my-component.tsx: export default function MyComponent({ user }, { derived }) {\n  const username = derived(() => user.name ?? \"No user\");\n\n  return <div>{username.value}</div>;\n} Example derived from state: src/web-components/double-counter.tsx: export default function DoubleCounter({}, { state, derived }) {\n  const count = state(0);\n  const double = derived(() => count.value * 2);\n\n  return (\n    <div>\n      <button onClick={() => count.value--}>Decrement</button>\n      {double.value}\n      <button onClick={() => count.value++}>Increment</button>\n    </div>\n  );\n}",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#context",
    "title": "Context",
    "text": "To share context between Web Components without prop drilling you can use context. To use context take a look to: createContext\ncontext-provider\nuseContext Example parent: import { createContext } from \"brisa\";\n\nconst ctx = createContext({});\n\nexport default function ThemeProvider({ color, children }) {\n  <context-provider context={ctx} value={{ color }}>\n    {children}\n  </context-provider>;\n} Example sub-tree child component: export default function SomeChildComponent(props, { useContext }) {\n  const theme = useContext(ThemeContext);\n  return <div style={{ color: theme.value.color }}>Hello world</div> Learn more about it here.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#template-literal-css",
    "title": "Template literal css",
    "text": "You can write CSS in your web components using the template literal named css. The return value of css is nothing. As it runs, the css is generated in the web component and the signals are registered to update it. import { WebContext } from \"brisa\";\n\nexport default function WebComponent(\n  { color }: { color: string },\n  { css }: WebContext,\n) {\n  css`\n    p {\n      color: ${color};\n    }\n  `;\n\n  return <p>{color}</p>;\n} You can use the name of the elements directly as the web components by their nature encapsulate the styles and there is no conflict with other web components. In this example, whenever the color property changes, it shall be updated reactively. Useful for creating animations, keyframes, pseudo classes or other things that can't be done with the style property and have more control of the css and signals. If you use VSCode we recommend this extension to improve DX. You can run this literal template several times and the styles will accumulate. This function must be executed before the first render, don't put it inside an effect, event or onMount.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#custom-hooks",
    "title": "Custom hooks",
    "text": "To use effect, cleanup, state, store, derived, useContext and onMount functions outside the component it is necessary to create a custom hook. This hook should be used before the JSX, not inside. Unlike other frameworks, in Brisa it is necessary to propagate the WebContext, since each web component has a different one and self-manages its own life. Example defining a custom hook: import { WebContext } from \"brisa\";\n\nexport default function useRandomColorInterval({\n  state,\n  effect,\n  cleanup,\n}: WebContext) {\n  const getRandomColor = () =>\n    \"#\" + Math.floor(Math.random() * 16777215).toString(16);\n\n  const color = state(getRandomColor());\n\n  effect(() => {\n    let interval = setInterval(() => {\n      color.value = getRandomColor();\n    }, 1000);\n\n    cleanup(() => {\n      clearInterval(interval);\n    });\n  });\n\n  return color;\n} How to consume it: import { WebContext } from \"brisa\";\nimport useRandomColorInterval from \"@/web-hooks/use-random-color-interval\";\n\nexport default function ThemeProvider(\n  { color }: Theme,\n  webContext: WebContext,\n) {\n  const randomColor = useRandomColorInterval(webContext);\n\n  return <div style={{ color: randomColor.value }}>{randomColor.value}</div>;\n} How NOT to consume it: import { WebContext } from \"brisa\";\nimport useRandomColorInterval from \"@/web-hooks/use-random-color-interval\";\n\nexport default function ThemeProvider(\n  { color }: Theme,\n  webContext: WebContext,\n) {\n  // âŒ BAD\n  return <div>{useRandomColorInterval(webContext).value}</div>;\n} Avoid having all hooks (server and client) in the same file. There are no \"use client\", \"use server\" directives here, so it is important to check with the type-safe whether it is WebContext or RequestContext that the custom hook expects.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#portals-createportal",
    "title": "Portals (createPortal)",
    "text": "createPortal lets you render some children into a different part of the DOM. createPortal(children, domNode). To create a portal, call createPortal, passing some JSX, and the DOM node where it should be rendered: import { createPortal } from \"brisa\";\n\nexport default function Component() {\n  return (\n    <div>\n      <p>This child is placed in the parent div.</p>\n      {createPortal(\n        <p>This child is placed in the document body.</p>,\n        document.body,\n      )}\n    </div>\n  );\n} A portal only changes the physical placement of the DOM node. In every other way, the JSX you render into a portal acts as a child node of the Brisa component that renders it. For example, the child can access the context provided by the parent tree, and events bubble up from children to parents according to the Brisa tree.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#inject-html-dangerhtml",
    "title": "Inject HTML (dangerHTML)",
    "text": "Make situations that we want to inject HTML that we have in string to the DOM. For these occasions, you can use the dangerHTML function. Since without this function it is escaped by security. import { dangerHTML } from \"brisa\";\n\nexport default function SomeComponent() {\n  return (\n    <>\n      {/* Escaped by default (doesn't work for security): */}\n      {'<script>alert(\"This is escaped and is not going to work\")</script>'}\n\n      {/* Force to inject an string as HTML: */}\n      {dangerHTML(\n        '<script>alert(\"This is injected and is going to work\")</script>',\n      )}\n    </>\n  );\n}",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#suspense-component-phase",
    "title": "Suspense component phase",
    "text": "You can generate a suspense phase if your web-component is async and you want to show something while the promise is pending. It also works during HTML streaming. export default async function MyWebComponent({}, { state }) {\n  const foo = await fetch(/* ... */).then((r) => r.text());\n\n  return <div>{foo}</div>;\n}\n\nMyWebComponent.suspense = (props, webContext) => <div>loading...</div>; See more details here to learn more.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#handle-component-error",
    "title": "Handle component error",
    "text": "You can generate a error phase if your web-component throws an error and you want to show something without crash the rest of the page. import { WebContext } from \"brisa\";\n\nexport default function SomeWebComponent() {\n  /* some code */\n}\n\nSomeWebComponent.error = ({ error, ...props }, webContext: WebContext) => {\n  return <p>Oops! {error.message}</p>;\n}; See more details here to learn more.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#using-web-components-in-web-components",
    "title": "Using Web Components in Web Components",
    "text": "Within the web components you can use other web components by writing them as if they were other DOM elements. We are not going to use any import, we can consume it directly as another HTML tag. Example consuming a Web Component inside a Web Component: //src/web-components/using-web-component.tsx\nimport { WebContext } from \"brisa\";\n\ntype Props = { name: string };\n\nexport function ServerComponent(\n  { name, children }: Props,\n  webContext: WebContext,\n) {\n  return (\n    <div>\n      {/* This is the Web Component, no import need it, is like more HTML tags */}\n      <some-web-component name={name}>{children}</some-web-component>\n    </div>\n  );\n}\n\n\n\n//src/web-components/using-web-component.js\nimport { WebContext } from \"brisa\";\n\nexport function ServerComponent({ name, children }, webContext) {\n  return (\n    <div>\n      {/* This is the Web Component, no import need it, is like more HTML tags */}\n      <some-web-component name={name}>{children}</some-web-component>\n    </div>\n  );\n}",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#using-web-components-in-server-components",
    "title": "Using Web Components in Server Components",
    "text": "We are not going to use any import, we can consume it directly as another HTML tag. Example consuming a Web Component inside a Server Component: //src/components/using-web-component.tsx\nimport { RequestContext } from \"brisa\";\nimport AnotherServerComponent from \"./another\";\n\ntype Props = { name: string };\n\nexport function ServerComponent(\n  { name }: Props,\n  requestContext: RequestContext,\n) {\n  return (\n    <div>\n      {/* This is the Web Component, no import need it, is like more HTML tags */}\n      <some-web-component name={name}>\n        <AnotherServerComponent name={name} />\n      </some-web-component>\n    </div>\n  );\n}\n\n\n\n//src/components/using-web-component.js\nimport AnotherServerComponent from \"./another\";\n\nexport function ServerComponent({ name }, requestContext) {\n  return (\n    <div>\n      {/* This is the Web Component, no import need it, is like more HTML tags */}\n      <some-web-component name={name}>\n        <AnotherServerComponent name={name} />\n      </some-web-component>\n    </div>\n  );\n} There are cases where the compiler may not detect the web component well, either because it is injected with dangerHTML or for any other reason. In these cases, you can export a variable with web-components on your page to help the compiler:\nexport const webComponents = [<some-example />]",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#using-server-components-in-web-components",
    "title": "Using Server Components in Web Components",
    "text": "It is not possible to use Server Components inside Web Components directly (with an import). However, it is possible to add Server Components within Web Components. But it can only be done through the prop children or using slots. Web component: src/web-components/my-counter.tsx: const LIMIT = 100;\n\nexport default function MyCounter({ children, onLimit }, { state, effect }) {\n  const count = state(0);\n\n  effect(() => {\n    if (count.value === LIMIT) {\n      console.log(\"Log from client\");\n      onLimit();\n    }\n  });\n\n  return (\n    <div>\n      <button onClick={() => count.value--}>-</button>\n      <button onClick={() => count.value++}>+</button>\n      {count.value}\n      {/* This children can be a Server Component: */}\n      <div>{children}</div>\n    </div>\n  );\n} Server Component: import AnotherServerComponent from \"./another\";\n\nexport default function MyServerComponent() {\n  return (\n    <my-counter onLimit={() => console.log(\"Log from server\")}>\n      <AnotherServerComponent />\n    </my-counter>\n  );\n}",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#server-side-rendering",
    "title": "Server Side Rendering",
    "text": "By default Brisa applies Server Side Rendering (SSR) of the web components, this means that they are executed both on the server and then on the client during hydration. To do this we use the Declarative Shadow DOM below. Within the Web Component the only ones that do not run on the server are: effect - Effects such as side-effects that can be used to interact with the Web API are not executed during the SSR.\nonMount - The components are mounted on the client once the browser receives the HTML (even if it does not have JavaScript), so it does not make sense to run this function on the server. When the component is hydrated on the client then this function is executed, only once, on the client.\ncleanup - Similar to onMount, if they are not mounted on the server, they are not unmounted on the server either. All cleanup functions are only executed on the client.\nEvents - Since the events are executed after a user (client) action, they are not executed during the SSR.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#how-to-disable-ssr-to-a-web-component",
    "title": "How to disable SSR to a web component",
    "text": "There are cases where we can avoid the SSR of some web component. It makes sense for these web components that are not available in the initial rendered page, for example they appear after some web interaction, such as a modal. To do this, all web components have available the skipSSR attribute. It's true by default (this attribute does not need to be used when it is true), but you can use it to turn to false. This can be used in any web-component, either consumed from another web-component or from a server component. <some-web-component skipSSR />",
    "titles": [
      "Web Components",
      "Server Side Rendering"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#reusing-elements-without-shadow-domhttpsdevelopermozillaorgen-usdocswebapiwebcomponentsusingshadowdom",
    "title": "Reusing Elements without Shadow DOM",
    "text": "In Brisa, incorporating components using the syntax <Component /> within a web component is not feasible. This invocation method is exclusive to server components. Brisa follows this approach to maintain a clear separation of concerns, where client components solely contain client code, and server components house server code, along with the markup of the web-components and other elements like a div. <Component /> - Smart/dummy server component.\n<web-component /> - Smart web component element. Dummy versions can be created, but it's advisable to leverage server components to avoid client-side JavaScript or use markup generators inside.\n{markupGenerator()} - Generates dummy markup within web-server components. Efforts have been invested in facilitating communication between these two realms, ensuring a seamless integration without confusion from intermingling code. Concepts: Smart: Possesses an internal state.\nDummy: Can utilize external state, but lacks a state created and housed internally. This distinctive approach distinguishes Brisa from other frameworks in reusing web component code without necessitating the creation of shadow DOM. In frameworks like React, to reuse markup (HTML elements), dummy components must be createdâ€”components without state. However, in Brisa, it is recommended to employ markup generators (functions) and invoke them during rendering. import { type Signal } from \"brisa\";\n\nexport function generatePercentage(percentage: Signal<number>) {\n  return (\n    <span>\n      Percentage:{\" \"}\n      {percentage.value > 0 ? `+${percentage.value}` : percentage.value}%\n    </span>\n  );\n} Subsequently, these markup generators can be directly invoked within JSX: import { type WebContext } from \"brisa\";\nimport generatePercentage from \"./_partials/generate-percentage\";\n\nexport default function Counter({}, { state }: WebContext) {\n  const count = state(0);\n\n  return (\n    <div>\n      <button onClick={() => count.value++}>+</button>\n      {generatePercentage(count)}\n      <button onClick={() => count.value--}>-</button>\n    </div>\n  );\n} Markup generators execute only when the web component is mounted, and the content returned by the generator becomes reactive. However, an exception exists when the argument holds the value of a signal rather than the full signal. Do this: // âœ… Good: The content of the markup generator\n// will be reactive as it consumes the signal. It\n// won't execute generatePercentage again.\n<div>{generatePercentage(count)}</div> Avoid this: // âŒ Bad: It will be reactive, but the\n// generatePercentage markup generator will be\n// executed again because the content only\n// has the signal value and not the full signal.\n<div>{generatePercentage(count.value)}</div> Unlike web components, markup generators lack their own state. Choosing between a web component and a markup generator depends on the need: Use a web component if encapsulating logic in a state is required.\nUse a markup generator if generating HTML for reuse in web components without internal state is sufficient. Performance concerns are alleviated in Brisa, as there are no rerenders, and markup generators execute only once. You have the flexibility to establish directories or files with the _ prefix, steering clear of the need to create web components within the src/web-components directory. This proves beneficial when incorporating reusable markup generators within web components. The sole exceptions to this practice are _native, a dedicated directory specifically designed for crafting native web components, free from both Brisa and JSX influences, and _integrations.tsx, an additional file exempt from this convention. Avoid sending the WebContext or parts of them to the markup generators, you can send signals (props, state, derived, context and store signals) and static values without issues.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#ui-agnostic",
    "title": "UI-agnostic",
    "text": "By default the web components are from Brisa, this makes it easy to have access to many features such as signals and optimizations so that they take up very little bundle size. However, in the end it translates to web components, if you want you can transform the web components from other frameworks such as React, Vue, Svelte, Lit or use native web components. We know that Brisa is very new, and the community behind it is growing, but it is still small compared to other frameworks. We believe it is important that you can use native web components to reuse many existing libraries, such as material components.",
    "titles": [
      "Web Components"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#native-web-components",
    "title": "Native web components",
    "text": "All native web components can be located inside web-components/_native and consumed in your components. Example: //web-components/\\_native/some-native.ts\nexport default class SomeNative extends HTMLElement {\n  constructor() {\n    super();\n    this.attachShadow({ mode: \"open\" });\n    this.shadowRoot.innerHTML = \"<h2>NATIVE WEB COMPONENT</h2>\";\n  }\n} Then you can consume it with <some-native /> depending the filename. In build-time is taken into account to import to your pages only the web components that the page is consuming, if it is not consumed, it will not be imported.",
    "titles": [
      "Web Components",
      "UI-agnostic"
    ]
  },
  {
    "id": "/building-your-application/components-details/web-components#components-from-react-vue-svelte",
    "title": "Components from React, Vue, Svelte...",
    "text": "We do not directly support a transformation of every component from another library to web components, but there are many alternatives that you can use: React to web components\nPreact to web components\nVue to web components\nSvelte to web components The transformation of UI components to custom elements should be the responsibility of each framework, Vue and Svelte currently support it in their core.",
    "titles": [
      "Web Components",
      "UI-agnostic"
    ]
  },
  {
    "id": "/building-your-application/configuring/asset-compression#assetcompression",
    "title": "assetCompression",
    "text": "By default, Brisa serves assets in their original form. However, you can configure Brisa to compress assets using GZIP or Brotli (depending on the browser). This can significantly reduce the size of assets, leading to faster load times and reduced bandwidth usage. Open the brisa.config.ts file and add the assetCompression configuration: import type { Configuration } from \"brisa\";\n\nexport default {\n  assetCompression: true,\n} satisfies Configuration; With this configuration, Brisa will compress all assets using GZIP and Brotli once in build time. When a browser requests an asset, Brisa will check if the browser supports Brotli compression. If the browser supports Brotli, Brisa will serve the Brotli-compressed asset. Otherwise, it will serve the GZIP-compressed asset. If you want to disable asset compression, set the assetCompression configuration to false or just remove it from the configuration. import type { Configuration } from \"brisa\";\n\nexport default {\n  assetCompression: false,\n} satisfies Configuration; When asset compression is disabled, Brisa will serve assets in their original form without any compression. (This is the default behavior.) Asset compression is a build-time operation. When you enable asset compression, Brisa will compress all assets during the build process. This can increase the build time, especially for large applications with many assets. However, the performance benefits of compressed assets usually outweigh the increased build time. If you want to serve assets from a CDN, you can use the assetPrefix configuration. For more information, see the assetPrefix documentation.",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/asset-prefix#assetprefix",
    "title": "assetPrefix",
    "text": "By default, Brisa serves assets from the same domain as the application. However, you can configure Brisa to use a Content Delivery Network (CDN) for serving assets. This is useful for improving the performance of your application by offloading static assets to a separate, geographically distributed server. Open the brisa.config.ts file and add the assetPrefix configuration: import type { Configuration } from \"brisa\";\n\nconst isProd = process.env.NODE_ENV === 'production'\n\nexport default {\n  assetPrefix: isProd ? \"https://your-cdn-url.com\" : undefined,\n} satisfies Configuration; Replace \"https://your-cdn-url.com\" with the base URL of your CDN. With this configuration, Brisa will prepend the assetPrefix to the URLs of all assets, such as images, stylesheets, and scripts. For example, if you have an image with the path /images/logo.png, Brisa will generate the URL as https://your-cdn-url.com/images/logo.png. When used with the output: \"static\" configuration, static assets will also be linked with the specified assetPrefix. For instance, if your static asset is /images/header.jpg, the generated file will be located at https://your-cdn-url.com/images/header.jpg instead of the default /images/header.jpg. Using a CDN for assets can significantly enhance the loading speed of your application by leveraging the CDN's global network infrastructure.",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/base-path#basepath",
    "title": "basePath",
    "text": "To deploy a Brisa application under a sub-path of a domain you can use the basePath config option. basePath allows you to set a path prefix for the application. For example, to use /docs instead of '' (an empty string, the default), open brisa.config.ts and add the basePath config: //brisa.config.ts\nimport type { Configuration } from \"brisa\";\n\nexport default {\n  basePath: \"/docs\",\n} satisfies Configuration; This value must be set at build time and cannot be changed without re-building as the value is inlined in the client-side bundles.",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/base-path#anchor-html-element-a",
    "title": "Anchor HTML element (a)",
    "text": "When linking to other pages using the anchor HTML element (a) the basePath will be automatically applied. For example, using /about will automatically become /docs/about when basePath is set to /docs. This makes sure that you don't have to change all links in your application when changing the basePath value.",
    "titles": [
      "basePath"
    ]
  },
  {
    "id": "/building-your-application/configuring/base-path#media-via-src-attribute",
    "title": "Media via src attribute",
    "text": "Consuming media with the src field (video, img...), if the path is relative the basePath is also added by default.",
    "titles": [
      "basePath"
    ]
  },
  {
    "id": "/building-your-application/configuring/brisa-config-js#brisaconfigjs-options",
    "title": "brisa.config.js options",
    "text": "The brisa.config.(js|ts|jsx|tsx) file is the main configuration file for an application using the Brisa framework. This file should export by default an object that satisfies the Configuration type structure. Below is a detailed explanation of how to define this configuration file and a unified example with comments on default values and how to configure them. import brisaTailwindCSS from \"brisa-tailwindcss\";\nimport type { Configuration } from \"brisa\";\n\nconst config: Configuration = {\n  /**\n   * `trailingSlash` configuration\n   * Default: undefined (trailing slash is not modified)\n   */\n  trailingSlash: true, // Adds trailing slash to URLs\n\n  /**\n   * `assetPrefix` configuration\n   * Default: undefined (no prefix added to assets)\n   */\n  assetPrefix: \"https://cdn.example.com\", // Prefix for assets\n\n  /**\n   * `extendPlugins` configuration\n   * Default: undefined (no additional plugins added)\n   */\n  extendPlugins: (plugins, { dev, isServer }) => [\n    ...plugins,\n    {\n      name: \"my-plugin\",\n      setup(build) {\n        build.onLoad({ filter: /\\.txt$/ }, async (args) => {\n          return {\n            contents: \"export default \" + JSON.stringify(args.path) + \";\",\n            loader: \"js\",\n          };\n        });\n      },\n    },\n  ],\n\n  /**\n   * `basePath` configuration\n   * Default: undefined (no base path added)\n   */\n  basePath: \"/my-app\", // Base path for the application\n\n  /**\n   * `tls` configuration\n   * Default: undefined (HTTPS is not enabled)\n   */\n  tls: {\n    cert: Bun.file(\"cert.pem\"),\n    key: Bun.file(\"key.pem\"),\n  }, // Enable HTTPS\n\n  /**\n   * `output` configuration\n   * Default: 'bun'\n   */\n  output: \"static\", // Output type of the application\n\n  /**\n   * `external` configuration\n   * Default: undefined (no external dependencies)\n   */\n  external: [\"lightningcss\"],\n\n  /**\n   * `integrations` configuration\n   * Default: undefined (no integrations added)\n   */\n  integrations: [brisaTailwindCSS()],\n};\n\n// Export the configuration as the default export\nexport default config satisfies Configuration;",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/brisa-config-js#trailingslashbuilding-your-applicationconfiguringtrailing-slash",
    "title": "trailingSlash",
    "text": "The trailingSlash option allows you to add a trailing slash to all URLs. This is useful when you want to enforce a trailing slash on all URLs. More information about the trailing slash can be found in the Configuration documentation.",
    "titles": [
      "brisa.config.js options"
    ]
  },
  {
    "id": "/building-your-application/configuring/brisa-config-js#assetprefixbuilding-your-applicationconfiguringasset-prefix",
    "title": "assetPrefix",
    "text": "The assetPrefix option allows you to add a prefix to all assets. This is useful when you want to serve assets from a CDN or a different domain. More information about the asset prefix can be found in the Configuration documentation.",
    "titles": [
      "brisa.config.js options"
    ]
  },
  {
    "id": "/building-your-application/configuring/brisa-config-js#extendpluginsbuilding-your-applicationconfiguringplugins",
    "title": "extendPlugins",
    "text": "The extendPlugins option allows you to add additional plugins to the Brisa build pipeline. This is useful when you want to extend the default behavior of the build process. More information about the asset prefix can be found in the Configuration documentation.",
    "titles": [
      "brisa.config.js options"
    ]
  },
  {
    "id": "/building-your-application/configuring/brisa-config-js#basepathbuilding-your-applicationconfiguringbase-path",
    "title": "basePath",
    "text": "The basePath option allows you to set a base path for the application. This is useful when you want to deploy the application under a sub-path of a domain. More information about the base path can be found in the Configuration documentation.",
    "titles": [
      "brisa.config.js options"
    ]
  },
  {
    "id": "/building-your-application/configuring/brisa-config-js#tlsbuilding-your-applicationconfiguringtls",
    "title": "tls",
    "text": "The tls option allows you to enable HTTPS for the application. This is useful when you want to serve the application over a secure connection. More information about the TLS configuration can be found in the Configuration documentation.",
    "titles": [
      "brisa.config.js options"
    ]
  },
  {
    "id": "/building-your-application/configuring/brisa-config-js#outputbuilding-your-applicationconfiguringoutput",
    "title": "output",
    "text": "The output option allows you to set the output type of the application. This is useful when you want to change the output directory of the application.",
    "titles": [
      "brisa.config.js options"
    ]
  },
  {
    "id": "/building-your-application/configuring/brisa-config-js#externalbuilding-your-applicationconfiguringexternal",
    "title": "external",
    "text": "The external option allows you to define external dependencies that should not be included in the final bundle. This is useful for libraries that are already included in the runtime environment, or for libraries that should be resolved at runtime. More information about the output configuration can be found in the Configuration documentation.",
    "titles": [
      "brisa.config.js options"
    ]
  },
  {
    "id": "/building-your-application/configuring/brisa-config-js#integrationsbuilding-your-applicationconfiguringintegrations",
    "title": "integrations",
    "text": "The integrations option allows you to integrate third-party libraries with the Brisa internals. This is useful when you want to automatically handle the integration of libraries like TailwindCSS.",
    "titles": [
      "brisa.config.js options"
    ]
  },
  {
    "id": "/building-your-application/configuring/clustering#clustering",
    "title": "clustering",
    "text": "To improve the performance and reliability of your Brisa application, you can enable clustering through the clustering configuration property. When clustering is true, Brisa will fork the process for each CPU core and will load balance the requests. The default value is true in production and when the operating system will load balance the requests correctly. Otherwise, the default value is false. The load balancing is working fine only in Linux. On Windows and macOS, the operating system does not load balance HTTP connections as one would expect.",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/clustering#example",
    "title": "Example",
    "text": "//brisa.config.ts\nimport type { Configuration } from \"brisa\";\n\nexport default {\n  clustering: true, // This enable clustering in prod and dev.\n} satisfies Configuration; To make it possible, Brisa uses node:cluster to handle the clustering. This Node API also works in Bun. If you need to use a Custom Server, this configuration does not apply, and you need to handle the clustering yourself.",
    "titles": [
      "clustering"
    ]
  },
  {
    "id": "/building-your-application/configuring/content-security-policy#content-security-policy",
    "title": "Content Security Policy",
    "text": "Content Security Policy (CSP) is important to guard your Brisa application against various security threats such as cross-site scripting (XSS), clickjacking, and other code injection attacks. Developers can specify which origins are permissible for content sources, scripts, stylesheets, images, fonts, objects, media (audio, video), iframes, and more.",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/content-security-policy#nonces",
    "title": "Nonces",
    "text": "A nonce is a unique, random string of characters created for a one-time use. It is used in conjunction with CSP to selectively allow certain inline scripts or styles to execute, bypassing strict CSP directives.",
    "titles": [
      "Content Security Policy"
    ]
  },
  {
    "id": "/building-your-application/configuring/content-security-policy#why-use-a-nonce",
    "title": "Why use a nonce?",
    "text": "Even though CSPs are designed to block malicious scripts, there are legitimate scenarios where inline scripts are necessary. In such cases, nonces offer a way to allow these scripts to execute if they have the correct nonce.",
    "titles": [
      "Content Security Policy",
      "Nonces"
    ]
  },
  {
    "id": "/building-your-application/configuring/content-security-policy#adding-a-nonce-with-middleware",
    "title": "Adding a nonce with Middleware",
    "text": "Middleware enables you to add headers and generate nonces before the page renders. Every time a page is viewed, a fresh nonce should be generated. This means that you must use dynamic rendering to add nonces. For example: import type { RequestContext } from \"brisa\";\n\nexport default function middleware(request: RequestContext) {\n  const nonce = Buffer.from(crypto.randomUUID()).toString(\"base64\");\n\n  request.headers.set(\"x-nonce\", nonce);\n  request.headers.set(\n    \"Content-Security-Policy\",\n    `\n    default-src 'self';\n    script-src 'self' 'nonce-${nonce}' 'strict-dynamic';\n    style-src 'self' 'nonce-${nonce}';\n    img-src 'self' blob: data:;\n    font-src 'self';\n    object-src 'none';\n    base-uri 'self';\n    form-action 'self';\n    frame-ancestors 'none';\n    block-all-mixed-content;\n    upgrade-insecure-requests;\n  `\n      .replace(/\\s{2,}/g, \" \")\n      .trim(),\n  );\n}\n\nexport function responseHeaders(request: RequestContext) {\n  return {\n    \"Content-Security-Policy\": request.headers.get(\"Content-Security-Policy\"),\n  };\n} By default, Middleware runs on all requests. You can filter Middleware using the url or the route of the Request Context. We recommend ignoring these: api (API routes)\nall request that route is null (files inside public folder) import type { RequestContext } from \"brisa\";\n\nexport default function middleware(req: RequestContext) {\n  // Early return\n  if (!req.route || req.route.name.startsWith(\"/api/\")) return;\n  // ...\n}",
    "titles": [
      "Content Security Policy",
      "Nonces"
    ]
  },
  {
    "id": "/building-your-application/configuring/content-security-policy#reading-the-nonce",
    "title": "Reading the nonce",
    "text": "You can now read the nonce from a Server Component using the Request Context: import type { RequestContext } from \"brisa\";\n\nexport default function Page({}, request: RequestContext) {\n  const nonce = request.headers.get(\"x-nonce\");\n\n  return (\n    <script src=\"https://www.googletagmanager.com/gtag/js\" nonce={nonce} />\n  );\n}",
    "titles": [
      "Content Security Policy",
      "Nonces"
    ]
  },
  {
    "id": "/building-your-application/configuring/custom-server#custom-server",
    "title": "Custom Server",
    "text": "",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/custom-server#bun-custom-server",
    "title": "Bun Custom Server",
    "text": "By default, Brisa includes its own server with brisa start. If you have an existing backend, you can still use it with Brisa (this is not a custom server). A custom Brisa server allows you to start a server 100% programmatically in order to use custom server patterns. Most of the time, you will not need this - but it's available for complete customization. Take a look at the following example of a custom server: import { getServeOptions, serve } from \"brisa/server\";\n\nconst { server, port, hostname } = serve({\n  ...await getServeOptions(),\n  port: 3001,\n});\n\nconsole.log(\n  \"Server ready ðŸ¥³\",\n  `listening on http://${hostname}:${port}...`,\n); If you want a custom handler, you can use the following: import { getServeOptions, serve } from \"brisa/server\";\n\nconst serveOptions = await getServeOptions();\n\nconst { server, port, hostname } = serve({\n  fetch(req, server) {\n    // Your implementation here ...\n\n    // Brisa handler\n    return serveOptions.fetch(req, server);\n  },\n  port: 3001,\n}); See all Bun.serve options in Bun.js docs. To run the custom server you'll need to update the scripts in package.json like so: {\n  \"scripts\": {\n    \"dev\": \"brisa build --dev && bun server.ts\",\n    \"build\": \"brisa build\",\n    \"start\": \"NODE_ENV=production bun server.ts\"\n  }\n} By default (without custom server) is: {\n  \"scripts\": {\n    \"dev\": \"brisa dev\",\n    \"build\": \"brisa build\",\n    \"start\": \"brisa start\"\n  }\n} If you use a custom server you need to handle clustering yourself. If you use a different runtime than Bun, like Node.js, you need to handle the WebSockets, HTTP/2, and other features yourself re-using the  serveOptions.",
    "titles": [
      "Custom Server"
    ]
  },
  {
    "id": "/building-your-application/configuring/custom-server#nodejs-custom-server",
    "title": "Node.js Custom Server",
    "text": "If you want to use a custom server with Node.js, you can use: import http from \"node:http\";\nimport { handler } from \"brisa/server/node\";\n\nconst server = http.createServer(handler).listen(3001); You can use the serve function from brisa/server/node for the same behavior:\nimport { serve } from \"brisa/server/node\";\n\nconst {server, port, hostname} = serve({ port: 3001 }); If you want to use a custom handler, you can use the Brisa handler function after your custom handler: import http from \"node:http\";\nimport { handler } from \"brisa/server/node\";\n\nconst customHandler = (req, res) => {\n  res.end(\"Hello World\");\n};\n\nconst server = http.createServer((req, res) => {\n  customHandler(req, res);\n  handler(req, res);\n}).listen(3001); If you use a Custom Server you need to handle the WebSockets, HTTP/2, and other features yourself re-using the  serveOptions. To use the serveOptions you can use the following: import { getServeOptions } from \"brisa/server\";\n\nconst serveOptions = await getServeOptions(); If you use a custom server you need to handle clustering yourself. To run the custom server you'll need to update the scripts in package.json like so: {\n  \"scripts\": {\n    \"dev\": \"brisa build --dev && node server.ts\",\n    \"build\": \"brisa build\",\n    \"start\": \"NODE_ENV=production node server.ts\"\n  }\n} By default (without custom server) is: {\n  \"scripts\": {\n    \"dev\": \"brisa dev\",\n    \"build\": \"brisa build\",\n    \"start\": \"brisa start\"\n  }\n}",
    "titles": [
      "Custom Server"
    ]
  },
  {
    "id": "/building-your-application/configuring/debugging#debugging",
    "title": "Debugging",
    "text": "",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/debugging#debugging-with-the-web-debugger",
    "title": "Debugging with the web debugger",
    "text": "",
    "titles": [
      "Debugging"
    ]
  },
  {
    "id": "/building-your-application/configuring/debugging#client-side-code",
    "title": "Client-side code",
    "text": "Start your development server as usual by running bun dev (or brisa dev). Once the server starts, open http://localhost:3000 (or your alternate URL) in Chrome. Next, open Chrome's Developer Tools (Ctrl+Shift+J on Windows/Linux, âŒ¥+âŒ˜+I on macOS), then go to the Sources tab. Now, any time your client-side code reaches a debugger statement, code execution will pause and that file will appear in the debug area. You can also press Ctrl+P on Windows/Linux or âŒ˜+P on macOS to search for a file and set breakpoints manually.",
    "titles": [
      "Debugging",
      "Debugging with the web debugger"
    ]
  },
  {
    "id": "/building-your-application/configuring/debugging#debug-web-components-changes-from-signals",
    "title": "Debug Web Components changes from Signals",
    "text": "To debug the interactions with the DOM that are generated inside the Web Components thanks to the signals, you have to place over the #shadow-root (open) (Dev tools â†’ element tab) and right click â†’ Break on â†’ subtree modifications. By activating the subtree modifications, the debugger will be opened each time a signal changes the DOM of the web component.",
    "titles": [
      "Debugging",
      "Debugging with the web debugger"
    ]
  },
  {
    "id": "/building-your-application/configuring/debugging#server-side-code",
    "title": "Server-side code",
    "text": "Brisa use the Bun debugger that speaks the WebKit Inspector Protocol. To enable debugging when running code with Brisa, use the bun dev:debug (or brisa dev --debug) command. For demonstration purposes, consider the following simple web server. [ wait ]   starting the development server...\n[ info ]   compiled successfully in 170.11ms.\n--------------------- Bun Inspector ---------------------\nListening:\n  ws://localhost:6499/7195wck9r6h\nInspect in browser:\n  https://debug.bun.sh/#localhost:6499/7195wck9r6h\n--------------------- Bun Inspector ---------------------\n[ info ]   hot reloading enabled\n[ ready ]  listening on http://localhost:3000... This automatically starts a WebSocket server on an available port that can be used to introspect the running Bun process. Various debugging tools can connect to this server to provide an interactive debugging experience. Bun hosts a web-based debugger at debug.bun.sh. It is a modified version of WebKit's Web Inspector Interface, which will look familiar to Safari users. Open the provided debug.bun.sh URL in your browser to start a debugging session. From this interface, you'll be able to view the source code of the running file, view and set breakpoints, and execute code with the built-in console.",
    "titles": [
      "Debugging",
      "Debugging with the web debugger"
    ]
  },
  {
    "id": "/building-your-application/configuring/environment-variables#environment-variables",
    "title": "Environment Variables",
    "text": "Brisa comes with built-in support for environment variables thanks to Bun, which allows you to do the following: Use .env.local to load environment variables\nBundle environment variables for the browser by prefixing with BRISA_PUBLIC_",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/environment-variables#loading-environment-variables",
    "title": "Loading Environment Variables",
    "text": "Brisa has built-in support for loading environment variables from .env.local into process.env. .env.local: DB_HOST=localhost\nDB_USER=myuser\nDB_PASS=mypassword This loads process.env.DB_HOST, process.env.DB_USER, and process.env.DB_PASS into the Bun environment automatically allowing you to use them in Brisa data fetching methods, middleware and API routes. For example, using middleware: src/middleware.ts: import { type RequestContext } from \"brisa\";\nimport myDB from \"some-db\";\n\nexport default async function middleware(request: RequestContext) {\n  const db = await myDB.connect({\n    host: process.env.DB_HOST,\n    username: process.env.DB_USER,\n    password: process.env.DB_PASS,\n  });\n  // ...\n} Using API Routes: src/api/hello.ts: import { type RequestContext } from \"brisa\";\n\nexport function GET(request: RequestContext) {\n  const db = await myDB.connect({\n    host: process.env.DB_HOST,\n    username: process.env.DB_USER,\n    password: process.env.DB_PASS,\n  });\n  // ...\n} Bun also exposes these variables via Bun.env and import.meta.env, which is a simple alias of process.env and you can use it in server files. Bun.env.DB_PASS; // => \"secret\"\nimport.meta.env.DB_PASS; // => \"secret\" Please note that Brisa will load the .env files only from the root folder and not from the /src folder.",
    "titles": [
      "Environment Variables"
    ]
  },
  {
    "id": "/building-your-application/configuring/environment-variables#bundling-environment-variables-for-the-browser",
    "title": "Bundling Environment Variables for the Browser",
    "text": "Non-BRISA_PUBLIC_ environment variables are only available in the Bun environment, meaning they aren't accessible to the browser (the client runs in a different environment). In order to make the value of an environment variable accessible in the browser, Brisa can \"inline\" a value, at build time, into the js bundle that is delivered to the client, replacing all references to process.env.[variable] with a hard-coded value. To tell it to do this, you just have to prefix the variable with BRISA_PUBLIC_. For example: BRISA_PUBLIC_ANALYTICS_ID=abcdefghijk This will tell Brisa to replace all references to process.env.BRISA_PUBLIC_ANALYTICS_ID in the Bun environment with the value from the environment in which you run brisa build, allowing you to use it anywhere in your code. It will be inlined into any JavaScript sent to the browser. After being built, your app will no longer respond to changes to these environment variables. For instance, if you build and deploy a single Docker image to multiple environments, all BRISA_PUBLIC_ variables will be frozen with the value evaluated at build time, so these values need to be set appropriately when the project is built. If you need access to runtime environment values, you'll have to setup your own API to provide them to the client (either on demand or during initialization). src/web-components/web-component.tsx: import { type WebContext } from \"brisa\";\nimport setupAnalyticsService from \"@/lib/my-analytics-service\";\n\nfunction WebComponent({}, { effect }: WebContext) {\n  effect(() => {\n    // 'BRISA_PUBLIC_ANALYTICS_ID' can be used here as it's prefixed by 'BRISA_PUBLIC_'.\n    // It will be transformed at build time to `setupAnalyticsService('abcdefghijk')`.\n    setupAnalyticsService(process.env.BRISA_PUBLIC_ANALYTICS_ID);\n  });\n\n  return <h1>Hello World</h1>;\n}\n\nexport default WebComponent; Note that dynamic lookups will not be inlined, such as: // This will NOT be inlined, because it uses a variable\nconst varName = \"BRISA_PUBLIC_ANALYTICS_ID\";\nsetupAnalyticsService(process.env[varName]);\n\n// This will NOT be inlined, because it uses a variable\nconst env = process.env;\nsetupAnalyticsService(env.BRISA_PUBLIC_ANALYTICS_ID);",
    "titles": [
      "Environment Variables"
    ]
  },
  {
    "id": "/building-your-application/configuring/environment-variables#default-environment-variables",
    "title": "Default Environment Variables",
    "text": "In general only one .env.local file is needed. However, sometimes you might want to add some defaults for the development (bun dev) or production (bun start) environment. Brisa allows you to set defaults in .env (all environments), .env.development (development environment), and .env.production (production environment). .env.local always overrides the defaults set. .env, .env.development, and .env.production files should be included in your repository as they define defaults. .env*.local should be added to .gitignore, as those files are intended to be ignored. .env.local is where secrets can be stored.",
    "titles": [
      "Environment Variables"
    ]
  },
  {
    "id": "/building-your-application/configuring/environment-variables#test-environment-variables",
    "title": "Test Environment Variables",
    "text": "Apart from development and production environments, there is a 3rd option available: test. In the same way you can set defaults for development or production environments, you can do the same with a .env.test file for the testing environment (though this one is not as common as the previous two). Brisa will not load environment variables from .env.development or .env.production in the testing environment. This one is useful when running tests with tools like playwright or cypress where you need to set specific environment vars only for testing purposes. Test default values will be loaded if NODE_ENV is set to test, though you usually don't need to do this manually as testing tools will address it for you. There is a small difference between test environment, and both development and production that you need to bear in mind: .env.local won't be loaded, as you expect tests to produce the same results for everyone. This way every test execution will use the same env defaults across different executions by ignoring your .env.local (which is intended to override the default set). Similar to Default Environment Variables, .env.test file should be included in your repository, but .env.test.local shouldn't, as .env*.local are intended to be ignored through .gitignore.",
    "titles": [
      "Environment Variables"
    ]
  },
  {
    "id": "/building-your-application/configuring/environment-variables#environment-variable-load-order",
    "title": "Environment Variable Load Order",
    "text": "Environment variables are looked up in the following places, in order, stopping once the variable is found. process.env\n.env.$(NODE_ENV).local\n.env.local (Not checked when NODE_ENV is test.)\n.env.$(NODE_ENV)\n.env For example, if NODE_ENV is development and you define a variable in both .env.development.local and .env, the value in .env.development.local will be used. The allowed values for NODE_ENV are production, development and test. If the environment variable NODE_ENV is unassigned, Brisa automatically assigns development when running the brisa dev command, or production for brisa build and brisa start.",
    "titles": [
      "Environment Variables"
    ]
  },
  {
    "id": "/building-your-application/configuring/environment-variables#quotation-marks",
    "title": "Quotation marks",
    "text": "Brisa supports double quotes, single quotes, and template literal backticks: .env: FOO='hello'\nFOO=\"hello\"\nFOO=`hello`",
    "titles": [
      "Environment Variables",
      "Environment Variable Load Order"
    ]
  },
  {
    "id": "/building-your-application/configuring/environment-variables#expansion",
    "title": "Expansion",
    "text": "Environment variables are automatically expanded. This means you can reference previously-defined variables in your environment variables. .env: FOO=world\nBAR=hello$FOO process.env.BAR; // => \"helloworld\" This is useful for constructing connection strings or other compound values. .env: DB_USER=postgres\nDB_PASSWORD=secret\nDB_HOST=localhost\nDB_PORT=5432\nDB_URL=postgres://$DB_USER:$DB_PASSWORD@$DB_HOST:$DB_PORT/$DB_NAME This can be disabled by escaping the $ with a backslash. .env: FOO=world\nBAR=hello\\$FOO process.env.BAR; // => \"hello$FOO\"",
    "titles": [
      "Environment Variables",
      "Environment Variable Load Order"
    ]
  },
  {
    "id": "/building-your-application/configuring/environment-variables#brisa-environment-variables",
    "title": "Brisa environment variables",
    "text": "BRISA_BUILD_FOLDER - You can define it to change the build folder and/or use it in your code to load files compiled for another process, see an example here.",
    "titles": [
      "Environment Variables",
      "Environment Variable Load Order"
    ]
  },
  {
    "id": "/building-your-application/configuring/environment-variables#dotenv",
    "title": "dotenv",
    "text": "Generally speaking, you won't need dotenv or dotenv-expand anymore, because Bun reads .env files automatically.",
    "titles": [
      "Environment Variables",
      "Environment Variable Load Order"
    ]
  },
  {
    "id": "/building-your-application/configuring/environment-variables#typescript",
    "title": "TypeScript",
    "text": "In TypeScript, all properties of process.env are typed as string | undefined. Bun.env.whatever;\n// string | undefined To get autocompletion and tell TypeScript to treat a variable as a non-optional string, we'll use interface merging. declare module \"bun\" {\n  interface Env {\n    AWESOME: string;\n  }\n} Add this line to any file in your project. It will globally add the AWESOME property to process.env and Bun.env. process.env.AWESOME; // => string",
    "titles": [
      "Environment Variables"
    ]
  },
  {
    "id": "/building-your-application/configuring/external#external-dependencies",
    "title": "External Dependencies",
    "text": "The external configuration property in brisa.config.ts allows you to define external dependencies that should not be included in the final bundle. This is useful for libraries that are already included in the runtime environment, or for libraries that should be resolved at runtime.",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/external#example",
    "title": "Example",
    "text": "In the next example, we are importing the lightningcss library as an external dependency. This means that the library will not be included in the final bundle, but will be resolved at runtime. import type { Configuration } from \"brisa\";\n\nexport default {\n  external: [\"lightningcss\"],\n} satisfies Configuration; This config property is used in the build processes we use with Bun bundler. For more information on this field, take a look at the Bun bundler documentation.",
    "titles": [
      "External Dependencies"
    ]
  },
  {
    "id": "/building-your-application/configuring/external#types",
    "title": "Types",
    "text": "export type Configuration = {\n  // ...\n  external?: string[];\n};",
    "titles": [
      "External Dependencies"
    ]
  },
  {
    "id": "/building-your-application/configuring/integrations#integrations",
    "title": "Integrations",
    "text": "Brisa, offers versatile integration with third-party libraries like TailwindCSS to be automatically handled for the Brisa internals. If you use brisa add tailwindcss and you do not have brisa.config.ts yet, this will be automatically generated: brisa.config.ts import brisaTailwindCSS from \"brisa-tailwindcss\";\nimport type { Configuration } from \"brisa\";\n\nexport default {\n  integrations: [brisaTailwindCSS()],\n} satisfies Configuration; In this example, this piece of code help to integrate TailwindCSS inside the Brisa internals.",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/integrations#types",
    "title": "Types",
    "text": "export type Configuration = {\n  // ...\n  integrations?: Integration[];\n};\n\nexport type Integration = {\n  name: string;\n  transpileCSS?(pathname: string, content: string): Promise<string>;\n  defaultCSS?: {\n    content: string;\n    applyDefaultWhenEvery: (content: string) => boolean;\n  }}",
    "titles": [
      "Integrations"
    ]
  },
  {
    "id": "/building-your-application/configuring/output#output",
    "title": "Output",
    "text": "Brisa, offers versatile output configuration options to tailor your build output according to your deployment needs. The output configuration property in brisa.config.ts allows you to define the type of output you desire, with options such as server, static, and desktop.",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/output#understanding-output-types",
    "title": "Understanding Output Types",
    "text": "",
    "titles": [
      "Output"
    ]
  },
  {
    "id": "/building-your-application/configuring/output#1-bunjs-server-output-bun",
    "title": "1. Bun.js Server Output (bun)",
    "text": "The bun output type generates a deployable server that can be hosted on a server infrastructure (Bun runtime). This is the default output type. To utilize this output type in your Brisa project, ensure that your brisa.config.ts file includes the following: import type { Configuration } from \"brisa\";\n\nexport default {\n  // \"bun\" is the default value when this configuration is not set\n  output: \"bun\",\n} satisfies Configuration; It is recommended to use the bun output type to leverage the complete set of features Brisa provides, enhancing your project with middleware capabilities, API endpoints, web sockets, and server-specific functionalities.",
    "titles": [
      "Output",
      "Understanding Output Types"
    ]
  },
  {
    "id": "/building-your-application/configuring/output#2-nodejs-server-output-node",
    "title": "2. Node.js Server Output (node)",
    "text": "The node output type is designed for creating deployable Node.js applications. To configure your Brisa project for Node.js server output, adjust your brisa.config.ts as follows: import type { Configuration } from \"brisa\";\n\nexport default {\n  output: \"node\",\n} satisfies Configuration; You can use specific Bun.js features only related with building the application, like Macros, but not runtime features like bun:ffi, for that you need to find the equivalent in Node.js.",
    "titles": [
      "Output",
      "Understanding Output Types"
    ]
  },
  {
    "id": "/building-your-application/configuring/output#3-static-output-static",
    "title": "3. Static Output (static)",
    "text": "The static output type creates a static export suitable for deployment to static hosting services. To configure your Brisa project for static output, adjust your brisa.config.ts as follows: import type { Configuration } from \"brisa\";\n\nexport default {\n  output: \"static\",\n} satisfies Configuration; Pure server stuff like api endpoints and server interactions will not work in runtime. All the interaction part should be in web-components only.",
    "titles": [
      "Output",
      "Understanding Output Types"
    ]
  },
  {
    "id": "/building-your-application/configuring/output#4-desktop-output-desktop",
    "title": "4. Desktop Output (desktop)",
    "text": "The desktop output type is designed for creating deployable desktop applications, integrated with Tauri. To set up your Brisa project for desktop output, modify your brisa.config.ts as shown below: import type { Configuration } from \"brisa\";\n\nexport default {\n  output: \"desktop\",\n} satisfies Configuration; Once activated you can call brisa dev to work locally with hotreloading in the desktop app or brisa build to build the desktop app native executables. You can do brisa dev --skip-tauri or brisa build --skip-tauri if you want to avoid creating and loading the desktop application. In production the build is done as static export, since there is no server.\nPure server stuff like api endpoints and server interactions will not work in runtime. All the interaction part should be in web-components only. Lean how to build a desktop app here.",
    "titles": [
      "Output",
      "Understanding Output Types"
    ]
  },
  {
    "id": "/building-your-application/configuring/output#5-android-output-android",
    "title": "5. Android Output (android)",
    "text": "The android output type is designed for creating deployable android applications, integrated with Tauri. To set up your Brisa project for desktop output, modify your brisa.config.ts as shown below: import type { Configuration } from \"brisa\";\n\nexport default {\n  output: \"android\",\n} satisfies Configuration; Prerequisits: You need to download Android Studio and follow these steps from Tauri documentation. Once activated you can call brisa dev to work locally with hotreloading in the android app or brisa build to build the android app native executables. You can do brisa dev --skip-tauri or brisa build --skip-tauri if you want to avoid creating and loading the android application. In production the build is done as static export, since there is no server.\nPure server stuff like api endpoints and server interactions will not work in runtime. All the interaction part should be in web-components only. Lean how to build a android app here.",
    "titles": [
      "Output",
      "Understanding Output Types"
    ]
  },
  {
    "id": "/building-your-application/configuring/output#6-ios-output-ios",
    "title": "6. iOS Output (ios)",
    "text": "The ios output type is designed for creating deployable iOS applications, integrated with Tauri. To set up your Brisa project for desktop output, modify your brisa.config.ts as shown below: import type { Configuration } from \"brisa\";\n\nexport default {\n  output: \"ios\",\n} satisfies Configuration; Prerequisits: You need to download iOS targets and follow these steps from Tauri documentation. Once activated you can call brisa dev to work locally with hotreloading in the iOS app or brisa build to build the iOS app native executables. You can do brisa dev --skip-tauri or brisa build --skip-tauri if you want to avoid creating and loading the iOS application. In production the build is done as static export, since there is no server.\nPure server stuff like api endpoints and server interactions will not work in runtime. All the interaction part should be in web-components only. Lean how to build a iOS app here.",
    "titles": [
      "Output",
      "Understanding Output Types"
    ]
  },
  {
    "id": "/building-your-application/configuring/output#additional-considerations",
    "title": "Additional Considerations",
    "text": "When configuring your output type, it's crucial to consider the deployment environment and requirements. Each output type serves a distinct purpose, and choosing the right one ensures optimal performance and compatibility. To view the changes in the output, run the brisa build command. In the case of server output, the build is generated in the build folder, while for static and desktop output, an additional out folder is created. The build folder is retained as it is needed to generate the initial build before generating static files or the desktop app in the separate out folder. Learn more details about static export here. If your application requires server-side features, like middleware or API endpoints, opt for the server output. For static websites, select the static output, and for desktop applications integrated with Tauri, use the desktop output.",
    "titles": [
      "Output"
    ]
  },
  {
    "id": "/building-your-application/configuring/output-adapter#output-adapter",
    "title": "Output Adapter",
    "text": "The outputAdapter configuration property in brisa.config.ts allows you to define the type of output adapter you desire, with options such as vercel. This enables you to deploy your Brisa project to various cloud providers, ensuring optimal performance and compatibility.",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/output-adapter#understanding-output-adapters",
    "title": "Understanding Output Adapters",
    "text": "",
    "titles": [
      "Output Adapter"
    ]
  },
  {
    "id": "/building-your-application/configuring/output-adapter#1-vercel-adapter-brisa-adapter-vercel",
    "title": "1. Vercel Adapter (brisa-adapter-vercel)",
    "text": "The vercel adapter allows you to deploy your Brisa project to Vercel, a cloud platform for static sites, serverless functions and edge entry points. To utilize this adapter in your Brisa project, ensure that your brisa.config.ts file includes the following: import vercel from 'brisa-adapter-vercel';\n\nexport default {\n  outputAdapter: vercel({ /* ... */ })\n}; In Vercel, the runtime is based on Node.js and/or Edge runtime.",
    "titles": [
      "Output Adapter",
      "Understanding Output Adapters"
    ]
  },
  {
    "id": "/building-your-application/configuring/output-adapter#documentation",
    "title": "Documentation",
    "text": "Vercel Adapter\nNetlify Adapter (coming soon)\nCloudflare Adapter (coming soon)",
    "titles": [
      "Output Adapter",
      "Understanding Output Adapters",
      "1. Vercel Adapter (brisa-adapter-vercel)"
    ]
  },
  {
    "id": "/building-your-application/configuring/plugins#plugins",
    "title": "Plugins",
    "text": "Brisa uses Bun, and Bun provides a universal plugin API that can be used to extend both the runtime and bundler. As Brisa requires bundler, we recommend you to use the bundler approach. Plugins intercept imports and perform custom loading logic: reading files, transpiling code, etc. They can be used to add support for additional file types, like .scss or .yaml. In the context of Bun's bundler, plugins can be used to implement framework-level features like CSS extraction, macros, and client-server code co-location.",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/plugins#usage-in-bundler",
    "title": "Usage in bundler",
    "text": "To use a plugin during the build, you must add it to the extendPlugins config in the brisa.config.ts file. Brisa will take care of running it for both the build of server files and the build of client files (web-components). import type { Configuration } from \"brisa\";\nimport { MyPlugin } from \"my-plugin\";\n\nexport default {\n  extendPlugins(plugins, { dev, isServer, entrypoint }) {\n    return [...plugins, MyPlugin];\n  },\n} satisfies Configuration; Parameter\nType\nDescription\n\n\n\n\nplugins\nBunPlugin[]\nArray of plugins to extend with.\n\n\noptions\nExtendPluginOptions\nOptions (see table below) Options: Field\nType\nDescription\n\n\n\n\ndev\nboolean\nIndicates whether it's a development build.\n\n\nisServer\nboolean\nIndicates whether it's a server build.\n\n\nentrypoint\nstring | undefined\nEntry point for client builds, optional for servers. On the server it is only executed once and the build is with all the entrypoints, while on the client a separate build is made for each page, that's why on the client there is the entrypoint field in the options. A plugin is defined as simple JavaScript object containing a name property and a setup function. Example of one: import type { BunPlugin } from \"bun\";\n\nexport const myPlugin: BunPlugin = {\n  name: \"Custom loader\",\n  setup(build) {\n    // implementation\n  },\n}; To know more about bundler Bun plugins take a look at the Bun documentation. In the case you want to know how to load plugins in runtime (not recommended in Brisa), take a look at this Bun documentation.",
    "titles": [
      "Plugins"
    ]
  },
  {
    "id": "/building-your-application/configuring/static-pages#static-pages",
    "title": "Static pages",
    "text": "",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/static-pages#prerender-some-pages-in-outputbun-or-outputnode",
    "title": "Prerender some pages in output=\"bun\" or output=\"node\"",
    "text": "In Brisa you can prerender pages to have a static/dynamic hybrid app. Although in the configuration is a JS Server you can indicate which pages you want to prerender during the build and then only have to serve the generated HTML file. For this to be possible, you have to put prerender named export on your pages: export const prerender = true;\n\nexport default function MyPage() {\n  // ...\n} The prerender export can be a boolean or a () => {[param: string]: string|string[]}[] |Â async () => {[param: string]: string|string[]}[] (only in the case of dynamic routes to indicate all the necesary params to prerender). In the case of a page that is not [dynamic], [[...catchAll]], or [...rest], the boolean is enough. The boolean only applies when the [`output` is a JS Server (`bun` | node`)](/building-your-application/configuring/output), for the other `output` types all pages will automatically be pre-rendered since there will be no server.",
    "titles": [
      "Static pages"
    ]
  },
  {
    "id": "/building-your-application/configuring/static-pages#prerender-dynamic-routes",
    "title": "Prerender dynamic routes",
    "text": "In the case of a page that is [dynamic], [[...catchAll]], or [...rest], we need to use the prerender export in a different way. Example of /pokemons/[slug].tsx: import type { RequestContext } from \"brisa\";\nimport { pokemons } from \"@/data\";\n\n// To prerender all pokemons, it is necessary to provide the\n// slug of \"/pokemons/[slug].tsx\"\nexport function prerender() {\n  return pokemons.map((pokemon) => ({\n    slug: pokemon.slug,\n  }));\n}\n\nexport default function PokemonPage({}, { route }: RequestContext) {\n  const slug = route.params.slug; // Read [slug] param\n  const pokemon = pokemons.find((p) => p.slug === slug);\n\n  return <h1>{pokemon.name}</h1>;\n} In this case, to prerender all pokemons, it is necessary that the prerender function returns an array with the slug of /pokemons/[slug].tsx. The prerender function can be synchronous or asynchronous, if you need to do fetch or any async operation you can do it without problems. This prerender option works for all types of output. In the case of already static output, it provides some useful information to convert dynamic paths to static ones, without this property, the example can not invert the pokemon paths.",
    "titles": [
      "Static pages"
    ]
  },
  {
    "id": "/building-your-application/configuring/static-pages#when-should-i-use-prerender",
    "title": "When should I use prerender?",
    "text": "You should use prerender if the page has no dynamic data and must be pre-rendered (for SEO) to be very fast.",
    "titles": [
      "Static pages"
    ]
  },
  {
    "id": "/building-your-application/configuring/static-pages#when-does-prerender-run",
    "title": "When does prerender run?",
    "text": "The prerender will only run during build in production, it will not be called during runtime. The code is never taken to client-side.",
    "titles": [
      "Static pages"
    ]
  },
  {
    "id": "/building-your-application/configuring/static-pages#where-can-i-use-prerender",
    "title": "Where can I use prerender?",
    "text": "The prerender can only be used inside paths that are pages (inside src/pages), it cannot be used anywhere else.",
    "titles": [
      "Static pages"
    ]
  },
  {
    "id": "/building-your-application/configuring/tls#tls",
    "title": "TLS",
    "text": "Brisa supports TLS out of the box thanks to Bun, powered by BoringSSL. Enable TLS by passing in a value for key and cert; both are required to enable TLS. brisa.config.ts: import type { Configuration } from \"brisa\";\n\nexport default {\n  tls: {\n    key: Bun.file(\"./key.pem\"),\n    cert: Bun.file(\"./cert.pem\"),\n  },\n} satisfies Configuration; The key and cert fields expect the contents of your TLS key and certificate, not a path to it. This can be a string, BunFile, TypedArray, or Buffer. brisa.config.ts: import type { Configuration } from \"brisa\";\n\nexport default {\n  tls: {\n    // BunFile\n    key: Bun.file(\"./key.pem\"),\n    // Buffer\n    key: fs.readFileSync(\"./key.pem\"),\n    // string\n    key: fs.readFileSync(\"./key.pem\", \"utf8\"),\n    // array of above\n    key: [Bun.file(\"./key1.pem\"), Bun.file(\"./key2.pem\")],\n  },\n} satisfies Configuration; If your private key is encrypted with a passphrase, provide a value for passphrase to decrypt it. brisa.config.ts: import type { Configuration } from \"brisa\";\n\nexport default {\n  tls: {\n    key: Bun.file(\"./key.pem\"),\n    cert: Bun.file(\"./cert.pem\"),\n    passphrase: \"my-secret-passphrase\",\n  },\n} satisfies Configuration; Optionally, you can override the trusted CA certificates by passing a value for ca. By default, the server will trust the list of well-known CAs curated by Mozilla. When ca is specified, the Mozilla list is overwritten. brisa.config.ts: import type { Configuration } from \"brisa\";\n\nexport default {\n  tls: {\n    key: Bun.file(\"./key.pem\"), // path to TLS key\n    cert: Bun.file(\"./cert.pem\"), // path to TLS cert\n    ca: Bun.file(\"./ca.pem\"), // path to root CA certificate\n  },\n} satisfies Configuration; To override Diffie-Helman parameters: import type { Configuration } from \"brisa\";\n\nexport default {\n  tls: {\n    // other config\n    dhParamsFile: \"/path/to/dhparams.pem\", // path to Diffie Helman parameters\n  },\n} satisfies Configuration;",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/tls#tls-in-nodejs",
    "title": "TLS in Node.js",
    "text": "If you're using Node.js runtime, you can also configure TLS using the tls field in your configuration. import { readFileSync } from \"node:fs\";\nimport type { Configuration } from \"brisa\";\n\nexport default {\n  tls: {\n    key: readFileSync(\"./key.pem\"),\n    cert: readFileSync(\"./cert.pem\"),\n  },\n} satisfies Configuration; Theses fields are passed directly to the https.createServer method, so you can use any of the options available in the Node.js documentation. Example: import { readFileSync } from \"node:fs\";\n\nexport default {\n  tls: {\n    key: readFileSync(\"./key.pem\"),\n    cert: readFileSync(\"./cert.pem\"),\n    // Other options\n    ciphers: \"ECDHE-RSA-AES128-GCM-SHA256\",\n    honorCipherOrder: true,\n  },\n} satisfies Configuration;",
    "titles": [
      "TLS"
    ]
  },
  {
    "id": "/building-your-application/configuring/trailing-slash#trailing-slash",
    "title": "Trailing slash",
    "text": "By default Brisa will redirect urls with trailing slashes to their counterpart without a trailing slash. For example /about/ will redirect to /about. You can configure this behavior to act the opposite way, where urls without trailing slashes are redirected to their counterparts with trailing slashes. Open brisa.config.ts and add the trailingSlash config: import type { Configuration } from \"brisa\";\n\nexport default {\n  trailingSlash: true,\n} satisfies Configuration; With this option set, urls like /about will redirect to /about/. When used with output: \"static\" configuration, the /about page will output /about/index.html (instead of the default /about.html).",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/typescript#typescript",
    "title": "TypeScript",
    "text": "Brisa provides a TypeScript-first development experience for building your application. It comes with built-in TypeScript support for automatically installing the necessary packages and configuring the proper settings thanks to Bun. bun create brisa ships with TypeScript by default. bun create brisa By default tsconfig.json file is created, with the @ path. Please, do not modify this path alias configuration. It's internally used in Brisa \"types.ts\" file to enable type-safe. If you need a different one, add it.",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/typescript#documentation-on-types",
    "title": "Documentation on types",
    "text": "One of the things we have focused a lot on is that developers can learn and consult documentation in the code itself without having to go to the browser. You can hover over each WebContext/RequestContext property/method to get information and access the documentation link for more info. Also while typing JSX you can consult documentation for each HTML element and each attribute.",
    "titles": [
      "TypeScript"
    ]
  },
  {
    "id": "/building-your-application/configuring/typescript#type-safe-for-web-components",
    "title": "Type-safe for web components",
    "text": "Web components are like other HTML elements, that is, you don't need to import them to use them. However, to improve the DX we offer type-safe to show you all the web components you have inside the web-components folder. Thanks to this: you can read your JSX to know which components are clients and which are servers, and you don't mix client code in the server components. The type-safe for web components are created inside the development CLI. If they do not appear, you must have \"brisa dev\" open.",
    "titles": [
      "TypeScript"
    ]
  },
  {
    "id": "/building-your-application/configuring/typescript#safe-return-on-components",
    "title": "Safe return on components",
    "text": "Using eslint (optional) with @typescript-eslint/no-unsafe-return, you can use JSXNode from brisa. export default function MyComponent(): JSX.Element {\n  return <div>Hello World</div>;\n}",
    "titles": [
      "TypeScript"
    ]
  },
  {
    "id": "/building-your-application/configuring/typescript#type-safe-for-i18n",
    "title": "Type-safe for i18n",
    "text": "There is type-safe enabled for all i18n keys that you can consume on the pages.",
    "titles": [
      "TypeScript"
    ]
  },
  {
    "id": "/building-your-application/configuring/zig-rust-c-files#use-c-abi-files-zig-rust-cc-c-nim-kotlin",
    "title": "Use C ABI files (zig, rust, c/c++, c#, nim, kotlin...)",
    "text": "If you need to utilize files from different C ABI languages (Zig, Rust, C/C++, C#, Nim, Kotlin, etc.), you can achieve this as follows:",
    "titles": []
  },
  {
    "id": "/building-your-application/configuring/zig-rust-c-files#create-your-zig-rust-or-other-file",
    "title": "Create Your Zig, Rust, or Other File:",
    "text": "Zig: // add.zig\npub export fn add(a: i32, b: i32) i32 {\n  return a + b;\n} or with Rust: // add.rs\n#[no_mangle]\npub extern \"C\" fn add(a: isize, b: isize) -> isize {\n    a + b\n} If you are using node as output, this documentation does not apply. You need to find the equivalent in Node.js.",
    "titles": [
      "Use C ABI files (zig, rust, c/c++, c#, nim, kotlin...)"
    ]
  },
  {
    "id": "/building-your-application/configuring/zig-rust-c-files#compile-your-files",
    "title": "Compile Your Files",
    "text": "You need to compile it before using it in your Brisa app. Zig: zig build-lib add.zig -dynamic -OReleaseFast or with Rust: rustc --crate-type cdylib add.rs Then, we need to move the generated files inside the prebuild folder. This prebuild folder is used during brisa dev and brisa build where all the prebuild files are copied inside build/prebuild, to be able to use them later in runtime. Example of script inside package.json to compile inside prebuild folder: {\n  \"scripts\": {\n    \"dev\": \"brisa dev\",\n    \"build\": \"brisa build\",\n    \"start\": \"brisa start\",\n    \"build:zig\": \"cd prebuild && bun run build:zig:for-your-computer && bun run build:zig:docker:oven/bun && cd ..\",\n    \"build:zig:for-your-computer\": \"zig build-lib ../src/zig/add.zig -dynamic -OReleaseFast\",\n    \"build:zig:docker:oven/bun\": \"zig build-lib ../src/zig/add.zig -dynamic -OReleaseFast -target x86_64-linux-musl\"\n  }\n} If you do not have the prebuild folder you must create it.",
    "titles": [
      "Use C ABI files (zig, rust, c/c++, c#, nim, kotlin...)"
    ]
  },
  {
    "id": "/building-your-application/configuring/zig-rust-c-files#create-a-jsts-bridge",
    "title": "Create a JS/TS Bridge",
    "text": "Develop a JavaScript/TypeScript file to bridge to the compiled file. // src/utils/add.ts\nimport { dlopen, FFIType, suffix } from \"bun:ffi\";\nimport path from \"node:path\";\n\nconst compileFilePath = path.join(\n  // You can use BRISA_BUILD_FOLDER env to access to the build folder\n  Bun.env.BRISA_BUILD_FOLDER,\n  // \"prebuild\" folder during build time is copied inside the build folder\n  \"prebuild\",\n  // `suffix` is either \"dylib\", \"so\", or \"dll\" depending on the platform\n  // you don't have to use \"suffix\", it's just there for convenience\n  `libadd.${suffix}`,\n);\n\nconst lib = dlopen(compileFilePath, {\n  add: {\n    args: [FFIType.i32, FFIType.i32],\n    returns: FFIType.i32,\n  },\n});\n\nexport default lib.symbols.add; Ensure correct typing for the args and the return. Access the environment variable BRISA_BUILD_FOLDER via process.env.BRISA_BUILD_FOLDER or Bun.env.BRISA_BUILD_FOLDER. This represents the path to the build folder, where the prebuild files are located. Bun.env.BRISA_BUILD_FOLDER works in development and production.",
    "titles": [
      "Use C ABI files (zig, rust, c/c++, c#, nim, kotlin...)"
    ]
  },
  {
    "id": "/building-your-application/configuring/zig-rust-c-files#consume-it-in-your-server-code",
    "title": "Consume it in Your Server Code",
    "text": "Now, you can use it in any server file: components, layout, middleware, API, response headers, etc. // src/pages/index.tsx\nimport add from \"@/utils/add\";\n\nexport default function HomePage() {\n  return <div>5+5 is {add(5, 5)}</div>;\n} For more details, such as dealing with pointers, refer to Bun's FFI documentation.",
    "titles": [
      "Use C ABI files (zig, rust, c/c++, c#, nim, kotlin...)"
    ]
  },
  {
    "id": "/building-your-application/data-management/fetching#data-fetching",
    "title": "Data Fetching",
    "text": "Data fetching is a fundamental aspect of any application, influencing its performance and user experience. This documentation outlines how data fetching can be accomplished in a Brisa application, emphasizing best practices and efficient strategies.",
    "titles": []
  },
  {
    "id": "/building-your-application/data-management/fetching#fetching-data-with-fetch",
    "title": "Fetching Data with fetch",
    "text": "Brisa recommend to use the native fetch Web API. We don't make any modifications to the native implementation to handle caching, revalidation, or anything magical, the fetch works as fetch, because it is the native one. We believe that adding cache and extending the native fetch is a sign of an incorrect design of how to fetch data. So to fix this we have improved the way to share this data in your application. As all components (server/web) can be async/await and are rendered only once, you can do this without problems: export default async function ServerComponent() {\n  const res = await fetch(/* */);\n\n  // Your server component logic\n} or export default async function WebComponent() {\n  const res = await fetch(/* */);\n\n  // Your web component logic\n} In the same way, you can fetch data in the middleware, layout, responseHeaders, Head, suspense phase, etc, and share the data with the rest of the application.",
    "titles": [
      "Data Fetching"
    ]
  },
  {
    "id": "/building-your-application/data-management/fetching#suspense-phase",
    "title": "Suspense phase",
    "text": "Each component (server-component and web-component) allows an extension to add a suspense component to it, which is the fallback that will be displayed while the component loads. SomeComponent.suspense = ({}, { i18n }) => {\n  return <div>{i18n.t('loading-message')...}</div>\n} Suspense is useful during HTML streaming, while the server loads the data the suspense content is displayed, and once the server loads the data, during streaming the suspense is changed to the real content, all this without the client having to make any request to the server.",
    "titles": [
      "Data Fetching"
    ]
  },
  {
    "id": "/building-your-application/data-management/fetching#async-generators",
    "title": "Async generators",
    "text": "async generators are also supported if you want to stream every item in a list for example: async function* List() {\n  yield <li>{await foo()}</li>;\n  yield <li>{await bar()}</li>;\n  yield <li>{await baz()}</li>;\n} This can be used as a server component: return <List />; And the HTML is resolved via streaming.",
    "titles": [
      "Data Fetching"
    ]
  },
  {
    "id": "/building-your-application/data-management/fetching#share-server-server-data-between-components",
    "title": "Share server-server data between components",
    "text": "To share data across all parts of the server (middleware, layout, responseHeaders, Head, suspense phase, etc) there are two ways: Request store\nContext API Example using store: import { type RequestContext } from \"brisa\";\n\ntype Props = {};\n\nexport async function Main({}: Props, request: RequestContext) {\n  const res = await fetch(/* */);\n  const user = await res.json();\n\n  // Set key-value data to request store\n  request.store.set(\"user\", user);\n\n  return <UserInfo />;\n}\n\nMain.suspense = ({}: Props, request: RequestContext) => (\n  <div>Loading user...</div>\n);\n\nexport function UserInfo({}: Props, request: RequestContext) {\n  const user = request.store.get(\"user\");\n\n  return <div>Hello {user.name}</div>;\n} Example using Context API: import { type RequestContext, createStore } from \"brisa\";\n\ntype Props = {};\n\nconst UserCtx = createStore();\n\nexport async function Main({}: Props, request: RequestContext) {\n  const res = await fetch(/* */);\n  const user = await res.json();\n\n  // Use serverOnly inside context-provider to avoid to create a web\n  // component for the provider and share the data only with the\n  // server part\n  return (\n    <context-provider serverOnly context={UserCtx} value={user}>\n      <UserInfo />\n    </context-provider>\n  );\n}\n\nMain.suspense = ({}: Props, request: RequestContext) => (\n  <div>Loading user...</div>\n);\n\nexport function UserInfo({}: Props, request: RequestContext) {\n  const user = request.useContext(UserCtx);\n\n  return <div>Hello {user.value.name}</div>;\n} We recommend that whenever possible you add the data to the store inside the request. And use the Context API only in specific cases where you only want to share this data with a piece of the component tree. The reason is that the Context API is more expensive and if you don't put the serverOnly attribute it creates a DOM element (context-provider) and shares the data with the rest of the web-components that are in the same component tree. In both cases the data lives within the lifetime of the request, it is not global data, and one of the benefits is that all server-components receive the RequestContext as a second parameter, and you can access easly to that data. The RequestContext is an extension of the Request, where apart from the Request API you have some extra things, such as the store. If your data is utilized in multiple locations, and you wish to display the suspense at the lowest-level component while making only one request, we recommend passing down the promise and resolving it in all child components that utilize this data.",
    "titles": [
      "Data Fetching"
    ]
  },
  {
    "id": "/building-your-application/data-management/fetching#share-web-web-data-between-components",
    "title": "Share web-web data between components",
    "text": "To share data across all web components there are also the same two ways: Web Context store\nContext API Example using store: src/web-components/main-app.ts import { type WebContext } from \"brisa\";\n\ntype Props = {};\n\nexport default async function MainApp({}: Props, { store }: WebContext) {\n  const res = await fetch(/* */);\n  const user = await res.json();\n\n  // Set key-value data to request store\n  store.set(\"user\", user);\n\n  return <user-info />;\n}\n\nMainApp.suspense = ({}: Props, webContext: WebContext) => (\n  <div>Loading user...</div>\n); src/web-components/user-info.ts export default function UserInfo({}: Props, { store, derived }: WebContext) {\n  const username = derived(() => store.get(\"user\").name);\n\n  return <div>Hello {username}</div>;\n} Example using Context API: src/web-components/main-app.ts import { type WebContext, createStore } from \"brisa\";\n\ntype Props = {};\n\nconst UserCtx = createStore();\n\nexport default async function Main({}: Props, request: WebContext) {\n  const res = await fetch(/* */);\n  const user = await res.json();\n\n  // Use context-provider to share the data with the\n  // web part\n  return (\n    <context-provider context={UserCtx} value={user}>\n      <user-info />\n    </context-provider>\n  );\n}\n\nMain.suspense = ({}: Props, webContext: WebContext) => (\n  <div>Loading user...</div>\n); src/web-components/user-info.ts export default function UserInfo({}: Props, { useContext }: WebContext) {\n  const user = useContext(UserCtx);\n\n  return <div>Hello {user.value.name}</div>;\n} We recommend that whenever possible you add the data to the store. And use the Context API only in specific cases where you only want to share this data with a piece of the component tree. The reason is that the Context API is more expensive and it creates a DOM element (context-provider).",
    "titles": [
      "Data Fetching"
    ]
  },
  {
    "id": "/building-your-application/data-management/fetching#re-fetch-data-in-web-components",
    "title": "Re-fetch data in web components",
    "text": "Web-components are reactive, and although they are only rendered once when the component is mounted, an effect can be used to do a re-fetch whenever a signal (prop, state, store, context...) changes. export default async function WebComponent(\n  { foo }: Props,\n  { store, store }: WebContext,\n) {\n  await effect(async () => {\n    if (foo === \"bar\") {\n      const res = await fetch(/* */);\n      const user = await res.json();\n      // Set key-value data to request store\n      store.set(\"user\", user);\n    }\n  });\n\n  return <user-info />;\n} An effect can be async/await without any problems. In this example, every time the foo prop signal inside the effect changes, the effect will be executed again. When updating the store, all web-components that reactively consumed this store entry will be updated with the new data.",
    "titles": [
      "Data Fetching",
      "Share web-web data between components"
    ]
  },
  {
    "id": "/building-your-application/data-management/fetching#share-server-web-data-between-components",
    "title": "Share server-web data between components",
    "text": "To share data across all parts of the server and web there are two ways: Request store using transferToClient method\nContext API (without serverOnly prop) Example using store: src/components/server-component.tsx import { type RequestContext } from \"brisa\";\n\ntype Props = {};\n\nexport async function ServerComponent({}: Props, { store }: RequestContext) {\n  const res = await fetch(/* */);\n  const user = await res.json();\n\n  // Set key-value data to request store\n  store.set(\"user\", user);\n  // Transfer \"user\" key-value to WebContext store\n  store.transferToClient([\"user\"]);\n\n  return <user-info />;\n}\n\nMain.suspense = ({}: Props, request: RequestContext) => (\n  <div>Loading user...</div>\n); src/web-components/user-info.tsx import { type WebContext } from \"brisa\";\n\nexport function UserInfo({}: Props, { store }: WebContext) {\n  // Consuming \"user\" store value in a web-component:\n  return <div>Hello {store.get(\"user\").name}</div>;\n} By default the RequestContext store is for sharing data only during the lifetime of the request and therefore only with server components. However, the store has the transferToClient method to transmit keys from the dictionary to the WebContext store. Example using Context API: src/context/user.ts import { createStore } from \"brisa\";\n\nexport const UserCtx = createStore(); src/components/server-component.tsx import { type RequestContext } from \"brisa\";\nimport { UserCtx } from \"@/context/user\";\n\ntype Props = {};\n\nexport async function Main({}: Props, request: RequestContext) {\n  const res = await fetch(/* */);\n  const user = await res.json();\n\n  // Use context-provider to share the data with the\n  // rest of server tree and also the web tree\n  return (\n    <context-provider context={UserCtx} value={user}>\n      <user-info />\n    </context-provider>\n  );\n}\n\nMain.suspense = ({}: Props, request: RequestContext) => (\n  <div>Loading user...</div>\n); src/web-components/user-info.tsx import { type WebContext } from \"brisa\";\nimport { UserCtx } from \"@/context/user\";\n\nexport function UserInfo({}: Props, { useContext }: WebContext) {\n  const user = useContext(UserCtx);\n\n  return <div>Hello {user.value.name}</div>;\n} The Context API by default shares server-web data unless we pass the serverOnly attribute to make it server-server only. All data transferred between server-web must be serializable. You can encrypt store data if you want to transfer sensitive data to the server actions so that it cannot be accessed from the client.",
    "titles": [
      "Data Fetching"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#server-actions",
    "title": "Server Actions",
    "text": "Server Actions are functions/arrow functions that are executed on the server once the user interacts with the page. They can be used only in Server Components to handle browser events on the server. Server Actions are a powerful tool to handle events on the server and do data mutations, validations, and more.",
    "titles": []
  },
  {
    "id": "/building-your-application/data-management/server-actions#convention",
    "title": "Convention",
    "text": "A Server Action can be defined like a browser event inside the Server Component JSX. <button\n  onClick={(e) =>\n    console.log(\n      \"this code is executed on the server in case of Server Components\",\n      e,\n    )\n  }\n>\n  Click to run a server action\n</button> While web-components these actions are browser events and are processed from the client, in server components these actions are executed on the server, having access to the serialized event. You can pass server actions as props in the same way of events. At the moment the action is placed in a web component, inside the web component the real event of the browser acts, and outside the web component then it is executed from the server.",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#behavior",
    "title": "Behavior",
    "text": "Server Actions are not limited to <form> and can be invoked from any element like <button>.\nServer Actions are Hypermedia-driven, when an action is invoked, it can respond new HTML and update the UI only by affecting the parts of the DOM that have modified and the web-components can respond reactively to the changes, all in a single round-trip from the server.\nBehind the scenes, actions use the POST method, and only this HTTP method can invoke them.\nWhen an action is invoked the preventDefault is automatic called.\nServer Actions serialize the event to access it from the server. In the case of onSubmit, it process the formData to send it to the server, then the event changes from SubmitEvent to FormDataEvent, so you can access directly to the e.formData.\nServer Actions are functions. This means they can be reused anywhere in your application. Server actions only work with a server (output as bun | node).",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#forms",
    "title": "Forms",
    "text": "Brisa transforms the SubmitEvent to FormDataEvent, so you can access directly to the e.formData. This is because Brisa have to build the formData before sending it to the server, so on the server it is already built. export default function Form() {\n  return (\n    <form\n      onSubmit={(e) => {\n        console.log(\"Username:\", e.formData.get(\"username\"));\n      }}\n    >\n      <label>\n        Username:\n        <input type=\"text\" name=\"username\" />\n      </label>\n      <br />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n} When working with forms that have many fields, you may want to consider using the entries() method with JavaScript's Object.fromEntries(). For example: const rawFormData = Object.fromEntries(formData.entries())",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#form-action-without-js",
    "title": "Form action without JS",
    "text": "When you use the onSubmit action of a form, it can work without JavaScript automatically. However, if you want a different behavior when the user does not have JavaScript you can override the \"action\", \"enctype\" and \"method\" attributes and connect it to a specific endpoint. Normally it will not be necessary to overwrite them, but we prefer that it is feasible to do so. The differences to be taken into account when no-JS are: No action signals can be used, the properties of the store at this point die on the client.\nThe page is reloaded always with the new content, instead of doing the rerenderInAction.",
    "titles": [
      "Server Actions",
      "Forms"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#nested-actions",
    "title": "Nested actions",
    "text": "In Brisa we allow nested actions to be used. We want the actions in the server components to be as similar as possible to the events in the web components. export function ParentComponent() {\n  function onAction() {\n    console.log(\"this works in the server\");\n  }\n\n  return <ChildComponent onAction={onAction} />;\n}\n\nfunction ChildComponent({ onAction }: { onAction: () => void }) {\n  return <button onClick={onAction}>Run the action</button>;\n} This way you can divide responsibilities between components if you wish and share data between actions: export function ParentComponent() {\n  function onAction(data: string) {\n    console.log(\"server data:\", data);\n  }\n\n  return <ChildComponent onAction={onAction} />;\n}\n\nfunction ChildComponent({ onAction }: { onAction: () => void }) {\n  return (\n    <button\n      onClick={() => {\n        const data = \"We can transfer data in nested actions\";\n        onAction(data);\n      }}\n    >\n      Run the action\n    </button>\n  );\n} Actions and nested actions are always async. The actions, even if you have not written them async, are always executed async, if you need to do something after executing a nested action it is necessary to put an await: async function onAction() {\n  await onNestedAction();\n  console.log(\"Done!\");\n}",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#server-side-validation-and-error-handling",
    "title": "Server-side validation and error handling",
    "text": "We recommend using HTML validation like required and type=\"email\" for basic client-side form validation. For more advanced server-side validation, you can use a library like zod to validate the form fields before mutating the data, together with Action Signals (store). import type { RequestContext } from \"brisa\";\nimport { rerenderInAction } from \"brisa/server\";\nimport { z } from \"zod\";\n\nconst schema = z.object({\n  email: z.string().email({ message: \"Invalid email\" }),\n});\n\n// Reactive server component without the need to create a client component:\nexport default function Form({}, { store }: RequestContext) {\n  const errors = store.get(\"errors\");\n\n  // You extend the life of the store from request-time:\n  //  render (server) â†’ ðŸ’€\n  // to:\n  //  render (server) â†’ client â†’ action (server) â†’ rerender (server) â†’ client â†’ ...\n  store.transferToClient([\"errors\"]);\n\n  return (\n    <form\n      onSubmit={(e) => {\n        const email = e.formData.get(\"email\");\n        const result = schema.safeParse({ email });\n\n        store.set(\"errors\", result.success ? null : result.error.format());\n\n        // rerenderInAction is used to make the server components reactively react\n        // to the store change as well. If rerenderInAction is not used, only the\n        // web components that are listening to the store.get('errors') signal\n        // react to the changes.\n        rerenderInAction({ type: \"page\" });\n      }}\n    >\n      <input name=\"email\" type=\"text\" />\n      {errors?.email && <p>{errors.email._errors.toString()}</p>}\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n} Before mutating data, you should always ensure a user is also authorized to perform the action. See Authentication and Authorization.",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#action-fail-handling",
    "title": "Action fail handling",
    "text": "If the server action fails, you can access from the web components to the error message through the error signal inside the IndicatorSignal. import { type WebContext } from \"brisa\";\n\ntype Props = { actionId: string };\n\nexport default async function ActionError(\n  { actionId }: Props,\n  { indicate }: WebContext,\n) {\n  const actionIndicator = indicate(actionId);\n\n  if (typeof actionIndicator.error.value !== \"string\") return;\n\n  return <div>Error: {actionIndicator.error.value}</div>;\n} In this example, the action-error web component takes an actionId prop and utilizes the indicate method to obtain the indicator signal associated with that specific action. The code then checks whether the error value within the indicator is a string. If it is, the component renders a UI element displaying the error message. This mechanism allows developers to seamlessly incorporate error handling into their web components, enhancing the user experience by providing meaningful error information when server actions encounter issues. The same actionId as the value for the indicate[Event] linking the indicator to the corresponding server action. This cohesive association allows developers to seamlessly integrate error handling into their web components, ensuring that meaningful error information is presented to users when server actions encounter issues.",
    "titles": [
      "Server Actions",
      "Server-side validation and error handling"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#debounce",
    "title": "Debounce",
    "text": "Brisa extends all the HTML element events (onInput, onMouseOver, onTouchStart...) to allow to debounce the action call by replacing the on prefix to debounce. <input\n  type=\"text\"\n  onInput={(e) => console.log(e.target.value)}\n  debounceInput={400}\n/> The time unit consistently remains in milliseconds. In this example, the call to the server and consequently the execution of console.log will only take place 400ms after the user ceases typing in the textbox. Only works in the HTML elements that trigger the action, if you use it in the components as a prop it will only work if you use it inside the component to link it with the HTML element that triggers the action. The only exception is to use it in a web-component from a server component, as the web components are transformed into real HTML elements that trigger actions, then in this case it does work. This is only implemented for server actions, for browsers events inside web components it does not apply since we do not modify the original event.",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#optimistic-updates",
    "title": "Optimistic updates",
    "text": "Optimistic updates are a strategy used in client-server architectures to enhance the user experience by locally updating the user interface (UI) optimistically before receiving confirmation from the server about the success of an operation. This approach aims to reduce perceived latency and provide a more responsive application. In Brisa, we support optimistic updates to manage server actions, and this is achieved through the use of the setOptimistic method within the store of web components. Example of web component (like-button): import type { WebContext } from \"brisa\";\n\ntype Props = { onLike: () => void };\n\nexport default function LikeButton({ onLike }: Props, { store }: WebContext) {\n  return (\n    <button\n      onClick={() => {\n        store.setOptimistic<number>(\"like-action\", \"likes\", (v) => v + 1);\n        onLike();\n      }}\n    >\n      Like ({store.get(\"likes\")})\n    </button>\n  );\n} Here, the like-button web component employs the setOptimistic method to optimistically increment the 'likes' count on the client side, assuming a successful action. The current 'likes' count is then displayed in the UI. Now, let's observe how this like-button is utilized in a server component, complete with the associated server action: import type { RequestContext } from 'brisa';\nimport { getUser, updateDB } from '@/helpers'\n\nfunction Page({}, request: RequestContext)\n  const { store, indicate } = request;\n  const indicator = indicate('like-action')\n\n  store.transferToClient(['likes'])\n\n  async function onLikeAction() {\n    const user = getUser(request)\n    const updatedNum = await updateDB(user)\n    // Update shared store with the client:\n    store.set('likes', updatedNum)\n  }\n\n  return (\n    <like-button\n      // It's necessary to connect the indicator to the action\n      indicateLike={indicator}\n      onLike={onLikeAction}\n    />\n  )\n} In the server component, we utilize the transferToClient method to relay the 'likes' data to the client-side store. Upon executing the action, the server component interacts with the database, and if successful, it updates the shared store with the new 'likes' count. It's crucial to note that in the event of a failed request action, the optimistic update is automatically reverted to the previous state, ensuring data consistency.",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#optimistic-updates-via-url-params",
    "title": "Optimistic updates via URL params",
    "text": "If you want to use the optimistic update via URL search params, you can do it in the same way (you need the store.setOptimistic), the only difference is that from the server action instead of updating the store value, you can directly use the function navigate and pass it as search param. Example of web component (like-button): import type { WebContext } from \"brisa\";\n\ntype Props = { onLike: () => void };\n\nexport default function LikeButton({ onLike }: Props, { store }: WebContext) {\n  return (\n    <button\n      onClick={() => {\n        store.setOptimistic<number>(\"like-action\", \"likes\", (v) => v + 1);\n        onLike();\n      }}\n    >\n      Like ({store.get(\"likes\")})\n    </button>\n  );\n} Example of server component: import { navigate, type RequestContext } from \"brisa\";\nimport { getUser, updateDB } from \"@/helpers\";\n\nfunction Page({}, req: RequestContext) {\n  const { store, indicate, route } = req;\n  const indicator = indicate(\"like-action\");\n  const defaultLikes = route.query.likes ? +route.query.likes : 0;\n\n  // It's needed to communicate with the client\n  store.set(\"likes\", defaultLikes);\n  store.transferToClient([\"likes\"]);\n\n  async function onLikeAction() {\n    const user = getUser(req);\n    const updatedNum = await updateDB(user);\n    // Update URL param:\n    const url = new URL(req.url);\n    url.searchParams.set(\"likes\", store.get(\"likes\") + 1);\n    navigate(url.toString());\n  }\n\n  return (\n    <like-button\n      // It's necessary to connect the indicator to the action\n      indicateLike={indicator}\n      onLike={onLikeAction}\n    />\n  );\n}",
    "titles": [
      "Server Actions",
      "Optimistic updates"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#rerenderinaction",
    "title": "rerenderInAction",
    "text": "The rerenderInAction method is used to rerender the component or the page\ninside a server action. Outside of an action, it throws an error.",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#params",
    "title": "Params:",
    "text": "type: The type of the rerender. It can be targetComponent, currentComponent or page. By default, it is currentComponent.\nmode: The type of the rerender. It can be reactivity or transition. By default, it is reactivity. rerenderInAction needs to be called outside of the try/catch block: import { rerenderInAction } from \"brisa/server\";\n\n// Inside a server action\nfunction handleEvent() {\n  try {\n    // ...\n  } catch (error) {\n    // ...\n  }\n\n  // Trigger a full-page rerender\n  rerenderInAction({ type: \"page\" });\n} See the differences between \"Action Signals\" and rerenderInAction in this documentation.",
    "titles": [
      "Server Actions",
      "rerenderInAction"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#navigate",
    "title": "navigate",
    "text": "If you would like to navigate the user to a different route after the completion of a Server Action, you can use navigate API. navigate needs to be called outside of the try/catch block: import { navigate } from \"brisa\";\n\nexport async function createPost(id: string) {\n  try {\n    // ...\n  } catch (error) {\n    // ...\n  }\n\n  navigate(`/post/${id}`); // Navigate to the new post page\n}",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#cookies",
    "title": "Cookies",
    "text": "You can access to the request inside the server action to read cookies from headers, then you can communicate via request store to the responseHeaders of the page: import type { RequestContext } from \"brisa\";\n\nexport default function Login({}, req: RequestContext) {\n  return (\n    <form\n      onSubmit={(e) => {\n        const username = e.formData.get(\"username\");\n        // Read the cookies\n        const cookies = req.headers.get(\"cookie\");\n        // Store data inside the request:\n        req.store.set(\"new-cookies\", \"foo=bar;\");\n      }}\n    >\n      {/* ... */}\n    </form>\n  );\n}\n\nexport function responseHeaders(req: RequestContext) {\n  // Read the stored data:\n  const newCookies = req.store.get(\"new-cookies\");\n\n  return {\n    \"Set-Cookie\": newCookies,\n  };\n}",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#security",
    "title": "Security",
    "text": "",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#authentication-and-authorization",
    "title": "Authentication and authorization",
    "text": "You should treat Server Actions as you would public-facing API endpoints, and ensure that the user is authorized to perform the action. For example: import { Database } from \"bun:sqlite\";\nimport type { RequestContext } from \"brisa\";\nimport { rerenderInAction} from \"brisa/server\";\nimport validateToken from \"@/auth/validate-token\";\n\nconst db = new Database(\"mydb.sqlite\");\nconst query = db.query(\"SELECT * FROM cats\");\nconst insert = db.prepare(`INSERT INTO cats (name) VALUES (?)`);\n\nexport default function CatsComponent({}, req: RequestContext) {\n  const invalidTokenError = req.store.get(\"invalidTokenError\");\n  const cats = query.all();\n\n  async function addCat(e: FormDataEvent) {\n    const cookies = getCookies(req.headers);\n    const token = cookies?.[\"X-Token\"];\n    const isTokenValid = await validateToken(token);\n\n    if (!isTokenValid) {\n      // handle invalid token\n      req.store.set(\"invalidTokenError\", \"The token is invalid\");\n      rerenderInAction({ type: \"page\" });\n    }\n\n    insert.run(e.formData.get(\"cat\") as string);\n    rerenderInAction({ type: \"page\" });\n  }\n\n  req.store.transferToClient([\"invalidTokenError\"]);\n\n  return (\n    <form onSubmit={addCat}>\n      <input name=\"cat\" type=\"text\" placeholder=\"Cat Name\" />\n      <button>Add random cat</button>\n      <ul>\n        {cats.map((cat) => (\n          <li key={cat.id}>{cat.name}</li>\n        ))}\n      </ul>\n      {invalidTokenError && <div>{invalidTokenError}</div>}\n    </form>\n  );\n}\n\n// Example of getCookies (you can also use any library):\nfunction getCookies(headers: Headers): Record<string, string> {\n  const cookie = headers.get(\"Cookie\");\n  const out: Record<string, string> = {};\n\n  if (cookie === null) return {};\n\n  for (const kv of cookie.split(\";\")) {\n    const [cookieKey, ...cookieVal] = kv.split(\"=\");\n    const key = cookieKey.trim();\n    out[key] = cookieVal.join(\"=\");\n  }\n\n  return out;\n} For more information see the Authentication documentation.",
    "titles": [
      "Server Actions",
      "Security"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#action-signals",
    "title": "Action Signals",
    "text": "From the server you can consume a store that by default has a limited lifetime and only lives on request-time. However, you can expand the lifetime of some properties of the store with the method: transferToClient. The moment you do this, not only do you expand its life in client-time, but you can then re-use it in action-time. Defining a Server Action inside a component creates a closure where the action has access to the outer function's scope. For example, the onClick action has access to the foo variable: export default function Page() {\n  const foo = \"bar\";\n\n  function onClick() {\n    if (foo === \"bar\") {\n      // ...\n    }\n  }\n\n  return <button onClick={onClick}>Click</button>;\n} However, only static variables can be reused. In Brisa for security we don't expose server variables in the client directly to then pass them back to the server action. So, if instead of the string bar it would be Math.random() it would be a different value in rendering-time than action-time. render (server) â†’ HTML (client) â†’ action (server) â†’ HTML (client) ... For these cases, you can use the action signals through the store method to improve the communication between render and action. import type { RequestContext } from \"brisa\";\nimport { RenderInitiator, rerenderInAction } from \"brisa/server\";\n\nexport default function Page(\n  {},\n  { store, method, renderInitiator }: RequestContext,\n) {\n  // set communication render-value during the initial request\n  // (not in the rerender of the server action or during SPA navigation)\n  if (renderInitiator === RenderInitiator.INITIAL_REQUEST) {\n    store.set(\"foo\", Math.random());\n    store.transferToClient([\"foo\"]);\n  }\n\n  function onClick() {\n    // get communication render-value\n    const renderFooValue = store.get(\"foo\");\n    // ..\n    // set communication action-client:\n    store.set(\"foo\", Math.random());\n    // rerender this component:\n    rerenderInAction(); \n  }\n\n  return (\n    <button onClick={onClick}>\n      {/* display \"initial render\" and \"rerender\" value */}\n      {store.get(\"foo\")}\n      <web-component />\n    </button>\n  );\n} Imagine inside the web-component you have a store property that is the same as the foo value. After the action, the web-component will react to the changes of the foo value. The Web Component is not necessary to be inside the same component, it can be in any part of the page. import type { WebContext } from \"brisa\";\n\nexport default function WebComponent({}, { store }: WebContext) {\n  return <div>{store.get(\"foo\")}</div>;\n} Only in these cases, these store properties will be exposed in the HTML. Changing the value of the action signal within the action will also reflect the change in the rendering and also, reactively, to all web components that consume the same store property. The concept is similar to the store of web components. The values of the action signals (store) must be serializable. Use unencrypted transferToClient only for NON-SENSITIVE DATA only. These values are shared through HTML. If you need sensitive data, you must use transferToClient(['foo'], { encrypt: true }); or use a database.",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#store-as-action-signal",
    "title": "Store as action signal",
    "text": "To communicate with the same store between server and client you have to use the transferToClient option. For security reasons the data of the server store are only server data and are not shared in the client store. However, for non-sensitive data you can use the transferToClient property to share the store throughout your application, communicating any server component with any web component reactively, also accessible inside server actions.",
    "titles": [
      "Server Actions",
      "Action Signals"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#server-component",
    "title": "Server component",
    "text": "src/components/server-counter.tsx import type { RequestContext } from \"brisa\";\n\nexport default function ServerCounter({}, { store }: RequestContext) {\n  store.set(\"count\", 0); // Initializes the store value on the server\n\n  // Mark \"count\" as non-sensible data and transfer to the client\n  store.transferToClient([\"count\"]); // This line is necessary\n\n  return (\n    <div>\n      <button\n        onClick={() => {\n          store.set(\"count\", store.get(\"count\") + 1);\n        }}\n      >\n        Server +\n      </button>\n      <web-counter />\n      <button\n        onClick={() => {\n          store.set(\"count\", store.get(\"count\") - 1);\n        }}\n      >\n        Server -\n      </button>\n    </div>\n  );\n}",
    "titles": [
      "Server Actions",
      "Action Signals",
      "Store as action signal"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#web-component",
    "title": "Web component",
    "text": "src/web-components/web-counter.tsx import type { WebContext } from \"brisa\";\n\nexport default function WebCounter({}, { store }: WebContext) {\n  return (\n    <div>\n      <button\n        onClick={() => {\n          store.set(\"count\", store.get(\"count\") + 1);\n        }}\n      >\n        Client +\n      </button>\n      Count value: {store.get(\"count\")}\n      <button\n        onClick={() => {\n          store.set(\"count\", store.get(\"count\") - 1);\n        }}\n      >\n        Client -\n      </button>\n    </div>\n  );\n} This example shows a counter shared between the server and the client. It can be incremented from the action (server component) or from the browser event (web component), and the store value will always be synchronized between the two.",
    "titles": [
      "Server Actions",
      "Action Signals",
      "Store as action signal"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#action-signals-vs-rerenderinaction",
    "title": "Action Signals vs rerenderInAction",
    "text": "It depends on the type of communication you want. If you want: Communicate with the web components only: You don't need to use rerenderInAction, you can use the store as action signal instead.\nCommunicate with the server components: You need to use rerenderInAction.\nCommunicate with the server components and web components: You need to use rerenderInAction and the web components will react to the changes to their attributes.",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#transfer-sensitive-data",
    "title": "Transfer sensitive data",
    "text": "If you want to transfer sensitive data from the render to use it later on the action you can use: store.transferToClient([\"some-key\"], { encrypt: true }); On the client it will always be encrypted and there will be no way to decrypt it, while on the server action you will have access with: store.get(\"some-key\"); // In the server is automatic decrypted Brisa uses aes-256-cbc for encryption, a combination of cryptographic algorithms used to securely encrypt information recommended by OpenSSL. Encryption keys are generated during the build of your project. It is important to note that encryption is a blocking process and may increase the time it takes for the request. It also exposes public data for the server action to access. Before using encrypt, consider if there is a better way to have this data from the action like querying a DB, without the need to expose it in the client.",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#props-in-server-actions",
    "title": "Props in Server Actions",
    "text": "By default the only props you can access within a server action are other server actions. This is for security reasons. In Brisa we do not want to expose server data in the client by default so that later it can be accessed from the server actions. However, you can transfer any server store property to the client allowing to use this value in the server action. Instead: export default function ServerComponent({ onAction, foo }) {\n  function onClickAction(e) {\n    onAction(e); // âœ… Server actions are allowed\n    console.log(foo.bar); // âŒ foo is undefined\n  }\n\n  return <button onClick={onClickAction}>Run action</button>;\n} Do this: export default function ServerComponent({ onAction, foo }, { store }) {\n  store.set(\"foo\", foo);\n\n  // Encrypt it or not depending on whether it is sensitive data or not.\n  store.transferToClient([\"foo\"], { encrypt: true });\n\n  function onClickAction(e) {\n    onAction(e); // âœ… Server actions are allowed\n    console.log(store.get(\"foo\").bar); // âœ…\n  }\n\n  return <button onClick={onClickAction}>Run action</button>;\n} If we do not encrypt it you can use the same field of the store in the web components and all the changes you make in the actions will react in all the web components that have the signal. Learn more in transfer sensitive data and in store.transferToClient documentation.",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#using-server-actions-in-a-reverse-proxy",
    "title": "Using Server Actions in a Reverse Proxy",
    "text": "The POST request generated by the Server Action consistently yields an HTML stream. This stream may be empty in cases of navigation or when no content is returned. However, to provide guidance to the client code on how to process this stream, the following two headers are essential:",
    "titles": [
      "Server Actions"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#request-headers",
    "title": "Request headers",
    "text": "X-Action: This header is the id of the action because the same page can have multi-actions.\nX-Actions: This header shares the action dependencies to another action.",
    "titles": [
      "Server Actions",
      "Using Server Actions in a Reverse Proxy"
    ]
  },
  {
    "id": "/building-your-application/data-management/server-actions#response-headers",
    "title": "Response headers",
    "text": "X-Mode: This header is crucial for determining whether the stream corresponds to reactivity or transition.\nX-Type: This header indicates the type of the stream, which can be component or page. This information is essential for the client to understand how to process the stream.\nX-Navigate: This header indicates that instead of observing the stream, the client should navigate to another route.\nX-Cid: This header returns the id of the component that called the rerenderInAction method with currentComponent type. This header is used internally by Brisa to determine which component should be rerendered. When it is not present, the component that fired the action is rerendered.\nX-Reset: This header is to communicate to the RPC client that the <form> should be reset after the action is executed. This header is added automatically by Brisa when the e.target.reset() on server action onSubmit is called. When utilizing a reverse proxy, it is imperative to ensure the upstream propagation of these headers for seamless communication between the client and the backend server.",
    "titles": [
      "Server Actions",
      "Using Server Actions in a Reverse Proxy"
    ]
  },
  {
    "id": "/building-your-application/deploying#deploying",
    "title": "Deploying",
    "text": "Congratulations, it's time to ship to production. In this section, you will learn how to deploy your Brisa application to production. Choose your hosting provider and follow the instructions to deploy your application.",
    "titles": []
  },
  {
    "id": "/building-your-application/deploying#static-site-app-web-service-app-with-docker",
    "title": "Static Site App / Web Service App with Docker",
    "text": "Bun runtime compatible Deploy Brisa app to Fly.io\nDeploy Brisa app to AWS\nDeploy Brisa app to Render.com",
    "titles": [
      "Deploying"
    ]
  },
  {
    "id": "/building-your-application/deploying#static-site-app-web-service-app-with-adapters",
    "title": "Static Site App / Web Service App with Adapters",
    "text": "Non-Bun runtime compatible Deploy Brisa app to Vercel\nNetlify - Coming soon\nCloudflare Pages - Coming soon",
    "titles": [
      "Deploying"
    ]
  },
  {
    "id": "/building-your-application/deploying#custom-adapters",
    "title": "Custom Adapters",
    "text": "Adapters are useful to don't write IaC code, just plug and play. In Brisa, we offer adapters for some Cloud Providers, but you can write your own and share it with the community. Writing a Custom Adapter",
    "titles": [
      "Deploying"
    ]
  },
  {
    "id": "/building-your-application/deploying#learn-more",
    "title": "Learn more",
    "text": "Docker - Learn how to containerize a Brisa application with Docker.",
    "titles": [
      "Deploying"
    ]
  },
  {
    "id": "/building-your-application/deploying/aws#deploying-on-aws",
    "title": "Deploying on AWS",
    "text": "This documentation outlines the process of deploying a Brisa application on AWS. AWS is a cloud service provider that offers a wide range of services, including hosting, storage, and databases. Depending on your output strategy, you can deploy your Brisa application on AWS using different approaches: Static exports (output=\"static\"): You can deploy your Brisa application as a static website on Amazon S3 or Amazon CloudFront.\nDocker containers (output=\"bun\" | output=\"node\"): You can containerize your Brisa application using Docker and deploy it on Amazon Elastic Container Service (ECS). This approach is recommended for applications that require server-side logic or API endpoints.",
    "titles": []
  },
  {
    "id": "/building-your-application/deploying/aws#deploying-as-a-static-website",
    "title": "Deploying as a static website",
    "text": "To deploy a Brisa application as a static website on AWS, you can use Amazon S3 to host your static assets and Amazon CloudFront to serve your content globally with low latency. For static site, you need to modify the brisa.config.ts file as follows: import type { Configuration } from \"brisa\";\n\nexport default {\n  output: \"static\",\n} satisfies Configuration; Here are the steps to deploy your Brisa application as a static website on AWS: Create an S3 bucket: Create an S3 bucket to store your static assets. You can create an S3 bucket using the AWS Management Console or the AWS CLI.\nUpload your static assets: Upload the contents of the out folder to your S3 bucket. You can use the AWS Management Console, the AWS CLI, or an S3 client to upload your static assets. Once you have uploaded your static assets to your S3 bucket, you can configure Amazon CloudFront to serve your content globally with low latency. You can create a CloudFront distribution that points to your S3 bucket and configure it to cache your content at edge locations around the world.",
    "titles": [
      "Deploying on AWS"
    ]
  },
  {
    "id": "/building-your-application/deploying/aws#deploying-with-docker-containers",
    "title": "Deploying with Docker containers",
    "text": "To deploy a Brisa application on AWS, you can use Docker to containerize your application and deploy it on AWS Elastic Container Service (ECS). ECS is a fully managed container orchestration service that allows you to run and scale containerized applications on AWS.",
    "titles": [
      "Deploying on AWS"
    ]
  },
  {
    "id": "/building-your-application/deploying/aws#prerequisites",
    "title": "Prerequisites",
    "text": "Before deploying your Brisa application on AWS, you need to have the following prerequisites: AWS account: You need to have an AWS account to use AWS services.\nDocker: You need to have Docker installed on your local machine to containerize your application.\nAWS CLI: You need to have the AWS Command Line Interface (CLI) installed on your local machine to interact with AWS services.",
    "titles": [
      "Deploying on AWS",
      "Deploying with Docker containers"
    ]
  },
  {
    "id": "/building-your-application/deploying/aws#containerize-your-brisa-application",
    "title": "Containerize your Brisa application",
    "text": "To deploy your Brisa application on AWS, you need to containerize your application using Docker. You can follow the Containerize with Docker guide to create a Dockerfile for your Brisa application.",
    "titles": [
      "Deploying on AWS",
      "Deploying with Docker containers"
    ]
  },
  {
    "id": "/building-your-application/deploying/aws#deploy-on-aws-ecs",
    "title": "Deploy on AWS ECS",
    "text": "Once you have containerized your Brisa application, you can deploy it on AWS ECS. Here are the steps to deploy your application on AWS ECS: Create an ECS cluster: You need to create an ECS cluster to run your containerized application. You can create an ECS cluster using the AWS Management Console or the AWS CLI.\nCreate an ECS task definition: You need to create an ECS task definition that defines how your containerized application should run. You can create an ECS task definition using the AWS Management Console or the AWS CLI.\nCreate an ECS service: You need to create an ECS service that runs your containerized application as tasks in the ECS cluster. You can create an ECS service using the AWS Management Console or the AWS CLI.\nDeploy your application: Once you have created the ECS cluster, task definition, and service, you can deploy your containerized Brisa application on AWS ECS. By following these steps, you can deploy your Brisa application on AWS using Docker containers and AWS ECS. This approach is recommended for applications that require server-side logic or API endpoints.",
    "titles": [
      "Deploying on AWS",
      "Deploying with Docker containers"
    ]
  },
  {
    "id": "/building-your-application/deploying/aws#uploading-assets-images-files-etc-to-s3",
    "title": "Uploading assets (images, files, etc.) to S3",
    "text": "When deploying your Brisa application on AWS, you may need to upload assets such as images, files, or other resources to your S3 bucket. You can use the AWS Management Console, the AWS CLI, or an S3 client to upload assets to your S3 bucket. To upload assets to your S3 bucket, you can follow these steps: Create an S3 bucket: Create an S3 bucket to store your assets. You can create an S3 bucket using the AWS Management Console or the AWS CLI.\nUpload assets: Upload your assets to the S3 bucket using the AWS Management Console, the AWS CLI, or an S3 client.\nConfigure assets from CDN: You need to modify the brisa.config.ts to add an assetPrefix, pointing to the CDN URL of your S3 bucket. This ensures that your Brisa application loads assets from the CDN.",
    "titles": [
      "Deploying on AWS",
      "Deploying with Docker containers"
    ]
  },
  {
    "id": "/building-your-application/deploying/docker#docker",
    "title": "Docker",
    "text": "",
    "titles": []
  },
  {
    "id": "/building-your-application/deploying/docker#containerize-with-docker",
    "title": "Containerize with Docker",
    "text": "This guide assumes you already have Docker Desktop installed. Docker is a platform for packaging and running an application as a lightweight, portable container that encapsulates all the necessary dependencies. To containerize our application, we define a Dockerfile. This file contains a list of instructions to initialize the container, copy our local project files into it, install dependencies, and start the application. # Adjust BUN_VERSION as desired\nARG BUN_VERSION=1.1.28\nFROM oven/bun:${BUN_VERSION}-slim AS base\n\n# Brisa app lives here\nWORKDIR /app\n\n# Set production environment\nENV NODE_ENV=\"production\"\n\n# Throw-away build stage to reduce the size of the final image\nFROM base AS build\n\n# Install node modules\nCOPY --link bun.lockb package.json ./\nRUN bun install --ci\n\n# Copy Brisa application code\nCOPY --link . .\n\n# Build Brisa application\nRUN bun run build\n\n# Final stage for app image\nFROM base\n\n# Copy built Brisa application\nCOPY --from=build /app /app\n\n# Start the Brisa server on port 3000\nEXPOSE 3000\nCMD [ \"bun\", \"run\", \"start\" ] Now that you have your docker image, let's look at .dockerignore which has the same syntax as .gitignore; here, you need to specify the files/directories that must not go in any stage of the docker build. An example of a ignore file is: dockerignore: .vscode\nnode_modules\n.DS_Store\nbuild If you want to be more strict, you can also invert the .dockerignore and use it as an allowed file. An example of how this would work is: dockerignore: # Ignore all files from your repo\n*\n\n# Allow specific files or folders\n!bun.lockb\n!package.json\n!src Making the .dockerignore an allowed file becomes very handy to prevent trash on your image, or sensitive information. For example secrets, coverage files or another dev on your team using a different IDE. We'll now use docker build to convert this Dockerfile into a Docker image. The result will be a self-contained template containing all the dependencies and configurations required to run the application on any platform. docker build -t my-app . The -t flag lets us specify a name for the image. We've built a new Docker image. Now let's use that image to spin up an actual, running container. docker run -p 3000:3000 my-app We'll use docker run to start a new container using the my-app image. We'll map the container's port 3000 to our local machine's port 3000 (-p 3000:3000). The run command prints a string representing the container ID. The container is now running in the background. Visit localhost:3000. You should see your homepage. Optional: the flag -d flag to run in detached mode to run the container in the background. To stop the container, we'll use docker stop <container-id>. If you can't find the container ID, you can use docker ps to list all running containers. That's it! Refer to the Docker documentation for more advanced usage.",
    "titles": [
      "Docker"
    ]
  },
  {
    "id": "/building-your-application/deploying/docker#containerize-monorepo-with-docker-turborepo",
    "title": "Containerize Monorepo with Docker + Turborepo",
    "text": "Next, it will be an extension of the above. Let's start with an example of a monorepo Dockerfile: ARG BUN_VERSION=1.1.20\nFROM oven/bun:${BUN_VERSION}-slim AS base\nWORKDIR /app\n\n# Run a Docker container as root is not a good idea, so let's prepare for using a non privileged user.\nENV USERNAME=bun\nENV USER_GROUP=bun\n\n# We can take advantage of updating the base image.\nRUN apt-get -y update\n\nFROM base AS prepare\n\nCOPY --link . .\n\n# We will be assuming that your app inside the monorepo is called @example/brisa-app\nRUN bun --filter='@example/brisa-app' install --frozen-lockfile --production\nRUN bun run build --filter @example/brisa-app\n\n# copy production dependencies and source code into the final image\nFROM base\n\nCOPY --link . .\n\n# Copy node_modules\nCOPY --from=prepare /app/node_modules node_modules\n\n# Copy the built folder\nCOPY --from=prepare /app/apps/brisa-app/build apps/brisa-app/build\n\n# Giving to the copied files proper execution permissions\nRUN chown ${USERNAME}:${USER_GROUP} -R .\n\nENV NODE_ENV=production\n\n# run the app\nEXPOSE 3000/tcp\n\n# Running a non-root container\nUSER ${USERNAME}:${USER_GROUP}\nENTRYPOINT [ \"bun\", \"run\", \"start\", \"--filter\", \"@example/brisa-app\" ] Simply copying and pasting does not work as expected. Working with monorepos requires more initial setup time compared to a single repository. It is necessary to configure tools like Turborepo to ensure proper functionality. Check the Turborepo documentation for more information. We'll need to install Turborepo in the root of the project. Alternatively, you can install it globally, although we do not recommend this approach. Installing tools globally can lead to version conflicts within your team, which can be time-consuming to resolve. (This often results in the familiar refrain, \"It works on my machine!\" ðŸ˜Ž). In our documentation, we use Turborepo as an example, but there are other options available for managing monorepos. package.json: // ...\n\"dependencies\": {\n \"turbo\": \"2.0.7\"\n},\n// ... Also, we will have to add a turbo.json file for telling Turborepo what commands it needs to listen to. turbo.json: {\n  \"$schema\": \"https://turbo.build/schema.json\",\n  \"tasks\": {\n    \"build\": {},\n    \"start\": {}\n  }\n} Finally, amend the .dockerfile to make sure it adds the new necessary files. .dockerfile: *\n\n# ROOT\n!turbo.json\n!bun.lockb\n!package.json\n\n# APPS\n## Example\n!apps/example/package.json\n!apps/example/turbo.json\n!apps/example/tsconfig.json\n!apps/example/bunfig.toml # Optional, only if you run tests on the Dockerfile\n!apps/example/brisa.config.ts\n!apps/example/src/* We've summarized an example of running Brisa on Dockerfile if you are using a monorepo with Turborepo.",
    "titles": [
      "Docker"
    ]
  },
  {
    "id": "/building-your-application/deploying/docker#advanced-topics",
    "title": "Advanced topics",
    "text": "",
    "titles": [
      "Docker"
    ]
  },
  {
    "id": "/building-your-application/deploying/docker#my-docker-image-is-too-big",
    "title": "My docker image is too big",
    "text": "At Brisa, we love to optimize. In the previous Dockerfiles, we copied all node_modules, but most of the dependencies are already on the bundle, and we don't need it anymore. Let us give you a Dockerfile example with more optimizations on the Dockerfile. Dockerfile: ARG BUN_VERSION=1.1.20\nFROM oven/bun:${BUN_VERSION}-slim AS base\nWORKDIR /app\n\n# Run a Docker container as root is not a good idea, so let's prepare for using a non privileged user.\nENV USERNAME=bun\nENV USER_GROUP=bun\n\n# We can take advantage of updating the base image.\nRUN apt-get -y update\n\nFROM base AS prepare\n\nCOPY --link . .\n\n# We will be assuming that your app inside the monorepo is called @example/brisa-app\nRUN bun --filter='@example/brisa-app' install --frozen-lockfile --production\nRUN bun run build --filter @example/brisa-app\n\n# copy production dependencies and source code into the final image\nFROM base\n\nCOPY --link . .\n\n# Copy node_modules - DO NOT COPY THE WHOLE FOLDER; IT COULD BE HUGE !!!!\n# COPY --from=prepare /app/node_modules node_modules\n\n# Instead, copy only what you really need. In brisa, you will need to copy anything imported on brisa.config.ts and turbo in a monorepo scenario.\n# Turbo\nCOPY --from=prepare /app/node_modules/.bin/turbo node_modules/.bin/turbo\nCOPY --from=prepare /app/node_modules/turbo node_modules/turbo\n# This binary will change depending on the OS you are running your app.\nCOPY --from=prepare /app/node_modules/turbo-linux-64 node_modules/turbo-linux-64\n\n# Brisa\nCOPY --from=prepare /app/node_modules/.bin/brisa node_modules/.bin/brisa\nCOPY --from=prepare /app/node_modules/brisa node_modules/brisa\n\n# Other libs imported on brisa.config.ts, if you are using other libs, there is no need to add any other lib.\n\n# Copy the built folder\nCOPY --from=prepare /app/apps/brisa-app/build apps/brisa-app/build\n\n# Giving to the copied files proper execution permissions\nRUN chown ${USERNAME}:${USER_GROUP} -R .\n\nENV NODE_ENV=production\n\n# run the app\nEXPOSE 3000/tcp\n\n# Running a non-root container\nUSER ${USERNAME}:${USER_GROUP}\nENTRYPOINT [ \"bun\", \"run\", \"start\", \"--filter\", \"@example/brisa-app\" ] That's all for now. Feel free to reach out or ask more questions on Brisa's Discord.",
    "titles": [
      "Docker",
      "Advanced topics"
    ]
  },
  {
    "id": "/building-your-application/deploying/fly-io#deploying-to-flyio",
    "title": "Deploying to Fly.io",
    "text": "Fly.io is the fastest way to deploy straight from your source code. Youâ€™ll be up and running in just minutes.",
    "titles": []
  },
  {
    "id": "/building-your-application/deploying/fly-io#requeriments",
    "title": "Requeriments",
    "text": "Follow this docs to install flyctl: https://fly.io/docs/hands-on/install-flyctl/ Then, login with: flyctl auth login",
    "titles": [
      "Deploying to Fly.io"
    ]
  },
  {
    "id": "/building-your-application/deploying/fly-io#deploy-your-application",
    "title": "Deploy your application",
    "text": "Deploying your Brisa app is done with the following command: fly launch --now That's all ðŸ¥³. After executing this command you will have access to the URL of your Brisa app. It is not necessary to configure any additional settings like an outputAdapter, as Fly.io is compatible with Brisa's default output.",
    "titles": [
      "Deploying to Fly.io"
    ]
  },
  {
    "id": "/building-your-application/deploying/render-com#deploying-on-rendercom",
    "title": "Deploying on Render.com",
    "text": "This documentation outlines the process of deploying a Brisa application on Render.com. Render is a cloud service provider that offers uploaddable static sites and a web service with docker containers. Depending on your output strategy, you can deploy your Brisa application on Render.com using different approaches: Static Sites (output=\"static\"): You can deploy your Brisa application as a static website on Render.com.\nWeb Services (output=\"bun\" | output=\"node\"): You can containerize your Brisa application using Docker and deploy it on Render.com.",
    "titles": []
  },
  {
    "id": "/building-your-application/deploying/render-com#deploying-as-a-static-website",
    "title": "Deploying as a Static Website",
    "text": "To deploy a Brisa application as a static website on Render.com, you can use the Static Sites feature to host your static assets. For static site, you need to modify the brisa.config.ts file as follows: import type { Configuration } from \"brisa\";\n\nexport default {\n  output: \"static\",\n} satisfies Configuration; Here are the steps to deploy your Brisa application as a static website on Render.com: Create a new Static Site: Create a new static site inside Render.com Dashboard\nConnect your GitHub repository: Connect your GitHub repository to the Static Site.\nModify Build Command and the Publish directory: Set the build command to bun run build and the publish directory to out or the directory where your static assets are located.\nSet BUN_VERSION environment variable: Set the BUN_VERSION environment variable to the Bun version that you are using in your Brisa application. You can check the Bun version by running bun --version in your terminal. After these steps, Render will automatically build your static site and deploy it to the static site. You can access your Brisa application by visiting the URL provided by Render.",
    "titles": [
      "Deploying on Render.com"
    ]
  },
  {
    "id": "/building-your-application/deploying/render-com#deploying-as-a-web-service",
    "title": "Deploying as a Web Service",
    "text": "To deploy a Brisa application as a web service on Render.com, you can use Docker to containerize your application and deploy it on Render.com. We recommend reading the Docker documentation to understand how to containerize your Brisa application. Once you have your Dockerfile, you need to: Create a new Web Service: Create a new web service inside Render.com Dashboard\nConnect your GitHub repository: Connect your GitHub repository to the Web Service, It will probably detect that you have a DockerFile and you will get Docker already selected, otherwise select Docker. After these steps, Render will automatically build your Docker container and deploy it to the web service. You can access your Brisa application by visiting the URL provided by Render.",
    "titles": [
      "Deploying on Render.com"
    ]
  },
  {
    "id": "/building-your-application/deploying/vercel#vercel",
    "title": "Vercel",
    "text": "To deploy to Vercel, use adapter-vercel. To deploy to Vercel, the following outputs are supported for now: node and static.",
    "titles": []
  },
  {
    "id": "/building-your-application/deploying/vercel#usage",
    "title": "Usage",
    "text": "Install with: bun install -D brisa-adapter-vercel Then, add the adapter to your brisa.config.ts: /// file: brisa.config.ts\nimport vercel from 'brisa-adapter-vercel';\n\nexport default {\n  output: 'node', // or 'static'\n  outputAdapter: vercel({\n    // see below for options that can be set here\n  })\n}; If you select node as the output, the runtime on Vercel will always be the latest LTS of Node.js. Brisa is only compatible with Node.js version 20.x and later.",
    "titles": [
      "Vercel"
    ]
  },
  {
    "id": "/building-your-application/deploying/vercel#deployment-configuration",
    "title": "Deployment configuration",
    "text": "The vercel adapter accepts an object with the following properties: regions: an array of edge network regions defaulting to [\"iad1\"]. Note that multiple regions for serverless functions are only supported on Enterprise plans.\nmemory: the amount of memory available to the function. Defaults to 1024 Mb, and can be decreased to 128 Mb or increased in 64Mb increments up to 3008 Mb on Pro or Enterprise accounts.\nmaxDuration: maximum execution duration of the function. Defaults to 10 seconds for Hobby accounts, 15 for Pro and 900 for Enterprise. If your pages need to access data in a specific region, it's recommended that they be deployed in the same region (or close to it) for optimal performance.",
    "titles": [
      "Vercel"
    ]
  },
  {
    "id": "/building-your-application/deploying/vercel#environment-variables",
    "title": "Environment variables",
    "text": "Vercel makes a set of deployment-specific environment variables available. Like other environment variables, these are accessible from process.env.",
    "titles": [
      "Vercel"
    ]
  },
  {
    "id": "/building-your-application/deploying/vercel#skew-protection",
    "title": "Skew protection",
    "text": "Skew protection is a Vercel feature that routes client requests to their original deployment. When a user visits your app, a cookie is set with the deployment ID, and any subsequent requests will be routed to that deployment for as long as skew protection is active. When they reload the page, they will get the newest deployment.",
    "titles": [
      "Vercel"
    ]
  },
  {
    "id": "/building-your-application/deploying/writing-a-custom-adapter#writing-a-custom-adapter",
    "title": "Writing a custom adapter",
    "text": "Adapters are useful to don't write IaC code, just plug and play. In Brisa, we offer adapters for some Cloud Providers, but you can write your own and share it with the community. If an adapter for your preferred environment doesn't yet exist, you can build your own. We recommend looking at the source for an adapter to a platform similar to yours and copying it as a starting point. Feel free to contribute your adapter to the Brisa community by opening a pull request in the Brisa repository. Adapter packages implement the following API, which creates an Adapter: import type {Â Adapter } from 'brisa';\n\nexport default function yourAdapter(options) {\n\tconst adapter = {\n\t\tname: 'adapter-package-name',\n\t\tasync adapt({ BUILD_DIR, ROOT_DIR, CONFIG }, prerenderedRoutes) {\n\t\t\t// adapter implementation\n\t\t},\n\t} satisfies Adapter;\n\n\treturn adapter;\n} Both, name and adapt are required. export type Adapter = {\n  /**\n   * The name of the adapter.\n   */\n  name: string;\n  /**\n   * This function is called after Brisa has built your app.\n   */\n  adapt(\n    brisaConstants: BrisaConstants,\n    prerenderedRoutes?: Map<string, string[]>,\n  ): void | Promise<void>;\n};",
    "titles": []
  },
  {
    "id": "/building-your-application/deploying/writing-a-custom-adapter#name",
    "title": "name",
    "text": "The name field is a string that represents the name of the adapter.",
    "titles": [
      "Writing a custom adapter"
    ]
  },
  {
    "id": "/building-your-application/deploying/writing-a-custom-adapter#adapt",
    "title": "adapt",
    "text": "The adapt function is going to be called after Brisa has built your app in production mode. Adapter type is:",
    "titles": [
      "Writing a custom adapter"
    ]
  },
  {
    "id": "/building-your-application/deploying/writing-a-custom-adapter#parameters-of-adapt",
    "title": "Parameters of adapt",
    "text": "The adapt receives the following parameters: The brisaConstants parameter is an object that contains all the constants used by Brisa and the output adapter. It contains information about the build, the environment, the configuration, and more.\nThe prerenderedRoutes parameter is a map of routes to prerendered HTML files. In the case of a static export, this map will contain all the prerendered routes. In the case of a server output, this map will be filled with the prerendered routes, saved in the BUILD_DIR directory, under the prerendered-pages folder. And BrisaConstants type is: /**\n * Internal types used by Brisa and output adapters.\n */\nexport type BrisaConstants = {\n  PAGE_404: string;\n  PAGE_500: string;\n  VERSION: string;\n  VERSION_HASH: ReturnType<typeof Bun.hash>;\n  WEB_CONTEXT_PLUGINS: string[];\n  RESERVED_PAGES: string[];\n  IS_PRODUCTION: boolean;\n  IS_DEVELOPMENT: boolean;\n  IS_SERVE_PROCESS: boolean;\n  PORT: number;\n  BUILD_DIR: string;\n  ROOT_DIR: string;\n  SRC_DIR: string;\n  ASSETS_DIR: string;\n  PAGES_DIR: string;\n  I18N_CONFIG: I18nConfig;\n  LOG_PREFIX: {\n    WAIT: string;\n    READY: string;\n    INFO: string;\n    ERROR: string;\n    WARN: string;\n    TICK: string;\n  };\n  LOCALES_SET: Set<string>;\n  CONFIG: Configuration;\n  IS_STATIC_EXPORT: boolean;\n  REGEX: Record<string, RegExp>;\n  HEADERS: {\n    CACHE_CONTROL: string;\n  };\n};",
    "titles": [
      "Writing a custom adapter",
      "adapt"
    ]
  },
  {
    "id": "/building-your-application/deploying/writing-a-custom-adapter#return-value-of-adapt",
    "title": "Return value of adapt",
    "text": "The adapt function can return a Promise<void> or void. If the function returns a promise, Brisa will wait for the promise to resolve before continuing.",
    "titles": [
      "Writing a custom adapter",
      "adapt"
    ]
  },
  {
    "id": "/building-your-application/integrations/mdx#integrating-mdx",
    "title": "Integrating MDX",
    "text": "MDX is a popular format that allows you to write JSX in Markdown files. This integration enables you to use Brisa JSX components, directly in your Markdown files. When you integrate MDX into your Brisa project, you can create dynamic content with ease.",
    "titles": []
  },
  {
    "id": "/building-your-application/integrations/mdx#setup",
    "title": "Setup",
    "text": "To integrate MDX into your Brisa project, follow these steps: bunx brisa add mdx This command installs the necessary dependencies and configures your project to support MDX.",
    "titles": [
      "Integrating MDX"
    ]
  },
  {
    "id": "/building-your-application/integrations/mdx#usage",
    "title": "Usage",
    "text": "After you have integrated MDX into your Brisa project, you can start using it in your Markdown files. For example, you can create a src/pages/example.mdx file with the following content: import { Button } from \"@/components/Button\";\n\n# Example\n\nThis is an example of using MDX in Brisa.\n\n<Button>Click me</Button>\n<button-web-component>Click me</button-web-component> In this example, the Button component is imported from the @/components/Button module, and the button-web-component is a web component that is integrated into the project.",
    "titles": [
      "Integrating MDX"
    ]
  },
  {
    "id": "/building-your-application/integrations/tailwind-css#integrating-tailwind-css",
    "title": "Integrating Tailwind CSS",
    "text": "Brisa, offers versatile integration with third-party libraries like TailwindCSS to be automatically handled for the Brisa internals. Tailwind lets you use utility classes instead of writing CSS. These utility classes are mostly one-to-one with a certain CSS property setting: for example, adding the text-lg to an element is equivalent to setting font-size: 1.125rem in CSS. You might find it easier to write and maintain your styles using these predefined utility classes!",
    "titles": []
  },
  {
    "id": "/building-your-application/integrations/tailwind-css#installation",
    "title": "Installation",
    "text": "Run this command to integrate TailwindCSS in your Brisa project: brisa add tailwindcss And you are ready to use TailwindCSS in your Brisa project.",
    "titles": [
      "Integrating Tailwind CSS"
    ]
  },
  {
    "id": "/building-your-application/integrations/tailwind-css#manual-installation",
    "title": "Manual Installation",
    "text": "If you want to install TailwindCSS manually, you can do it by running: npm install tailwindcss postcss brisa-tailwindcss And then, you can add the integration in your brisa.config.ts file: brisa.config.ts import brisaTailwindCSS from \"brisa-tailwindcss\";\n\nexport default {\n  integrations: [brisaTailwindCSS()],\n} satisfies Configuration; And you are ready to use TailwindCSS in your Brisa project. Installing the dependencies manually, take care to use a TailwindCSS version v.4.x.",
    "titles": [
      "Integrating Tailwind CSS"
    ]
  },
  {
    "id": "/building-your-application/integrations/tailwind-css#defaults",
    "title": "Defaults",
    "text": "If you don't have any .css file with @tailwind directive or tailwindcss import, Brisa will automatically generate in build-time a default CSS file with TailwindCSS directives to be similar than TailwindCSS CDN: @tailwind base;\n@tailwind components;\n@tailwind utilities;\n@import 'tailwindcss/preflight';\n@import 'tailwindcss/theme'; In the case you want to override the default CSS file, you can create a .css file in your src with @tailwind directives or @import 'tailwindcss/... and Brisa will use it instead of the default one. This .css file you need to import it in your src/layout.ts file.",
    "titles": [
      "Integrating Tailwind CSS"
    ]
  },
  {
    "id": "/building-your-application/integrations/tailwind-css#usage",
    "title": "Usage",
    "text": "You can use TailwindCSS classes in your Brisa project as you would in a regular TSX file: export default function Home() {\n  return (\n    <div className=\"bg-gray-100\">\n      <h1 className=\"text-2xl font-bold text-gray-800\">Hello, world!</h1>\n    </div>\n  );\n}",
    "titles": [
      "Integrating Tailwind CSS"
    ]
  },
  {
    "id": "/building-your-application/integrations/tauri#integrating-tauri",
    "title": "Integrating Tauri",
    "text": "Tauri is integrated into Brisa when you change the config.output inside brisa.config.ts to one of the following values: desktop - for desktop applications\nios - for iOS applications\nandroid - for Android applications Example of a brisa.config.ts file with Tauri integration: import type { Configuration } from \"brisa\";\n\nexport default {\n  output: \"desktop\",\n} as Configuration; Thanks to Tauri, you can switch from a web application to a desktop, iOS, or Android application with minimal changes to your codebase. This integration allows you to leverage the full power of Tauri's capabilities while maintaining the Brisa development experience you are familiar with.",
    "titles": []
  },
  {
    "id": "/building-your-application/routing/api-routes#api-routes",
    "title": "API Routes",
    "text": "API routes provide a solution to build a public API with Brisa. Any file inside the folder src/api is mapped to /api/* and will be treated as an API endpoint. They are server-side only bundles and won't increase your client-side bundle size. You can export any uppercase request method: GET, POST, PATCH, PUT, DELETE, etc. For example, the following API GET endpoint returns a JSON response with a status code of 200: import { type RequestContext } from \"brisa\";\n\nexport function GET(request: RequestContext) {\n  const responseData = JSON.stringify({\n    message: \"Hello world from Brisa!\",\n  });\n\n  const responseOptions = {\n    headers: { \"content-type\": \"application/json\" },\n  };\n\n  return new Response(responseData, responseOptions);\n}",
    "titles": []
  },
  {
    "id": "/building-your-application/routing/api-routes#query-and-parameters",
    "title": "Query and parameters",
    "text": "If we want for example to use a dynamic route for users and know which username it is: /api/user/aralroca?id=3 â†’ src/api/user/[username].ts We have access to the route through the RequestContext and we can access both the parameters and the query. import { type RequestContext } from \"brisa\";\n\nexport function GET({ route: { query, params } }: RequestContext) {\n  const { id } = params;\n  return new Response(`Hello world ${query.username} with id=${id}!`);\n}",
    "titles": [
      "API Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/api-routes#request-params",
    "title": "Request params",
    "text": "The request that arrives is an extension of the native Request, where apart from having everything that the request has, it has extra information of the request, such as the i18n, the route and more. If you want to know more take a look at request context.",
    "titles": [
      "API Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/api-routes#request-body",
    "title": "Request Body",
    "text": "You can read the Request body using the standard Web API methods: //src/api/items/route.ts\nexport async function POST(request: RequestContext) {\n  const res = await request.json();\n  return new Response(JSON.stringify({ res }));\n}\n\n\n\n//src/api/items/route.js\nexport async function POST(request) {\n  const res = await request.json();\n  return new Response(JSON.stringify({ res }));\n}",
    "titles": [
      "API Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/api-routes#request-body-formdata",
    "title": "Request Body FormData",
    "text": "You can read the FormData using the standard Web API methods: //src/api/items/route.ts\nexport async function POST(request: RequestContext) {\n  const formData = await request.formData();\n  const name = formData.get(\"name\");\n  const email = formData.get(\"email\");\n  return new Response(JSON.stringify({ name, email }));\n}\n\n\n\n//src/api/items/route.js\nexport async function POST(request) {\n  const formData = await request.formData();\n  const name = formData.get(\"name\");\n  const email = formData.get(\"email\");\n  return new Response(JSON.stringify({ name, email }));\n} Since formData data are all strings, you may want to use zod-form-data to validate the request and retrieve data in the format you prefer (e.g. number).",
    "titles": [
      "API Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/api-routes#response",
    "title": "Response",
    "text": "The Response is the native one, so you can find out here how it works.",
    "titles": [
      "API Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/api-routes#consume-i18n-translations-in-your-api",
    "title": "Consume i18n translations in your API",
    "text": "Like pages, through the request context you can consume translations depending on the locale. Example: /es/api/user/aralroca?id=3 â†’ src/api/user/[username].ts import { type RequestContext } from \"brisa\";\n\nexport function GET({ i18n, route: { query, params } }: RequestContext) {\n  const { id } = params;\n  return new Response(i18n.t(\"hello\", { name: params.username, id }));\n} And this inside src/i18n/index.ts or src/i18n.ts file: export default {\n  locales: [\"en\", \"es\"],\n  defaultLocale: \"en\",\n  messages: {\n    en: {\n      hello: \"Hello {{name}} with id={{id}}!\",\n    },\n    es: {\n      hello: \"Â¡Hola {{name}} con id={{id}}!\",\n    },\n  },\n};",
    "titles": [
      "API Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/api-routes#dynamic-routes-catch-all-and-optional-catch-all-routes",
    "title": "Dynamic routes, catch all and optional catch all routes",
    "text": "API Routes support dynamic routes, and follow the same file naming rules used for pages/. /api/post/a?id=3 â†’ src/api/user/[slug].ts It can be extended to catch all paths by adding three dots (...) inside the brackets. For example: /api/post/a â†’ pages/api/post/[...slug].js\n/api/post/a/b â†’ pages/api/post/[...slug].js\n/api/post/a/b/c and so on. â†’ pages/api/post/[...slug].js Catch all routes can be made optional by including the parameter in double brackets ([[...slug]]). /api/post â†’ pages/api/post/[[...slug]].js\n/api/post/a â†’ pages/api/post/[[...slug]].js\n/api/post/a/b, and so on. â†’ pages/api/post/[[...slug]].js Good to know: You can use names other than slug, such as: [[...param]]",
    "titles": [
      "API Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/api-routes#cors",
    "title": "CORS",
    "text": "You can set CORS headers on a Response using the standard Web API methods: import { type RequestContext } from \"brisa\";\n\nexport async function GET(request: RequestContext) {\n  return new Response(\"Hello, Brisa!\", {\n    status: 200,\n    headers: {\n      \"Access-Control-Allow-Origin\": \"*\",\n      \"Access-Control-Allow-Methods\": \"GET, POST, PUT, DELETE, OPTIONS\",\n      \"Access-Control-Allow-Headers\": \"Content-Type, Authorization\",\n    },\n  });\n}",
    "titles": [
      "API Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/api-routes#redirects-to-a-specified-path-or-url",
    "title": "Redirects to a specified path or URL",
    "text": "Taking a form as an example, you may want to redirect your client to a specified path or URL once they have submitted the form. The following example redirects the client to the / path if the form is successfully submitted: import { type RequestContext } from \"brisa\";\n\nexport async function POST(req: RequestContext) {\n  const { name, message }  = await req.json()\n\n  try {\n    await handleFormInputAsync({ name, message })\n    return new Response(\"\", {\n      status: 307,\n      headers: {\n        Location: \"/\",\n      },\n    })\n  } catch (err) {\n    return new Response(\"Failed to fetch data\", { status: 500 })\n  }",
    "titles": [
      "API Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/api-routes#cache-control",
    "title": "Cache-Control",
    "text": "You can add the Cache-Control headers to the response. By default is not using any cache. export async function GET() {\n  const data = await getSomeData();\n  const res = new Response(JSON.stringify(data));\n\n  res.headers.set(\"Cache-Control\", \"max-age=86400\");\n\n  return res;\n}",
    "titles": [
      "API Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/api-routes#headers-and-cookies",
    "title": "Headers and Cookies",
    "text": "You can read headers and cookies from the Request and write headers and cookies to the Response using Web APIs. Example reading/writing cookies: import { type RequestContext } from \"brisa\";\n\nexport async function GET(request: RequestContext) {\n  const cookies = request.headers.get(\"cookie\");\n  const res = new Response(\"Hello, Brisa!\");\n\n  if (cookies) {\n    res.headers.set(\"set-cookie\", cookies);\n  }\n\n  return res;\n}",
    "titles": [
      "API Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/api-routes#streaming",
    "title": "Streaming",
    "text": "You can use the Web APIs to create a stream and then return it inside the Response: export async function GET() {\n  const stream = new ReadableStream({\n    start(controller) {\n      controller.enqueue(\"Hello\");\n      controller.enqueue(\" \");\n      controller.enqueue(\"Brisa!\");\n      controller.close();\n    },\n  });\n\n  return new Response(stream); // Hello Brisa!\n}",
    "titles": [
      "API Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/api-routes#webhooks",
    "title": "Webhooks",
    "text": "Webhooks are useful for receiving real-time notifications or events from external services or systems. These notifications are typically triggered by specific events and are sent as HTTP POST requests to a predefined URL endpoint in your Brisa application. import { type RequestContext } from \"brisa\";\n\nexport async function POST(req: RequestContext) {\n  const { event, eventData } = await req.json()\n\n  try {\n    // Perform actions based on the event and data received\n    return new Response(\"Webhook received and processed successfully\", { status: 200 });\n  } catch (err) {\n    return new Response(\"Error processing webhook\", { status: 500 });\n  }",
    "titles": [
      "API Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/api-routes#security-considerations",
    "title": "Security Considerations",
    "text": "When implementing webhook endpoints, it's essential to consider security measures to prevent unauthorized access or tampering with the webhook requests. Some best practices include: Authentication: Verify the authenticity of incoming webhook requests using authentication mechanisms such as API keys, tokens, or signatures.\nValidation: Validate the incoming webhook payload to ensure that it meets expected format and data integrity requirements.\nRate Limiting: Implement rate limiting to prevent abuse or excessive usage of webhook endpoints. By implementing these security measures, you can ensure the reliability and integrity of your webhook-based integrations in Brisa.",
    "titles": [
      "API Routes",
      "Webhooks"
    ]
  },
  {
    "id": "/building-your-application/routing/custom-error#custom-errors",
    "title": "Custom Errors",
    "text": "",
    "titles": []
  },
  {
    "id": "/building-your-application/routing/custom-error#404-page",
    "title": "404 Page",
    "text": "To create a custom 404 page you can create a src/pages/_404.js file. export default function Custom404() {\n  return <h1>404 - Page Not Found</h1>;\n} This page will be displayed when the user tries to access a page that does not exist. In this page you can access to the request context, fetch data, change the head content (meta tags, etc), and change the response headers, in the same way of the rest of pages.",
    "titles": [
      "Custom Errors"
    ]
  },
  {
    "id": "/building-your-application/routing/custom-error#notfound-function",
    "title": "notFound function",
    "text": "The notFound function allows you to render the 404 page within a route segment as well as inject a <meta name=\"robots\" content=\"noindex\" /> tag. Invoking the notFound() function throws a NotFoundError error and terminates rendering of the route segment in which it was thrown. import { RequestContext } from \"brisa\";\nimport { notFound } from \"brisa\";\n\nasync function fetchUser(id) {\n  const res = await fetch(\"https://...\");\n  if (!res.ok) return undefined;\n  return res.json();\n}\n\nexport default async function UserProfile({}, req: RequestContext) {\n  const user = await fetchUser(req.route.params.id);\n\n  if (!user) {\n    notFound();\n  }\n\n  // ...\n} Useful to control response status during streaming: Before response streaming (middleware, responseHeaders): It's returning the response with 404 status and the 404 page\nDuring response streaming (layout, page, components): Adds the meta tag with noindex, stop rendering the page and sends a client script to replace the page to the 404 page. This redirect is for UX to display the 404 content, here the bots will no longer see that because it has the noindex. However, this soft redirect that is done on the client does not change the browsing history and does receive the 404 status. The browsers normally cache very well the pages that return status 404.\nDuring a server action: (server events captured with actions): as the rendering has already been done and it is a post-render action, the 404 in an action acts similarly as in the middle of the streaming. The same happens if in the action instead of calling notFound() directly you do a rerender and the component calls notFound(). notFound() does not require you to use return notFound() due to using the TypeScript never type. Avoid using the notFound inside a try/catch block. The navigate is a throwable function and will break the execution of the current function.",
    "titles": [
      "Custom Errors"
    ]
  },
  {
    "id": "/building-your-application/routing/custom-error#500-page",
    "title": "500 Page",
    "text": "To customize the 500 page you can create a src/pages/_500.js file. export default function Custom500({ error }, requestContext) {\n  return <h1>500 - {error.message}</h1>;\n} In this page you can access to the request context, fetch data, change the head content (meta tags, etc), and change the response headers, in the same way of the rest of pages.",
    "titles": [
      "Custom Errors"
    ]
  },
  {
    "id": "/building-your-application/routing/custom-error#errors-in-component-level",
    "title": "Errors in component-level",
    "text": "If you want to control errors at the component level instead of displaying a whole new page with the error, you can make the components have the error extension by adding the ComponentName.error: Example server component: import { RequestContext } from \"brisa\";\n\nexport default function SomeServerComponent() {\n  /* some JSX */\n}\n\nSomeServerComponent.error = (\n  { error, ...props },\n  requestContext: RequestContext,\n) => {\n  return <p>Oops! {error.message}</p>;\n}; Example web component: import { WebContext } from \"brisa\";\n\nexport default function SomeWebComponent() {\n  /* some JSX */\n}\n\nSomeWebComponent.error = ({ error, ...props }, webContext: WebContext) => {\n  return <p>Oops! {error.message}</p>;\n}; This works for both server and web components. The difference is that web-components have access to the webContext while server-components have access to the requestContext.",
    "titles": [
      "Custom Errors",
      "500 Page"
    ]
  },
  {
    "id": "/building-your-application/routing/dynamic-routes#dynamic-routes",
    "title": "Dynamic Routes",
    "text": "When you don't know the exact segment names ahead of time and want to create routes from dynamic data, you can use Dynamic Segments that are filled in at request time.",
    "titles": []
  },
  {
    "id": "/building-your-application/routing/dynamic-routes#convention",
    "title": "Convention",
    "text": "A Dynamic Segment can be created by wrapping a folder's name in square brackets: [folderName]. For example, [id] or [slug]. Dynamic Segments can be accessed from request context.",
    "titles": [
      "Dynamic Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/dynamic-routes#example",
    "title": "Example",
    "text": "For example, a blog could include the following route src/pages/blog/[slug].js where [slug] is the Dynamic Segment for blog posts. export default function Page(props, { route }) {\n  return <p>Post: {route.query.slug}</p>;\n} All components can access route.query in the same way, not just pages. Route\nExample URL\nparams\n\n\n\n\npages/blog/[slug].js\n/blog/a\n{ slug: 'a' }\n\n\npages/blog/[slug].js\n/blog/b\n{ slug: 'b' }\n\n\npages/blog/[slug].js\n/blog/c\n{ slug: 'c' }",
    "titles": [
      "Dynamic Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/dynamic-routes#catch-all-segments",
    "title": "Catch-all Segments",
    "text": "Dynamic Segments can be extended to catch-all subsequent segments by adding an ellipsis inside the brackets [...folderName]. For example, pages/shop/[...slug].js will match /shop/clothes, but also /shop/clothes/tops, /shop/clothes/tops/t-shirts, and so on. Route\nExample URL\nparams\n\n\n\n\npages/shop/[...slug].js\n/shop/a\n{ slug: ['a'] }\n\n\npages/shop/[...slug].js\n/shop/a/b\n{ slug: ['a', 'b'] }\n\n\npages/shop/[...slug].js\n/shop/a/b/c\n{ slug: ['a', 'b', 'c'] }",
    "titles": [
      "Dynamic Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/dynamic-routes#optional-catch-all-segments",
    "title": "Optional Catch-all Segments",
    "text": "Catch-all Segments can be made optional by including the parameter in double square brackets: [[...folderName]]. For example, pages/shop/[[...slug]].js will also match /shop, in addition to /shop/clothes, /shop/clothes/tops, /shop/clothes/tops/t-shirts. The difference between catch-all and optional catch-all segments is that with optional, the route without the parameter is also matched (/shop in the example above). Route\nExample URL\nparams\n\n\n\n\npages/shop/[[...slug]].js\n/shop\n{}\n\n\npages/shop/[[...slug]].js\n/shop/a\n{ slug: ['a'] }\n\n\npages/shop/[[...slug]].js\n/shop/a/b\n{ slug: ['a', 'b'] }\n\n\npages/shop/[[...slug]].js\n/shop/a/b/c\n{ slug: ['a', 'b', 'c'] }",
    "titles": [
      "Dynamic Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/dynamic-routes#prerender-pages-to-convert-dynamic-to-static-routes",
    "title": "Prerender pages to convert dynamic to static routes",
    "text": "When you have a dynamic route that you want to prerender to a static route, you can use the prerender function. export function prerender({ route }) {\n  return [{ slug: 'a' }, { slug: 'b' }],\n}\n\nexport default function BlogPost(props, { route }) {\n  return <p>Post: {route.query.slug}</p>;\n} This will create two static pages: /blog/a and /blog/b. The rest of the dynamic routes will be handled at runtime.",
    "titles": [
      "Dynamic Routes"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#internationalization-i18n",
    "title": "Internationalization (i18n)",
    "text": "Brisa has built-in support for internationalized (i18n). You can provide a list of locales, the default locale, and domain-specific locales and Brisa will automatically handle the routing.",
    "titles": []
  },
  {
    "id": "/building-your-application/routing/internationalization#getting-started",
    "title": "Getting started",
    "text": "To get started, add the src/i18n.(ts|js) or src/i18n/index.(ts|js) file. Locales are UTS Locale Identifiers, a standardized format for defining locales. Generally a Locale Identifier is made up of a language, region, and script separated by a dash: language-region-script. The region and script are optional. An example: en-US - English as spoken in the United States\nnl-NL - Dutch as spoken in the Netherlands\nnl - Dutch, no specific region If user locale is nl-BE and it is not listed in your configuration, they will be redirected to nl if available, or to the default locale otherwise.\nIf you don't plan to support all regions of a country, it is therefore a good practice to include country locales that will act as fallbacks. // filename=\"src/i18n.ts\nimport { I18nConfig } from \"brisa\";\n\nconst i18nConfig: I18nConfig = {\n  // These are all the locales you want to support in\n  // your application\n  locales: [\"en-US\", \"fr\", \"nl-NL\"],\n  // This is the default locale you want to be used when visiting\n  // a non-locale prefixed path e.g. `/hello`\n  defaultLocale: \"en-US\",\n  // This is a list of locale domains and the default locale they\n  // should handle (these are only required when setting up domain routing)\n  domains: {\n    \"example.com\": {\n      defaultLocale: \"en-US\",\n    },\n    \"example.nl\": {\n      defaultLocale: \"nl-NL\",\n    },\n  },\n};\n\nexport default i18nConfig;\n\n\n\n// filename=\"src/i18n.js\nexport default {\n  // These are all the locales you want to support in\n  // your application\n  locales: [\"en-US\", \"fr\", \"nl-NL\"],\n  // This is the default locale you want to be used when visiting\n  // a non-locale prefixed path e.g. `/hello`\n  defaultLocale: \"en-US\",\n  // This is a list of locale domains and the default locale they\n  // should handle (these are only required when setting up domain routing)\n  domains: {\n    \"example.com\": {\n      defaultLocale: \"en-US\",\n    },\n    \"example.nl\": {\n      defaultLocale: \"nl-NL\",\n    },\n  },\n};",
    "titles": [
      "Internationalization (i18n)"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#locale-strategies",
    "title": "Locale Strategies",
    "text": "There are two locale handling strategies: Sub-path Routing and Domain Routing.",
    "titles": [
      "Internationalization (i18n)"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#sub-path-routing",
    "title": "Sub-path Routing",
    "text": "Sub-path Routing puts the locale in the url path. export default {\n  locales: [\"en-US\", \"fr\", \"nl-NL\"],\n  defaultLocale: \"en-US\",\n}; With the above configuration en-US, fr, and nl-NL will be available to be routed to, and en-US is the default locale. If you have a src/pages/blog.js the following urls would be available: /en-us/blog\n/fr/blog\n/nl-nl/blog",
    "titles": [
      "Internationalization (i18n)",
      "Locale Strategies"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#domain-routing",
    "title": "Domain Routing",
    "text": "By using domain routing you can change the defaultLocale of each domain: export default {\n  locales: [\"en-US\", \"fr\", \"nl-NL\"],\n  defaultLocale: \"en-US\",\n  domains: {\n    \"example.com\": {\n      defaultLocale: \"en-US\",\n    },\n    \"example.nl\": {\n      defaultLocale: \"nl-NL\",\n      protocol: \"http\", // by default is https\n      dev: true, // by default is false\n    },\n  },\n}; For example if you have src/pages/blog.js the following urls will be available: example.com/blog â†’ example.com/en-us/blog\nexample.nl/blog â†’ example.nl/nl-nl/blog If the browser language is not supported as locale, then it will redirect to defaultLocale.",
    "titles": [
      "Internationalization (i18n)",
      "Locale Strategies"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#automatic-locale-detection",
    "title": "Automatic Locale Detection",
    "text": "When a user visits the application root (generally /), Brisa will try to automatically detect which locale the user prefers based on the Accept-Language header and the current domain. If a locale other than the default locale is detected, the user will be redirected to either: When using Domain Routing: The domain with that locale specified as the default When using Domain Routing, if a user with the Accept-Language header fr;q=0.9 visits example.com, they will be redirected to example.fr since that domain handles the fr locale by default. When using Sub-path Routing, the user would be redirected to /fr.",
    "titles": [
      "Internationalization (i18n)"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#accessing-the-locale-information",
    "title": "Accessing the locale information",
    "text": "You can access the locale information via the request context: locale contains the currently active locale.\nlocales contains all configured locales.\ndefaultLocale contains the configured default locale.\npages contains the configured pages.\nt function to consume translations.\noverrideMessages function to override messages at session level Example in a page: // src/pages/index.tsx\nimport { type RequestContext } from \"brisa\";\n\ntype Props = {\n  name: string;\n};\n\nexport default function Home({ name }: Props, requestContext: RequestContext) {\n  const { locale, t, defaultLocale } = requestContext.i18n;\n\n  if (locale === defaultLocale) {\n    return (\n      <h1>\n        {i18n.t(\"strong-hello\", { name }, { elements: { strong: <strong /> } })}\n      </h1>\n    );\n  }\n\n  return <h1>{t(\"hello\", { name })}</h1>;\n}\n\n\n\n// src/pages/index.jsx\nexport default function Home({ name }, requestContext) {\n  const { locale, t, defaultLocale } = requestContext.i18n;\n\n  if (locale === defaultLocale) {\n    return (\n      <h1>\n        {i18n.t(\"strong-hello\", { name }, { elements: { strong: <strong /> } })}\n      </h1>\n    );\n  }\n\n  return <h1>{t(\"hello\", { name })}</h1>;\n} In src/i18n: import { I18nConfig } from \"brisa\";\nimport en from \"./messages/en\";\nimport es from \"./messages/es\";\n\nexport default {\n  defaultLocale: \"en\",\n  locales: [\"en\", \"es\"],\n  messages: { en, es },\n} satisfies I18nConfig<typeof en>;\n\n\n\n{\n  \"hello\": \"Hello {{name}}!\",\n  \"strong-hello\": \"Hello <strong>{{name}}</strong>!\"\n}\n\n\n\n{\n  \"hello\": \"Â¡Hola {{name}}!\",\n  \"strong-hello\": \"Â¡Hola <strong>{{name}}</strong>!\"\n}",
    "titles": [
      "Internationalization (i18n)"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#consume-translations",
    "title": "Consume translations",
    "text": "Brisa supports to consume translations inspired by libraries such as i18next and next-translate. Good to know: It only occupies 400B of client code if you consume translations in the web-components, if you only use it in server-components, pages, layout, api, middleware, it is 0B of client code. In order to consume translations, you need first to define the messages property in src/i18n.(js|ts) file: // src/i18n/index.ts\nimport { I18nConfig } from \"brisa\";\n\nimport en from \"./messages/en\";\nimport es from \"./messages/es\";\n\nconst i18nConfig: I18nConfig<typeof en> = {\n  defaultLocale: \"en\",\n  locales: [\"en\", \"es\"],\n  messages: { en, es },\n};\n\nexport default i18nConfig;\n\n\n\n// src/i18n/index.js\nimport en from \"./messages/en\";\nimport es from \"./messages/es\";\n\nconst i18nConfig = {\n  defaultLocale: \"en\",\n  locales: [\"en\", \"es\"],\n  messages: { en, es },\n};\n\nexport default i18nConfig; {\n  \"hello\": \"Hello {{name}}!\",\n  \"strong-hello\": \"Hello <strong>{{name}}</strong>!\"\n} {\n  \"hello\": \"Â¡Hola {{name}}!\",\n  \"strong-hello\": \"Â¡Hola <strong>{{name}}</strong>!\"\n} After this, you can consume translations in every part of your app through the request context: middleware, api routes, page routes, all page components, responseHeaders, layout, Head of each page... Important in TypeScript: The generic type <typeof en> in I18nConfig enables type-safe consumption of translations with the t function by resolving the keys, keys with plurals and nested keys from the preferred locale. This allows IDE autocompletion and type checking of translation keys throughout the codebase, improving productivity and avoiding translation bugs due to typos or invalid keys. The generic I18nConfig<typeof en> allows you to activate type-safe consuming translations with the t function. Displaying to you all the keys from the preferred locale messages, resolving plurals and nested values. Example in a component: // src/components/hello.tsx\nimport { type RequestContext } from \"brisa\";\n\ntype Props = { name: string };\n\nexport default function Hello({ name }: Props, { i18n }: RequestContext) {\n  return (\n    <main>\n      <h1>{i18n.t(\"hello\", { name })}</h1>\n      <h2>\n        {i18n.t(\"strong-hello\", { name }, { elements: { strong: <strong /> } })}\n      </h2>\n    </main>\n  );\n}\n\n\n\n// src/components/hello.jsx\nexport default function Hello({ name }, { i18n }) {\n  return (\n    <>\n      <h1>{i18n.t(\"hello\", { name })}</h1>;\n      <h2>\n        {i18n.t(\"strong-hello\", { name }, { elements: { strong: <strong /> } })}\n      </h2>\n    </>\n  );\n} The t function: Input:\n\ni18nKey: string (key)\nquery: object (optional) (example: { name: 'Leonard' }). See more\noptions: object (optional)\n\nfallback: string |Â string[] - fallback if i18nKey doesn't exist. See more.\nreturnObjects: boolean - Get part of the JSON with all the translations. See more.\ndefault: string - Default translation for the key. If fallback keys are used, it will be used only after exhausting all the fallbacks.\nelements - JSX.Element[] | Record<string, JSX.Element> - Useful to use HTML inside translations. In case of Array each index corresponds to the defined tag <0>/<1>. In case of object each key corresponds to the defined tag <example>.\n\n\n\n\nOutput: string | JSX.Element",
    "titles": [
      "Internationalization (i18n)"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#override-translations",
    "title": "Override Translations",
    "text": "You can employ the i18n.overrideMessages method to override messages at the session level. This method is applicable to all server parts using the RequestContext or in web components utilizing the WebContext.",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#override-translations-in-server-parts",
    "title": "Override Translations in Server Parts",
    "text": "In situations where pages are connected to external i18n services and there is a need to fetch the latest translations from the external service on each request, this function proves useful. // src/pages/index.tsx\nimport { type RequestContext } from \"brisa\";\n\nexport default async function Page({}, { i18n }: RequestContext) {\n  await i18n.overrideMessages(async (originalMessages) => {\n    const newMessages = await fetch(/* */).then((r) => r.json());\n    return { ...originalMessages, ...newMessages };\n  });\n\n  // This translation may have been overwritten\n  return <div>{i18n.t(\"foo\")}</div>;\n}\n\n\n\n// src/pages/index.jsx\nexport default async function Page({}, { i18n }) {\n  await i18n.overrideMessages(async (originalMessages) => {\n    const newMessages = await fetch(/* */).then((r) => r.json());\n    return { ...originalMessages, ...newMessages };\n  });\n\n  // This translation may have been overwritten\n  return <div>{i18n.t(\"foo\")}</div>;\n} Consider the following middleware example for scenarios where a language is specific to one page and not available on others. // src/middleware.ts\nimport { type RequestContext, notFound } from \"brisa\";\n\nexport default async function middleware(request: RequestContext) {\n  const { locale, overrideMessages } = request.i18n;\n\n  // \"ca\" locale is only available on the home page\n  if (locale === \"ca\") {\n    // Throw 404 error for other pages with the same locale\n    if (request.route.pathname !== \"/\") notFound();\n\n    // Load \"ca\" messages from an external service\n    const caMessages = await fetch(/* */).then((r) => r.json());\n\n    // Save \"ca\" messages\n    i18n.overrideMessages(() => caMessages);\n  }\n}\n\n\n\n// src/middleware.js\nexport default async function middleware(request) {\n  const { locale, overrideMessages } = request.i18n;\n\n  // \"ca\" locale is only available on the home page\n  if (locale === \"ca\") {\n    // Throw 404 error for other pages with the same locale\n    if (request.route.pathname !== \"/\") notFound();\n\n    // Load \"ca\" messages from an external service\n    const caMessages = await fetch(/* */).then((r) => r.json());\n\n    // Save \"ca\" messages\n    i18n.overrideMessages(() => caMessages);\n  }\n}",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations",
      "Override Translations"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#override-translations-in-web-components",
    "title": "Override Translations in Web Components",
    "text": "Consider scenarios where you want to use it in web components to load a dynamically dictionary: import type { WebContext } from \"brisa\";\n\nexport default async function DynamicDictionary(\n  {},\n  { state, i18n }: WebContext,\n) {\n  const open = state<boolean>(false);\n  let isDictionaryLoaded = false;\n\n  async function onToggle() {\n    if (!open.value && !isDictionaryLoaded) {\n      isDictionaryLoaded = true;\n\n      await i18n.overrideMessages(async (messages) => ({\n        ...messages,\n        dynamicDictionary: await fetch(/* some url */).then((res) =>\n          res.json(),\n        ),\n      }));\n    }\n\n    open.value = !open.value;\n  }\n\n  return (\n    <>\n      <button onClick={onToggle}>\n        {open.value ? i18n.t(\"close\") : i18n.t(\"open\")}\n      </button>\n      {open.value && i18n.t(\"dynamicDictionary.someKey\")}\n    </>\n  );\n}\n\n\n\nexport default async function DynamicDictionary({}, { state, i18n }) {\n  const open = state(false);\n  let isDictionaryLoaded = false;\n\n  async function onToggle() {\n    if (!open.value && !isDictionaryLoaded) {\n      isDictionaryLoaded = true;\n\n      await i18n.overrideMessages(async (messages) => ({\n        ...messages,\n        dynamicDictionary: await fetch(/* some url */).then((res) =>\n          res.json(),\n        ),\n      }));\n    }\n\n    open.value = !open.value;\n  }\n\n  return (\n    <>\n      <button onClick={onToggle}>\n        {open.value ? i18n.t(\"close\") : i18n.t(\"open\")}\n      </button>\n      {open.value && i18n.t(\"dynamicDictionary.someKey\")}\n    </>\n  );\n} In this example, the DynamicDictionary web component demonstrates dynamic loading of translations in an event. Upon toggling, it checks whether the dictionary is already loaded; if not, it fetches translations from a specified URL and uses overrideMessages to integrate them seamlessly into the current session. The translated key, dynamicDictionary.someKey, is then displayed based on the component's state. This approach allows on-the-fly language customization for improved user experience. Messages are already filtered by the current locale. Therefore, you can only override messages for the specific locale during the session (request in server parts and globalThis in web components). The overrideMessages function does not perform global overrides on the original values; instead, it exclusively modifies them at the request level in server parts or on the client side for a specific session. This ensures that changes made with this function are scoped appropriately, preventing unintended global alterations.",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations",
      "Override Translations"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#interpolation",
    "title": "Interpolation",
    "text": "Interpolation allows integrating dynamic values into your translations. All values get escaped to mitigate XSS attacks. Example to display: \"Hello Brisa\": Keys: {\n  \"hello\": \"Hello {{name}}!\"\n} Sample: t(\"hello\", { name: \"Brisa\" }); // Hello Brisa!",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#prefix-and-suffix",
    "title": "Prefix and suffix",
    "text": "You can change the delimiter that is used for interpolation touching the configuration of src/i18n.js: export default {\n  locales: [\"en-US\", \"fr\", \"nl-NL\"],\n  defaultLocale: \"en-US\",\n  interpolation: {\n    prefix: \"[[\",\n    suffix: \"]]\",\n  },\n}; And now you can adapt the interpolation messages to use [[ and ]]: {\n  \"hello\": \"Hello [[name]]!\"\n} To consume the translations is the same as before. Sample: t(\"hello\", { name: \"Brisa\" }); // Hello Brisa!",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#formatters",
    "title": "Formatters",
    "text": "You can format params using the interpolation.formatter config function. The formatter is the communication layer with Intl EcmaScript features. For example it helps to transform values with decimals, currencies, etc, depending on the locale. Sample adding the number format: // src/i18n.ts\nimport { I18nConfig } from \"brisa\";\n\nconst formatters = {\n  es: new Intl.NumberFormat(\"es-ES\"),\n  en: new Intl.NumberFormat(\"en-EN\"),\n};\n\nconst i18nConfig: I18nConfig = {\n  // ...\n  interpolation: {\n    format: (value, format, lang) => {\n      if (format === \"number\") return formatters[lang].format(value);\n      return value;\n    },\n  },\n};\n\nexport default i18nConfig;\n\n\n\n// src/i18n.js\nconst formatters = {\n  es: new Intl.NumberFormat(\"es-ES\"),\n  en: new Intl.NumberFormat(\"en-EN\"),\n};\n\nexport default {\n  // ...\n  interpolation: {\n    format: (value, format, lang) => {\n      if (format === \"number\") return formatters[lang].format(value);\n      return value;\n    },\n  },\n}; In English: {\n  \"example\": \"The number is {{count, number}}\"\n} In Spanish: {\n  \"example\": \"El nÃºmero es {{count, number}}\"\n} Using: t(\"example\", { count: 33.5 }); Returns: In English: The number is 33.5\nIn Spanish: El nÃºmero es 33,5",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations",
      "Prefix and suffix"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#nested-messages",
    "title": "Nested messages",
    "text": "It's possible to use nested messages in the JSONs: {\n  \"nested\": {\n    \"example\": \"Hello {{name}}\"\n  }\n} To consume it by default is used the . key separator: t(\"nested.example\", { name: \"Brisa\" });",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#key-separator",
    "title": "Key separator",
    "text": "You can change the keySeparator of nested messages in the src/i18n.js configuration: return {\n  // ...\n  keySeparator: \"|\",\n}; Then: t(\"nested|example\");",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations",
      "Nested messages"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#return-all-nested-translations",
    "title": "Return all nested translations",
    "text": "You can use the returnObjects: true, in the t options to get all. t(\"nested\", { name: \"Brisa\" }, { returnObjects: true });\n// { \"example\": \"Hello Brisa\" } Also you can use a dot \".\" as all: t(\".\", { name: \"Brisa\" }, { returnObjects: true });\n// { \"nested\": { \"example\": \"Hello Brisa\" } } Taking account that these are the messages: {\n  \"nested\": {\n    \"example\": \"Hello {{name}}\"\n  }\n}",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#fallbacks",
    "title": "Fallbacks",
    "text": "If no translation exists you can define fallbacks (string|string[]) to search for other translations: Sample of a fallback: t(\n  \"message-key\",\n  { count: 1 },\n  {\n    fallback: \"fallback-key\",\n  },\n); Sample with list of fallbacks: t(\n  \"message-key\",\n  { count: 42 },\n  {\n    fallback: [\"fallback-key\", \"fallback-key-2\"],\n  },\n);",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#plurals",
    "title": "Plurals",
    "text": "Brisa support 6 plural forms (taken from CLDR Plurals page) by adding to the key this suffix (or nesting it under the key with no _ prefix): _zero\n_one (singular)\n_two (dual)\n_few (paucal)\n_many (also used for fractions if they have a separate class)\n_other (requiredâ€”general plural formâ€”also used if the language only has a single form) See more info about plurals here. Only the last one, _other, is required because itâ€™s the only common plural form used in all locales. All other plural forms depends on locale. For example English has only two: _one and _other (1 cat vs. 2 cats). Some languages have more, like Russian and Arabic. In addition, Brisa also support an exact match by specifying the number (_0, _999) and this works for all locales. Here is an example: // **Note**: Only works if the name of the variable is {{count}}.\nt(\"cart-message\", { count }); And the messages: {\n  \"cart-message_0\": \"The cart is empty\", // when count === 0\n  \"cart-message_one\": \"The cart has only {{count}} product\", // singular\n  \"cart-message_other\": \"The cart has {{count}} products\", // plural\n  \"cart-message_999\": \"The cart is full\" // when count === 999\n} or {\n  \"cart-message\": {\n     \"0\": \"The cart is empty\", // when count === 0\n     \"one\": \"The cart has only {{count}} product\", // singular\n     \"other\": \"The cart has {{count}} products\", // plural\n     \"999\": \"The cart is full\", // when count === 999\n  }\n}",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#html-inside-the-translation",
    "title": "HTML inside the translation",
    "text": "Brisa supports consuming HTML inside translations, all interpolations are escaped to avoid XSS attacks and elements are defined from where they are consumed. You can use numbers or names: {\n  \"hello\": \"Hello <0>{{name}}</0>!\",\n  \"hello-2\": \"Hello <bold>{{name}}</bold>!\"\n} Then to consume it you need to define the elements using an Record<string, JSX.Element> or an JSX.Element[]: t(\"hello\", { name: \"Brisa\" }, { elements: [<strong />] }); or t(\"hello-2\", { name: \"Brisa\" }, { elements: { bold: <strong /> } });",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#default-value-when-translation-doest-exist",
    "title": "Default value when translation does't exist",
    "text": "If the translation does not exist and all fallback keys fail (if any), then as default behavior, the key is shown. t(\"hello\", { name: \"Brisa\" }); // Hello Brisa\nt(\"no-existing-key\"); // no-existing-key",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#change-default-value",
    "title": "Change default value",
    "text": "You can overwrite the default value using the default option: t(\"no-existing-key\", {}, { default: \"No value\" }); // No value",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations",
      "Default value when translation does't exist"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#empty-translations",
    "title": "Empty translations",
    "text": "With the allowEmptyStrings option of /src/i18n/index.ts you can change how translated empty strings should be handled. {\n  \"hello\": \"\"\n} If omitted or passed as true (By default is true), it returns an empty string. If passed as false, returns the key name itself. // src/i18n/index.ts\nimport { I18nConfig } from \"brisa\";\n\nimport en from './messages/en';\nimport es from './messages/es';\n\nconst i18nConfig: I18nConfig<typeof en> = {\n  defaultLocale: \"en\",\n  locales: [\"en\", \"es\"],\n  messages: { en, es }\n  allowEmptyStrings: false,\n};\n\nexport default i18nConfig;\n\n\n\n// src/i18n/index.js\nimport en from './messages/en';\nimport es from './messages/es';\n\nconst i18nConfig = {\n  defaultLocale: \"en\",\n  locales: [\"en\", \"es\"],\n  messages: { en, es }\n  allowEmptyStrings: false,\n};\n\nexport default i18nConfig; Now t('hello') returns \"hello\" instead of an empty string \"\".",
    "titles": [
      "Internationalization (i18n)",
      "Consume translations"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#translate-page-pathname",
    "title": "Translate page pathname",
    "text": "Many times we want the URL to be different in different languages. For example: /en/about-us â†’ src/pages/about-us.tsx\n/es/sobre-nosotros â†’ src/pages/about-us.tsx export default {\n  locales: [\"en-US\", \"es\"],\n  defaultLocale: \"en-US\",\n  pages: {\n    \"/about-us\": {\n      es: \"/sobre-nosotros\",\n    },\n    \"/user/[username]\": {\n      es: \"/usuario/[username]\",\n    },\n  },\n}; The key of each page item will be the name of the route. It works also with dynamic and catch-all routes. It will automatically be taken into account in redirects, navigation and the hrefLang generation (see here how to active hrefLang). Brisa automatically corrects links in the HTML of Server Components to solve these page translations, this means that you can use /about-us in the href of the a tag and it will be automatically corrected to /es/sobre-nosotros if the user is in the es locale.\nHowever, this automatic correction does not apply to Web Components by default, you have to activate it via configuration.",
    "titles": [
      "Internationalization (i18n)"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#activate-page-pathname-translation-in-web-components",
    "title": "Activate page pathname translation in Web Components",
    "text": "To activate the automatic correction of links in Web Components you need to add the pages.config.transferToClient property: export default {\n  locales: [\"en-US\", \"es\"],\n  defaultLocale: \"en-US\",\n  pages: {\n    config: {\n      transferToClient: true,\n    },\n    \"/about-us\": {\n      es: \"/sobre-nosotros\",\n    },\n    \"/user/[username]\": {\n      es: \"/usuario/[username]\",\n    },\n  },\n}; This will automatically correct ALL the links in the HTML of Web Components. If you want to correct only some paths, you can provide an array of paths: export default {\n  locales: [\"en-US\", \"es\"],\n  defaultLocale: \"en-US\",\n  pages: {\n    config: {\n      transferToClient: [\"/about-us\"],\n    },\n    \"/about-us\": {\n      es: \"/sobre-nosotros\",\n    },\n    \"/user/[username]\": {\n      es: \"/usuario/[username]\",\n    },\n  },\n}; Changing the page's language setting (locale) wonâ€™t automatically update the href links that have already been rendered, as these links donâ€™t react to locale changes. To properly change the language, you have two options:\n\n\nUse renderMode=\"native\": This method ensures that the page is rendered in the new language, updating all the content including the links. For more details, refer to the Native Rendering documentation.\n\n\nUpdate the key Attribute: If you update the key attribute of the web component, it will force the component to be recreated with the new language setting. For more information on how to use the key attribute, see the Key Property documentation. Activating this feature is going to increase the client bundle size because it needs to include the page translations and the logic to correct the links (~630 bytes).",
    "titles": [
      "Internationalization (i18n)",
      "Translate page pathname"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#types",
    "title": "Types:",
    "text": "export type i18nPages = {\n  [path: `/${string}`]: {\n    [K: ISOLocale]: string;\n  };\n} & {\n  config?: {\n    transferToClient?: boolean | `/${string}`[];\n  };\n};",
    "titles": [
      "Internationalization (i18n)",
      "Translate page pathname"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#navigation",
    "title": "Navigation",
    "text": "During navigation you do not have to add the locale in the href of the a tag, if you add it it will not do any conversion. The fact of not adding the locale Brisa takes care of transforming the link: import type { RequestContext } from 'brisa';\n\nfunction MyComponent({}, { i18n: { t } }: RequestContext) {\n  return <a href=\"/about-us\">{t(\"about-us\")}</a>;\n}\n\n\n\nfunction MyComponent({}, { i18n: { t } }) {\n  return <a href=\"/about-us\">{t(\"about-us\")}</a>;\n} Will be transformed to this HTML in es: <a href=\"/es/sobre-nosotros\">Sobre nosotros</a>",
    "titles": [
      "Internationalization (i18n)"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#transition-between-locales",
    "title": "Transition between locales",
    "text": "As long as you do not put the locale in the href of a tag, then no conversion is done. It is useful to change the language: // src/components/change-locale.tsx\nimport { type RequestContext } from \"brisa\";\n\nexport function ChangeLocale(props: {}, { i18n, route }: RequestContext) {\n  const { locales, locale, pages, t } = i18n;\n\n  return (\n    <ul>\n      {locales.map((lang) => {\n        const pathname = pages[route.name]?.[lang] ?? route.pathname;\n\n        if (lang === locale) return null;\n\n        return (\n          <li key={lang}>\n            <a href={`/${lang}${pathname}`}>{t(`change-to-${lang}`)}</a>\n          </li>\n        );\n      })}\n    </ul>\n  );\n}\n\n\n\n// src/components/change-locale.js\nexport function ChangeLocale(props: {}, { i18n, route }) {\n  const { locales, locale, pages, t } = i18n;\n\n  return (\n    <ul>\n      {locales.map((lang) => {\n        const pathname = pages[route.name]?.[lang] ?? route.pathname;\n\n        if (lang === locale) return null;\n\n        return (\n          <li key={lang}>\n            <a href={`/${lang}${pathname}`}>{t(`change-to-${lang}`)}</a>\n          </li>\n        );\n      })}\n    </ul>\n  );\n}",
    "titles": [
      "Internationalization (i18n)"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#leveraging-the-brisalocale-cookie",
    "title": "Leveraging the BRISA_LOCALE cookie",
    "text": "Brisa supports overriding the accept-language header with a BRISA_LOCALE=the-locale cookie. This cookie can be set using a language switcher and then when a user comes back to the site it will leverage the locale specified in the cookie when redirecting from / to the correct locale location. For example, if a user prefers the locale fr in their accept-language header but a BRISA_LOCALE=en cookie is set the en locale when visiting / the user will be redirected to the en locale location until the cookie is removed or expired.",
    "titles": [
      "Internationalization (i18n)"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#search-engine-optimization",
    "title": "Search Engine Optimization",
    "text": "Since Brisa knows what language the user is visiting it will automatically add the lang and dir attributes to the <html> tag. The lang attribute is added to define the language of the content assisting search engines and browsers, meanwhile the dir attribute is added to indicate to search engines and browsers the directionality of the content text.",
    "titles": [
      "Internationalization (i18n)"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#activate-automatic-hreflang",
    "title": "Activate automatic hrefLang",
    "text": "Brisa by default doesn't add the hreflang meta tags, but you can activate it to automatic generate the hrefLang. To activate the generation of hrefLang you need the hrefLangOrigin property to specify one or more origins. For one origin: export default {\n  locales: [\"en-US\", \"es\"],\n  defaultLocale: \"en-US\",\n  hrefLangOrigin: \"https://www.example.com\",\n}; For multi-origins: export default {\n  locales: [\"en-US\", \"es\"],\n  defaultLocale: \"en-US\",\n  hrefLangOrigin: {\n    es: \"https://www.example.com\",\n    en: \"https://www.example.co.uk\",\n  },\n}; In the case of using domain routing, maybe you wonder why you have to repeat domains and origins? ðŸ¤” domains defines the default language per domain for routing and language detection.\nhrefLangOrigin defines the origin/domain to use in the href attribute of hreflang for each language. The main difference between them is that you can have multiple domains in domains with the same defaultLocale, but in hrefLangOrigin you want to prioritize a specific one per language. Besides, you may not have domains defined but want to use the hrefLangOrigin to only 1 origin. hrefLang is automatic managed by Brisa, however rel=canonical links not. For these domains that have the same defaultLocale we recommend to manage in the layout the canonical links in order to prevent duplicate content issues in search engine optimization.",
    "titles": [
      "Internationalization (i18n)",
      "Search Engine Optimization"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#finalurl",
    "title": "finalURL",
    "text": "The finalURL is a field you have access to in the RequestContext and is the URL of your page, regardless of the fact that for the users it is another one. For example, if the user enters to /es/sobre-nosotros/ the finalURL can be /about-us because your page is in src/pages/about-us/index.tsx. export default function SomeComponent(\n  {},\n  { i18n, finalURL, route }: RequestContext,\n) {\n  console.log(`${finalURL} - ${i18n.locale} - ${route.pathname}`);\n  // /about-us - es - /es/sobre-nosotros/\n}\n\n\n\nexport default function SomeComponent({}, { i18n, finalURL, route }) {\n  console.log(`${finalURL} - ${i18n.locale} - ${route.pathname}`);\n  // /about-us - es - /es/sobre-nosotros/\n}",
    "titles": [
      "Internationalization (i18n)"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#translate-in-your-web-components",
    "title": "Translate in your web components",
    "text": "Brisa's web components allow direct consumption of translation keys within the component. You can seamlessly integrate translation into your components without the need for extensive configurations. Brisa intelligently identifies and imports only the necessary translation keys required by a web component. This eliminates unnecessary overhead, ensuring optimal performance by importing only the keys relevant to the component's functionality. export default function WebComponent({}, { i18n }: WebContext) {\n  return <h2>{i18n.t(\"hello-world\")}</h2>;\n}\n\n\n\nexport default function WebComponent({}, { i18n }) {\n  return <h2>{i18n.t(\"hello-world\")}</h2>;\n}",
    "titles": [
      "Internationalization (i18n)"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#dynamic-keys",
    "title": "Dynamic keys",
    "text": "Brisa excels in supporting dynamic translation keys at the web component level using the i18nKeys feature. This becomes particularly valuable when managing dynamic content, such as generating translation keys based on runtime variables. Consider the example below: export default function Item({ itemId }, { i18n: { t } }: WebContext) {\n  return (\n    <>\n      <h2>{t(`item.${itemId}.title`)}</h2>\n      <p>{t(`item.${itemId}.description`)}</p>\n      <a href={`/item/${itemId}`}>{t(\"more\")}</a>\n    </>\n  );\n}\n\nItem.i18nKeys = [/item.*(title|description)/];\n\n\n\nexport default function Item({ itemId }, { i18n }) {\n  return (\n    <>\n      <h2>{t(`item.${itemId}.title`)}</h2>\n      <p>{t(`item.${itemId}.description`)}</p>\n      <a href={`/item/${itemId}`}>{t(\"more\")}</a>\n    </>\n  );\n}\n\nItem.i18nKeys = [/item.*(title|description)/]; In this scenario, the static key more imports seamlessly, while the other dynamic keys require explicit specification in Item.i18nKeys. The i18nKeys field accepts both string and RegExp types for flexibility. Example Usage: Item.i18nKeys = [\"item\"]; For more precision, utilize RegExp: Item.i18nKeys = [/item.*(title|description)/];",
    "titles": [
      "Internationalization (i18n)",
      "Translate in your web components"
    ]
  },
  {
    "id": "/building-your-application/routing/internationalization#plurals-1",
    "title": "Plurals",
    "text": "Brisa seamlessly manages the importation of all plural rules associated with a translation key. The following translations exemplify the pluralization handling: {\n  \"cart-message_0\": \"The cart is empty\",\n  \"cart-message_one\": \"The cart has only {{count}} product\",\n  \"cart-message_other\": \"The cart has {{count}} products\",\n  \"cart-message_999\": \"The cart is full\",\n} or {\n  \"cart-message\": {\n     \"0\": \"The cart is empty\",\n     \"one\": \"The cart has only {{count}} product\",\n     \"other\": \"The cart has {{count}} products\",\n     \"999\": \"The cart is full\",\n  }\n} All associated plural rules are imported to the client code after consuming the key: t(\"cart-message\", { count }); Brisa's comprehensive translation handling, dynamic key support, and intelligent importation make it a powerful tool for developers seeking efficient localization in web development projects.",
    "titles": [
      "Internationalization (i18n)",
      "Translate in your web components"
    ]
  },
  {
    "id": "/building-your-application/routing/linking-and-navigating#linking-and-navigating",
    "title": "Linking and Navigating",
    "text": "",
    "titles": []
  },
  {
    "id": "/building-your-application/routing/linking-and-navigating#navigation-with-reactivity",
    "title": "Navigation with reactivity",
    "text": "Brisa works with MPA like SPA thanks to Navigation API, so we will use the native HTML navigation and you can use the a tag directly: export default function Home() {\n  return (\n    <ul>\n      <li>\n        <a href=\"/\">Home</a>\n      </li>\n      <li>\n        <a href=\"/about\">About Us</a>\n      </li>\n      <li>\n        <a href=\"/blog/hello-world\">Blog Post</a>\n      </li>\n    </ul>\n  );\n} The example above uses multiple a tags. Each one maps a path (href) to a known page: / â†’ src/pages/index.js\n/about â†’ src/pages/about.js\n/blog/hello-world â†’ src/pages/blog/[slug].js By default, without the renderMode attribute, it acts with the reactivity mode. This means that it does a diff of the DOM between the new document and the current one, thus maintaining the states of the web components that are still visible (either because they are in the layout or because we are navigating to the same page in another language) and the store signal between pages. Although it is a DOM diff it works with incremental rendering, that is to say, that if the following page uses suspense, when processing the diff with HTML streaming the suspense mode continues working. The reactivity updates only the content of the page that has changed, keeping the rest of the page intact. This is useful for maintaining the state of the web components that are still visible. Good to know:\nWith reactivity render mode (like SPA), we prioritizes the preservation of <body> attributes during the HTML diffing process. This design choice grants developers greater control over runtime modifications, such as themes, fonts, and other display properties managed through BODY tag attributes.\nMany of these decisions are actions performed by users at runtime. It would be disruptive if a user changed the theme of the page, only for that change to be lost upon navigation.",
    "titles": [
      "Linking and Navigating"
    ]
  },
  {
    "id": "/building-your-application/routing/linking-and-navigating#signals-depending-on-external-dom-elements",
    "title": "Signals depending on external DOM elements",
    "text": "Navigation with HTML streaming is very powerful because it allows you to see changes on the page immediately, but keep in mind that a web component can be mounted when the diffing part is not yet finished and it still needs to render the rest of DOM elements. That said, if a web component uses document.querySelectorAll() to get external elements from the DOM, you have to update them after navigation. To do this, you can use: window.navigation.addEventListener('navigatesuccess', updateDOMElements);\ncleanup(() => window.navigation.removeEventListener('navigatesuccess', updateDOMElements)); This event is part of the Web Platform, not Brisa, more documentation at MDN.",
    "titles": [
      "Linking and Navigating",
      "Navigation with reactivity"
    ]
  },
  {
    "id": "/building-your-application/routing/linking-and-navigating#navigation-with-transition",
    "title": "Navigation with transition",
    "text": "There are times when we want to make transition animations between one page and another. To achieve this we can use the renderMode attribute of <a> to specify that this navigation uses the View Transition AP. When using the transitions it still works like the reactivity mode, plus the addition of the View Transition API transition. It still works with suspense and HTML streaming. Example: export default function Home() {\n  return (\n    <ul>\n      <li>\n        <a href=\"/\" renderMode=\"transition\">\n          Home\n        </a>\n      </li>\n      <li>\n        <a href=\"/about\" renderMode=\"transition\">\n          About Us\n        </a>\n      </li>\n      <li>\n        <a href=\"/blog/hello-world\" renderMode=\"transition\">\n          Blog Post\n        </a>\n      </li>\n    </ul>\n  );\n} To add custom transition animations, you have to do it with CSS and the view-transition-name property. For example, to change the speed of it: ::view-transition-old(root),\n::view-transition-new(root) {\n  animation-duration: 0.5s;\n} To access the transition with JavaScript/TypeScript you can access the global property window.lastDiffTransition",
    "titles": [
      "Linking and Navigating"
    ]
  },
  {
    "id": "/building-your-application/routing/linking-and-navigating#navigation-in-native-way",
    "title": "Navigation in native way",
    "text": "If we want to force the navigation to be native (that of the browser, without simulating SPA), we can indicate it with the renderMode attribute: export default function Home() {\n  return (\n    <ul>\n      <li>\n        <a href=\"/\" renderMode=\"native\">\n          Home\n        </a>\n      </li>\n      <li>\n        <a href=\"/about\" renderMode=\"native\">\n          About Us\n        </a>\n      </li>\n      <li>\n        <a href=\"/blog/hello-world\" renderMode=\"native\">\n          Blog Post\n        </a>\n      </li>\n    </ul>\n  );\n} By default it is already native in these cases: If you use another target, such as target=\"_blank\".\nUsing another origin ex: <a href=\"https://example.com\">.\nUsing the download attribute, ex: <a href=\"/some-file.pdf\" download>. Modifying the history Web API always acts as native navigation, bypassing reactivity and transition modes. To have the URL params as a signal, take a look this example.",
    "titles": [
      "Linking and Navigating"
    ]
  },
  {
    "id": "/building-your-application/routing/linking-and-navigating#navigation-to-dynamic-paths",
    "title": "Navigation to dynamic paths",
    "text": "You can also use interpolation to create the path, which comes in handy for dynamic route segments. For example, to show a list of posts which have been passed to the component as a prop: export default function Posts({ posts }) {\n  return (\n    <ul>\n      {posts.map((post) => (\n        <li key={post.id}>\n          <a href={`/blog/${encodeURIComponent(post.slug)}`}>{post.title}</a>\n        </li>\n      ))}\n    </ul>\n  );\n} encodeURIComponent is used in the example to keep the path utf-8 compatible.",
    "titles": [
      "Linking and Navigating"
    ]
  },
  {
    "id": "/building-your-application/routing/linking-and-navigating#i18n-navigation",
    "title": "I18n navigation",
    "text": "If you have i18n routing enabled, during navigation you always have to forget about route translations and during the render of the page will be translated to correct translated page. export default function Home() {\n  return <a href=\"/about\">About Us</a>;\n} In English: /about â†’ /en/about â†’ src/pages/about.js In Spanish: /about â†’ /es/sobre-nosotros â†’ src/pages/about.js For pathname translations, we recommend using server components to avoid the need for client-side translations, however, if you need to use client-side translations, you can use the pages.config.transferToClient configuration property to transfer the needed page pathnames translations to the client.",
    "titles": [
      "Linking and Navigating"
    ]
  },
  {
    "id": "/building-your-application/routing/linking-and-navigating#navigate-to-another-locale",
    "title": "Navigate to another locale",
    "text": "It is always possible to force a specific route in case you want to change the locale to another one: export default function Home() {\n  return <a href=\"/es/sobre-nosotros\">About Us in Spanish</a>;\n} If you are changing the current page locale and you have translations in the client-side, to avoid any issues with the translations, we recommend using the renderMode=\"native\" attribute to force to reload all the translations and href links that are setted on client-side (they are not reactive with signals).",
    "titles": [
      "Linking and Navigating",
      "I18n navigation"
    ]
  },
  {
    "id": "/building-your-application/routing/linking-and-navigating#navigate-function",
    "title": "navigate function",
    "text": "The navigate function is used for imperative navigation. import { navigate } from \"brisa\";\n\n// ...\nnavigate(\"/some-page\"); The navigate function can be used both on the client and on the server. Although there are some differences to be taken into account: If the navigation is done before sending the response (in the middleware, responseHeaders or an API endpoint for example), instead of modifying the navigation history it does a 301 redirect.\nIf it is done during rendering, a soft redirect is made.\nIf used inside a client-event or a server-event (action) a new page is always generated in the navigation history. All i18n navigaton rules apply equally in this function. navigate('/some') does not require you to use return navigate('/some') due to using the TypeScript never type.",
    "titles": [
      "Linking and Navigating"
    ]
  },
  {
    "id": "/building-your-application/routing/linking-and-navigating#prefetch",
    "title": "Prefetch",
    "text": "Prefetching is a technique used in web browsing to enhance the user experience by proactively loading resources before they are explicitly requested by the user. When a user visits a webpage, their browser typically fetches resources such as HTML files, CSS stylesheets, JavaScript files, images, and other assets required to render the page. Prefetching allows the browser to anticipate the user's next actions and fetch resources that are likely to be needed soon. Prefetching can significantly improve perceived page load times and responsiveness, especially on high-latency networks or devices with limited processing power. However, it's essential to implement prefetching judiciously to avoid unnecessary bandwidth consumption and ensure that prefetching does not interfere with other critical tasks, such as fetching resources for the currently viewed page. To apply the prefetch we can apply it thanks to the Head component of the page: export function Head({}, { route }: RequestContext) {\n  return (\n    <>\n      <link rel=\"prefetch\" href=\"/foo\"></link>\n    </>\n  );\n}\n\nexport default function Page() {\n  return <a href=\"/foo\">Navigate to foo</a>;\n} In this above example, when navigating to /foo the result will be immediate because the request has already been processed. The i18n is managed in the same way as the links, so if /foo in Spanish is called /bar, it will automatically convert /foo to /es/bar. Consider an e-commerce website with a multi-step checkout process consisting of distinct pages for entering shipping information, payment details, and order confirmation. By implementing prefetching, we can ensure that each step of the checkout process loads instantly as the user progresses, providing a seamless and frictionless experience. For more information access the MDN documentation. Although it is implemented in all browsers, in Safari and Safari iOS it is under a preference setting, so probably will be users who do not have the prefetch applied to them.",
    "titles": [
      "Linking and Navigating"
    ]
  },
  {
    "id": "/building-your-application/routing/linking-and-navigating#prefetch-with-javascripttypescript",
    "title": "Prefetch with JavaScript/TypeScript",
    "text": "To prefetch imperatively with JavaScript or TypeScript, you can do it from the Web Components with the fetch method. As in production the pages have this header: Cache-Control:\nno-store, must-revalidate, public, max-age=3600 They are cached for 1 hour. Therefore, you can use the fetch without processing the response, only as a prefetch to ensure that during navigation it pulls the cache. Example: export default function SomeWebComponent() {\n  // The prefetch don't need await because we are not processing the response in this\n  fetch(\"/foo\");\n  return <a href=\"/foo\">Navigate to foo</a>;\n} The imperative prefetch using fetch doesn't work in Server Components. For Server Components you can use the the link element. The imperative prefetch using fetch don't translate i18n pages, so you need to manage with the i18n info from the WebContext.",
    "titles": [
      "Linking and Navigating",
      "Prefetch"
    ]
  },
  {
    "id": "/building-your-application/routing/linking-and-navigating#speculation-rules-for-prerendering",
    "title": "Speculation Rules for prerendering",
    "text": "The Chrome team has reintroduced full prerendering capabilities to enhance page load times by speculating which pages a user might navigate to next. This new mechanism uses the Speculation Rules API, allowing developers to programmatically prerender pages. This guide will show you how to use this API to prerender a page when a user hovers over a link. Example: <script type=\"speculationrules\">\n  {\n    \"prerender\": [\n      {\n        \"where\": {\n          \"href_matches\": \"/*\"\n        },\n        \"eagerness\": \"moderate\"\n      }\n    ]\n  }\n</script> In this example: The speculation rule is defined within a <script type=\"speculationrules\"> tag.\nThe rule specifies that all URLs matching the pattern /* should be prerendered.\nThe eagerness property is set to moderate, which means that speculation will be triggered when the user hovers over a link for 200 milliseconds or on the pointerdown event (useful for mobile devices where hover events are not applicable). This setup ensures that prerendering happens efficiently and only when there is a high likelihood of the user navigating to those pages based on their interaction with the links. For more information access the MDN documentation.",
    "titles": [
      "Linking and Navigating",
      "Prefetch"
    ]
  },
  {
    "id": "/building-your-application/routing/middleware#middleware",
    "title": "Middleware",
    "text": "Middleware allows you to run code before a request is completed. Then, based on the incoming request, you can modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly. Middleware runs before routes are matched.",
    "titles": []
  },
  {
    "id": "/building-your-application/routing/middleware#convention",
    "title": "Convention",
    "text": "Use the file middleware.ts (or .js) inside the src folder of your project to define Middleware. Or inside src/middleware/index.ts (or .js).",
    "titles": [
      "Middleware"
    ]
  },
  {
    "id": "/building-your-application/routing/middleware#example",
    "title": "Example",
    "text": "// middleware.ts\nimport { type RequestContext } from \"brisa\";\n\n// This function can be without `async` if you are not using `await` inside\nexport default async function middleware({\n  i18n,\n  route,\n  headers,\n}: RequestContext): Response | undefined {\n  const { locale } = i18n;\n  const isUserRoute = route?.name?.startsWith(\"/user/[username]\");\n\n  if (isUserRoute && !(await isUserLogged(headers))) {\n    return new Response(\"\", {\n      status: 302,\n      headers: {\n        Location: `/${locale}/login`,\n      },\n    });\n  }\n}\n\n\n\n// middleware.js\n// This function can be without `async` if you are not using `await` inside\nexport default async function middleware({ i18n, route, headers }) {\n  const { locale } = i18n;\n  const isUserRoute = route?.name?.startsWith(\"/user/[username]\");\n\n  if (isUserRout && !(await isUserLogged(headers))) {\n    return new Response(\"\", {\n      status: 302,\n      headers: {\n        Location: `/${locale}/login`,\n      },\n    });\n  }\n} Only is possible to access to route property inside api routes and pages routes. This is to support handling of dynamic routes, catch-all, etc in a simple way. In the case of assets you can look it up through the request: import { type RequestContext } from \"brisa\";\n\nexport default async function middleware(\n  request: RequestContext,\n): Response | undefined {\n  const url = new URL(request.url);\n\n  if (url.pathname === \"/favicon.svg\") {\n    return new Response(\n      `\n      <svg>\n        <rect width=\"100\" height=\"100\" fill=\"red\" />\n      </svg>\n    `,\n      {\n        headers: { \"content-type\": \"image/svg+xml\" },\n      },\n    );\n  }\n}\n\n\n\nexport default async function middleware(request) {\n  const url = new URL(request.url);\n\n  if (url.pathname === \"/favicon.svg\") {\n    return new Response(\n      `\n      <svg>\n        <rect width=\"100\" height=\"100\" fill=\"red\" />\n      </svg>\n    `,\n      {\n        headers: { \"content-type\": \"image/svg+xml\" },\n      },\n    );\n  }\n} However, this is not the best way to serve assets. You can put the static files directly inside the public folder. More information here.",
    "titles": [
      "Middleware"
    ]
  },
  {
    "id": "/building-your-application/routing/middleware#cookies-and-headers",
    "title": "Cookies & Headers",
    "text": "",
    "titles": [
      "Middleware"
    ]
  },
  {
    "id": "/building-your-application/routing/middleware#on-request",
    "title": "On Request",
    "text": "Cookies are regular headers. On a Request, they are stored in the Cookie header. import { type RequestContext } from \"brisa\";\n\nexport default async function middleware(request: RequestContext) {\n  const cookies = request.headers.get(\"cookie\");\n  const headers = request.headers.get(\"x-example\");\n\n  // ... do something with cookies and headers\n}\n\n\n\nexport default async function middleware(request) {\n  const cookies = request.headers.get(\"cookie\");\n  const headers = request.headers.get(\"x-example\");\n\n  // ... do something with cookies and headers\n}",
    "titles": [
      "Middleware",
      "Cookies & Headers"
    ]
  },
  {
    "id": "/building-your-application/routing/middleware#on-response",
    "title": "On Response",
    "text": "The responseHeaders function can be exported in the middleware, in the same way that you can do it inside layout and pages. All responseHeaders will be mixed in this order: middleware response headers\nlayout response headers (can crush the middleware response headers)\npage response headers (both middleware and layout response headers can be mixed). import { type RequestContext } from \"brisa\";\n\nexport function responseHeaders(\n  request: RequestContext,\n  responseStatus: number,\n) {\n  return {\n    \"Cache-Control\": \"public, max-age=3600\",\n    \"X-Example\": \"This header is added from middleware\",\n  };\n}\n\n\n\nexport function responseHeaders(request, responseStatus) {\n  return {\n    \"Cache-Control\": \"public, max-age=3600\",\n    \"X-Example\": \"This header is added from middleware\",\n  };\n}",
    "titles": [
      "Middleware",
      "Cookies & Headers"
    ]
  },
  {
    "id": "/building-your-application/routing/middleware#share-data-between-middleware-layout-page-component-responseheaders",
    "title": "Share data between middleware â†’ layout â†’ page â†’ component â†’ responseHeaders",
    "text": "You can share data between different parts of the application using the store. import { type RequestContext } from \"brisa\";\n\nexport default async function middleware(request: RequestContext) {\n  const data = await getData(request);\n\n  request.store.set(\"data\", data);\n} import { type RequestContext } from \"brisa\";\n\ntype Props = {\n  name: string;\n};\n\nexport default function SomeComponent(props: Props, request: RequestContext) {\n  const data = request.store.get(\"data\");\n\n  return <h1>Hello {data[props.name]}</h1>;\n} If you want to know more check this out.",
    "titles": [
      "Middleware"
    ]
  },
  {
    "id": "/building-your-application/routing/pages-and-layouts#pages-and-layouts",
    "title": "Pages and Layouts",
    "text": "The Pages Router has a file-system based router built on the concept of pages (like Next.js pages folder). When a file is added to the pages directory, it's automatically available as a route. In Brisa framework, a page is a Brisa Server Component exported from a .js, .jsx, .ts, or .tsx file in the pages directory. Each page is associated with a route based on its file name. Example: If you create pages/about.js that exports a Brisa component like below, it will be accessible at /about. export default function About() {\n  return <div>About</div>;\n} See the difference between Brisa Components and React Components here.",
    "titles": []
  },
  {
    "id": "/building-your-application/routing/pages-and-layouts#index-routes",
    "title": "Index routes",
    "text": "The router will automatically route files named index to the root of the directory. pages/index.js â†’ /\npages/blog/index.js â†’ /blog",
    "titles": [
      "Pages and Layouts"
    ]
  },
  {
    "id": "/building-your-application/routing/pages-and-layouts#nested-routes",
    "title": "Nested routes",
    "text": "The router supports nested files. If you create a nested folder structure, files will automatically be routed in the same way still. pages/blog/first-post.js â†’ /blog/first-post\npages/dashboard/settings/username.js â†’ /dashboard/settings/username",
    "titles": [
      "Pages and Layouts"
    ]
  },
  {
    "id": "/building-your-application/routing/pages-and-layouts#pages-with-dynamic-routes",
    "title": "Pages with Dynamic Routes",
    "text": "Brisa supports pages with dynamic routes. For example, if you create a file called pages/posts/[id].js, then it will be accessible at posts/1, posts/2, etc. To learn more about dynamic routing, check the Dynamic Routing documentation.",
    "titles": [
      "Pages and Layouts"
    ]
  },
  {
    "id": "/building-your-application/routing/pages-and-layouts#layout",
    "title": "Layout",
    "text": "The global layout is defined inside /src/layout/index. By default Brisa supports a default layout, but you can modify it here. import { RequestContext } from \"brisa\";\n\nexport default function Layout(\n  { children }: { children: JSX.Element },\n  { route }: RequestContext\n) {\n  return (\n    <html>\n      <head>\n        <title>My layout</title>\n        <link rel=\"icon\" href=\"favicon.ico\" />\n      </head>\n      <body>{children}</body>\n    </html>\n  );\n} It must have the same structure: html, head and body. If for example you forget to put the head, you may have issues and you will be alerted with an error during development. All the components of Brisa (pages and layouts included), apart from the props, receive a second argument which is the context of the request, apart from having access to the request, you have access to a series of extra information such as the route of the page. In the layouts, having access to the page route is very useful to create different layouts. Once you have defined the layout, you don't have to import it into your pages, it will automatically be applied to all pages. To apply different layouts to different pages, take a look at multi-layouts.",
    "titles": [
      "Pages and Layouts"
    ]
  },
  {
    "id": "/building-your-application/routing/pages-and-layouts#example-of-multi-layouts",
    "title": "Example of multi-layouts",
    "text": "import { type RequestContext } from \"brisa\";\nimport UserLayout from './user-layout'\nimport GlobalLayout from './global-layout'\n\nexport default function Layout({ children }: { children: JSX.Element }, { route }: RequestContext) {\n  // pathname: /en/user/aralroca/settings or /es/usuario/pepe\n  if(route.name.startsWith('/user/[username]')) {\n    return <UserLayout>{children}<UserLayout>\n  }\n\n  return <GlobalLayout>{children}</GlobalLayout>\n}",
    "titles": [
      "Pages and Layouts",
      "Layout"
    ]
  },
  {
    "id": "/building-your-application/routing/pages-and-layouts#data-fetching",
    "title": "Data Fetching",
    "text": "Inside your layout, you can fetch data directly with fetch, in the same way that you can do it in pages: import { RequestContext } from \"brisa\";\n\nexport default async function Layout(\n  { children }: { children: JSX.Element },\n  { route }: RequestContext\n) {\n  const data = await fetch(/* data url */).then((r) => r.json());\n\n  return (\n    <html>\n      <head>\n        <title>My layout</title>\n        <link rel=\"icon\" href=\"favicon.ico\" />\n      </head>\n      <body>{children}</body>\n    </html>\n  );\n} The fetch is directly native and has no wrapper to control the cache. We recommend that you do not do the same fetch in several places, but use the store to store the data and consume it from any component. async generators are also supported if you want to stream every item in a list for example:\nasync function* List() {\n  yield <li>{await foo()}</li>;\n  yield <li>{await bar()}</li>;\n  yield <li>{await baz()}</li>;\n}\n\nThis can be used as a server component:\nreturn <List />;\n\nAnd the HTML is resolved via streaming.",
    "titles": [
      "Pages and Layouts"
    ]
  },
  {
    "id": "/building-your-application/routing/pages-and-layouts#response-headers-in-layouts-and-pages",
    "title": "Response headers in layouts and pages",
    "text": "The responseHeaders function can be exported inside the layout and inside any page. In the same way that is possible to export it also in the middleware. All responseHeaders will be mixed in this order: middleware response headers\nlayout response headers (can crush the middleware response headers)\npage response headers (both middleware and layout response headers can be mixed). import { type RequestContext } from \"brisa\";\n\nexport function responseHeaders(\n  request: RequestContext,\n  responseStatus: number,\n) {\n  return {\n    \"Cache-Control\": \"public, max-age=3600\",\n    \"Content-Security-Policy\": \"script-src 'self' 'unsafe-inline';\",\n    \"X-Example\": \"This header is added from layout\",\n  };\n}\n\n\n\nexport function responseHeaders(request, responseStatus) {\n  return {\n    \"Cache-Control\": \"public, max-age=3600\",\n    \"Content-Security-Policy\": \"script-src 'self' 'unsafe-inline';\",\n    \"X-Example\": \"This header is added from layout\",\n  };\n}",
    "titles": [
      "Pages and Layouts"
    ]
  },
  {
    "id": "/building-your-application/routing/pages-and-layouts#head",
    "title": "Head",
    "text": "The Head is a method that you can export in the pages to overwrite any element of the <head> tag. If for example you have the title defined in the layout but in the page /about-us you want to put a different title. You can use the same id to override the title of the layout: export function Head({}, { route }: RequestContext) {\n  return (\n    <>\n      <title id=\"title\">About us</title>\n      <link rel=\"canonical\" href=\"https://my-web.com\" />\n    </>\n  );\n}\n\nexport default function AboutUsPage() {\n  // ...\n} If you want to mash existing head fields (title, link, meta, etc) because you already have them defined in the layout, you must use the id attribute in both parts, and only this one will be rendered. On pages that do not overwrite it, the one in the layout will be rendered.",
    "titles": [
      "Pages and Layouts"
    ]
  },
  {
    "id": "/building-your-application/routing/pages-and-layouts#share-data-between-middleware-layout-page-component-responseheaders-head-web-components",
    "title": "Share data between middleware â†’ layout â†’ page â†’ component â†’ responseHeaders â†’ Head â†’ web-components",
    "text": "You can share data between different parts of the application using the request context. import { type RequestContext } from \"brisa\";\n\nexport default async function Layout({}, request: RequestContext) {\n  const data = await getData(request);\n\n  request.store.set(\"data\", data);\n\n  return (\n    <html>\n      <head>\n        <title>My page</title>\n        <link rel=\"icon\" href=\"favicon.ico\" />\n      </head>\n      <body>{children}</body>\n    </html>\n  );\n} import { type RequestContext } from \"brisa\";\n\ntype Props = {\n  name: string;\n};\n\nexport default function SomeComponent(props: Props, { store }: RequestContext) {\n  const data = store.get(\"data\");\n\n  return <h1>Hello {data[props.name]}</h1>;\n}",
    "titles": [
      "Pages and Layouts"
    ]
  },
  {
    "id": "/building-your-application/routing/pages-and-layouts#transfer-data-to-client-web-components",
    "title": "Transfer data to client (web-components):",
    "text": "This data is only available on the server. So you can store sensitive data without worrying. However, you can transfer certain data to the client side (web-components) using store.transferToClient method. import { type RequestContext } from \"brisa\";\n\nexport default async function Layout({}, request: RequestContext) {\n  const data = await getData(request);\n\n  request.store.set(\"data\", data);\n\n  // Transfer \"data\" from store to client\n  request.store.transferToClient([\"data\"]);\n\n  return (\n    <html>\n      <head>\n        <title>My page</title>\n        <link rel=\"icon\" href=\"favicon.ico\" />\n      </head>\n      <body>{children}</body>\n    </html>\n  );\n} This allows access to these values from the web components store. This setup also enables subsequent server actions to access the same store, as the communication flows through the client: server render â†’ client â†’ server action â†’ client It is a way to modify in a reactive way from a server action the web components that consume this store. You can encrypt store data if you want to transfer sensitive data to the server actions so that it cannot be accessed from the client.",
    "titles": [
      "Pages and Layouts",
      "Share data between middleware â†’ layout â†’ page â†’ component â†’ responseHeaders â†’ Head â†’ web-components"
    ]
  },
  {
    "id": "/building-your-application/routing/pages-and-layouts#consume-data-on-client-web-components",
    "title": "Consume data on client (web-components):",
    "text": "In the web-components instead of the RequestContext, there is the WebContext, where you have a different store, but if you have transferred the data from the RequestContext store, you will be able to consume it from the WebContext store. import { WebContext } from \"brisa\";\n\nexport default function WebComponent({}, { store }: WebContext) {\n  return <button onClick={() => alert(store.get(\"example\"))}>Click</button>;\n} If you want to know more about store check this out.",
    "titles": [
      "Pages and Layouts",
      "Share data between middleware â†’ layout â†’ page â†’ component â†’ responseHeaders â†’ Head â†’ web-components"
    ]
  },
  {
    "id": "/building-your-application/routing/sitemap#sitemap",
    "title": "Sitemap",
    "text": "A sitemap is a file that lists the URLs for a site. It allows devs to include additional information about each URL: when it was last updated, how often it changes, and how important it is in relation to other URLs in the site. This information helps search engines crawl your site more intelligently. To create the sitemap.xml file during the build process, you can create this file in your project: src/sitemap.ts\nsrc/sitemap.js\nsrc/sitemap/index.ts\nsrc/sitemap/index.js The sitemap.xml file will be generated in the root of the output directory. And this generation only happens in production mode. You can try it with brisa build && brisa start. In order that the sitemap.xml file works, you need to add to your src/public/robots.txt file the following line:\nSitemap: https://example.com/sitemap.xml\n\nNote: Replace https://example.com with your domain.",
    "titles": []
  },
  {
    "id": "/building-your-application/routing/sitemap#example-of-srcsitemapts",
    "title": "Example of src/sitemap.ts",
    "text": "import type { Sitemap } from \"brisa\";\n\nexport default [{\n  loc: \"https://example.com\",\n  lastmod: \"2021-10-01T00:00:00.000Z\",\n  changefreq: \"daily\",\n  priority: 1.0,\n  images: [\n    {\n      loc: \"https://example.com/image.jpg\",\n      title: \"Image title\",\n      caption: \"Image caption\",\n    },\n  ],\n}] as Sitemap; The generated sitemap.xml will be: sitemap.xml <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<urlset xmlns=\"http://www.sitemaps.org/schemas/sitemap/0.9\">\n  <url>\n    <loc>https://example.com</loc>\n    <lastmod>2021-10-01T00:00:00.000Z</lastmod>\n    <changefreq>daily</changefreq>\n    <priority>1.0</priority>\n    <image:image>\n      <image:loc>https://example.com/image.jpg</image:loc>\n      <image:title>Image title</image:title>\n      <image:caption>Image caption</image:caption>\n    </image:image>\n  </url>\n</urlset>",
    "titles": [
      "Sitemap"
    ]
  },
  {
    "id": "/building-your-application/routing/sitemap#lets-make-it-simpler",
    "title": "Let's make it simpler",
    "text": "Many times there is a lot of additional information that we don't want, if this is your case, that you only want the <loc>, you can use the fileSystemRouter from Brisa: import path from \"node:path\";\nimport type { Sitemap } from \"brisa\";\nimport { fileSystemRouter } from \"brisa/server\";\n\nconst { routes } = fileSystemRouter({ dir: \n  path.join(import.meta.dirname, \"pages\") \n});\n\nconsole.log(routes);\n// [\n//   ['/', '/Users/aralroca/my-app/src/pages/index.tsx'],\n//   ['/about', '/Users/aralroca/my-app/src/pages/about.tsx'],\n// ]\n\nexport default routes.map(([pathname]) => ({\n  loc: `https://example.com${pathname}`,\n})) satisfies Sitemap; However, even if you need additional information, you can put it at the page level as you like and use the filePath of the entry that routes returns to load this extra information. Example: import path from \"node:path\";\nimport type { Sitemap } from \"brisa\";\nimport { fileSystemRouter } from \"brisa/server\";\n\nconst { routes } = fileSystemRouter({ \n  dir: path.join(import.meta.dirname, \"pages\") \n});\n\nasync function sitemap(): Promise<Sitemap> {\n  return Promise.all(routes.map(async ([pathname, filePath]) => ({\n    loc: `https://example.com${pathname}`,\n    ...((await import(filePath)).sitemap ?? {}),\n  })));\n}\n\nexport default sitemap(); And in your page: export const sitemap = {\n  lastmod: \"2021-10-01T00:00:00.000Z\",\n  changefreq: \"daily\",\n  priority: 1.0,\n  images: [\n    {\n      loc: \"https://example.com/image.jpg\",\n      title: \"Image title\",\n      caption: \"Image caption\",\n    },\n  ],\n};",
    "titles": [
      "Sitemap"
    ]
  },
  {
    "id": "/building-your-application/routing/sitemap#map-md-content",
    "title": "Map .md content",
    "text": "In the case that your dynamic pages are linked to .md files, for example /blog/[slug].tsx that is linked to the content of src/posts/*.md, you can use the fileSystemRouter to point directly to posts and change the extension: import type { Sitemap } from 'brisa';\nimport path from 'node:path';\nimport { fileSystemRouter } from 'brisa/server';\n\nconst origin = 'https://example.com';\n\nconst pagesDir = path.join(import.meta.dirname, 'pages');\nconst postsDir = path.join(import.meta.dirname, 'posts');\n\nconst pages = fileSystemRouter({ dir: pagesDir });\nconst posts = fileSystemRouter({\n\tdir: postsDir,\n\t// Change the extension to .md\n\tfileExtensions: ['.md'],\n});\n\nconst staticPages = pages.routes\n\t.filter(([pathname]) => pathname !== '/blog/[slug]')\n\t.map(([pathname]) => ({\tloc: origin + pathname }))\n\nconst dynamicPages = posts.routes\n\t.map(([pathname]) => ({ loc: origin + '/blog' + pathname }));\n\nexport default [...staticPages, ...dynamicPages] satisfies Sitemap;",
    "titles": [
      "Sitemap"
    ]
  },
  {
    "id": "/building-your-application/routing/sitemap#types",
    "title": "Types",
    "text": "The Sitemap type is: type SitemapItem = {\n  loc: string;\n  lastmod?: string;\n  changefreq?:\n    | 'always'\n    | 'hourly'\n    | 'daily'\n    | 'weekly'\n    | 'monthly'\n    | 'yearly'\n    | 'never';\n  priority?: number;\n  images?: {\n    loc: string;\n    title?: string;\n    caption?: string;\n  }[];\n  videos?: {\n    thumbnail_loc: string;\n    title: string;\n    description: string;\n    content_loc: string;\n    player_loc: string;\n    duration?: number;\n    expiration_date?: string;\n    rating?: number;\n    view_count?: number;\n    publication_date?: string;\n    family_friendly?: string;\n    tag?: string;\n    live?: 'yes' | 'no';\n    requires_subscription?: 'yes' | 'no';\n    restriction?: string;\n    platform?: string;\n    uploader?: string;\n  }[];\n};\n\ntype Sitemap = SitemapItem[] | Promise<SitemapItem[]>;",
    "titles": [
      "Sitemap"
    ]
  },
  {
    "id": "/building-your-application/routing/static-assets#static-assets-in-public",
    "title": "Static Assets in public",
    "text": "Brisa can serve static files, like images, under a folder called public in the src directory. Files inside src/public can then be referenced by your code starting from the base URL (/). For example, the file src/public/images/cat.png can be viewed by visiting the /images/cat.png path. The code to display that image might look like: export function Cat({ id, alt }) {\n  return (\n    <img\n      src={`/images/${id}.png`}\n      alt={alt}\n      class=\"cat\"\n      loading=\"lazy\"\n      width=\"64\"\n      height=\"64\"\n    />\n  );\n} The folder is also useful for robots.txt, favicon.ico, Google Site Verification, and any other static files (including .html). But make sure to not have a static file with the same name as a file in the pages/ directory, as this will result in an error. We recommend to create subfolders to avoid conflicts with page names: src/public/assets or /src/public/images, src/public/fonts, etc.",
    "titles": []
  },
  {
    "id": "/building-your-application/routing/static-assets#compression-applied-to-static-assets",
    "title": "Compression applied to static assets",
    "text": "Brisa by default don't compresses static assets in the public folder using Brotli and Gzip. But you can activate this feature by setting the assetCompression configuration to true in the brisa.config.ts file. import type { Configuration } from \"brisa\";\n\nexport default {\n  assetCompression: true,\n} satisfies Configuration; This is done at build time, so the server doesn't need to compress the files on the fly and can serve the compressed files directly to the browser. When a browser requests a file, it sends an Accept-Encoding header to tell the server which compression algorithms it supports. The server then sends the file compressed with the best algorithm supported by the browser.",
    "titles": [
      "Static Assets in public"
    ]
  },
  {
    "id": "/building-your-application/routing/static-assets#gzip",
    "title": "Gzip",
    "text": "Gzip is a widely supported compression algorithm that reduces the size of files by up to 70%. It's supported by all modern browsers and is the most common compression algorithm used on the web.",
    "titles": [
      "Static Assets in public",
      "Compression applied to static assets"
    ]
  },
  {
    "id": "/building-your-application/routing/static-assets#brotli",
    "title": "Brotli",
    "text": "Brotli is a newer compression algorithm developed by Google that can reduce file sizes by up to 30% more than Gzip. It's supported by all modern browsers. Compression is only applied in production mode when assetCompression is set to true. In development mode, files are served uncompressed to make debugging easier.",
    "titles": [
      "Static Assets in public",
      "Compression applied to static assets"
    ]
  },
  {
    "id": "/building-your-application/routing/suspense-and-streaming#suspense-and-streaming",
    "title": "Suspense and Streaming",
    "text": "Each component (server-component and web-component) allows an extension to add a suspense component to it, which is the fallback that will be displayed while the component loads. SomeComponent.suspense = ({}, { i18n }) => {\n  return <div>{i18n.t('loading-message')...}</div>\n}",
    "titles": []
  },
  {
    "id": "/building-your-application/routing/suspense-and-streaming#suspense-during-streaming",
    "title": "Suspense during Streaming",
    "text": "The HTML of the page is served with small chunks during the streaming. Streaming is particularly beneficial when you want to prevent long data requests from blocking the page from rendering as it can reduce the Time To First Byte (TTFB) and First Contentful Paint (FCP). It also helps improve Time to Interactive (TTI), especially on slower devices. If there is no suspense: It will wait to load each component and will be sending the HTML chunks returned by each component. If some component has suspense: This component will not block other components, it will show the fallback that returns the suspense (pending state) and once it is loaded the content is replaced on the fly during the streaming.",
    "titles": [
      "Suspense and Streaming"
    ]
  },
  {
    "id": "/building-your-application/routing/suspense-and-streaming#example",
    "title": "Example",
    "text": "In this example we are registering suspense to display a loading state meanwhile the user of SomeComponent is not loaded. After add the suspense it does not block and keeps sending more chunks of the HTML while the component is loading. Once the component is loaded then the fallback will be replaced by the original content. In case it fails, we could also display another type of content using the error component extension. // src/components/some-component.tsx\nimport { type RequestContext } from \"brisa\";\n\n// If it does not have the suspense, it waits to show the content, otherwise, it puts it in suspense and is displayed once is available\nexport default async function SomeComponent({}, { store, i18n }: RequestContext) {\n  const { t } = i18n\n  const user = await getUser();\n  const message = t('hello-username', { username: user.username })\n\n  // Save user inside the store to avoid prop drilling\n  store.set('user', user);\n\n  return <Card title={message}><UserContent /></Card>\n}\n\n// Adding suspense:\n// Rendering this meanwhile SomeComponent is pending\nSomeComponent.suspense = ({}, { i18n }: RequestContext) => {\n  return <div>{i18n.t('loading-message')...}</div>\n}\n\n// Rendering this when throws an error\nSomeComponent.error = ({ error }) => {\n  return <div>Oops! {error.message}</div>\n}\n\n\n\n// src/components/some-component.jsx\n\n// If it does not have the suspense, it waits to show the content, otherwise, it puts it in suspense and is displayed once is available\nexport default async function SomeComponent({}, { store, i18n }) {\n  const user = await getUser();\n  const message = i18n.t('hello-username', { username: user.username })\n\n  // Save user inside the store to avoid prop drilling\n  store.set('user', user);\n\n  return <Card title={message}><UserContent /></Card>\n}\n\n// Adding suspense:\n// Rendering this meanwhile SomeComponent is pending\nSomeComponent.suspense = ({}, { i18n }) => {\n  return <div>{i18n.t('loading-message')...}</div>\n}\n\n// Rendering this when throws an error\nSomeComponent.error = ({ error }) => {\n  return <div>Oops! {error.message}</div>\n}",
    "titles": [
      "Suspense and Streaming",
      "Suspense during Streaming"
    ]
  },
  {
    "id": "/building-your-application/routing/suspense-and-streaming#seo",
    "title": "SEO",
    "text": "Since streaming is server-rendered, it does not impact SEO. You can use the Mobile Friendly Test tool from Google to see how your page appears to Google's web crawlers and view the serialized HTML (source).",
    "titles": [
      "Suspense and Streaming",
      "Suspense during Streaming"
    ]
  },
  {
    "id": "/building-your-application/routing/suspense-and-streaming#suspense-differences-between-serverweb-components",
    "title": "Suspense differences between server/web components",
    "text": "Both server/web components use suspense during streaming.",
    "titles": [
      "Suspense and Streaming"
    ]
  },
  {
    "id": "/building-your-application/routing/suspense-and-streaming#suspense-in-web-components",
    "title": "Suspense in Web-components",
    "text": "By default all web-components are Server Side Rendered. Unless you use the skipSSR={true} attribute when consuming it: <my-web-component skipSSR /> Web-components have another benefit of suspense, and that is that it is applied dynamically as well, this means that if you have web-components that are not displayed in the initial HTML but are dynamically displayed later after a user interaction and need to do something asynchronous to load data, the content defined in the \"suspense\" will be displayed while loading this data. src/web-components/my-web-component.tsx: export default async function MyWebComponent({}, { state }) {\n  const foo = await fetch(/* ... */).then((r) => r.text());\n\n  return <div>{foo}</div>;\n}\n\nMyWebComponent.suspense = (props, webContext) => <div>loading...</div>; You can do a fetch in the render because in Brisa there are no rerenders, so it will always run only once mouting the component. Another benefit of web-components is the suspense defined therein is reactive to props, state, context and store. So you can make it interactive from the client if you need to. Example displaying different texts during suspense using store: import { WebContext } from \"brisa\";\n\nexport default async function MyWebComponent({}, { store }: WebContext) {\n  store.set(\"suspense-message\", \"Loading step 1 ...\");\n  const firstResponse = await fetch(/* ... */);\n  store.set(\"suspense-message\", \"Loading step 2 ...\");\n  const secondResponse = await fetch(/* ... */);\n\n  return (\n    <div>\n      {firstResponse.foo} {secondResponse.bar}\n    </div>\n  );\n}\n\n// Display reactive messages from context during the suspense phase:\nMyWebComponent.suspense = ({}, { store }: WebContext) => {\n  return store.get(\"suspense-message\");\n}; Also works during streaming. Although loading data is done at the client-side. That is, the suspense is rendered on the server with SSR, and on the client-side the real component is loaded by updating the suspense phase until it has the content. That is, these fetch inside the component will never be done from the server in the case of web-components.",
    "titles": [
      "Suspense and Streaming",
      "Suspense differences between server/web components"
    ]
  },
  {
    "id": "/building-your-application/routing/suspense-and-streaming#transitions-between-suspense-content",
    "title": "Transitions between suspense-content",
    "text": "There is an important difference between the web and server components when it comes to making transitions between the suspense phase and the real content. The suspense phase by default does not support animations as it is replaced by the real content, so if you need to implement animations during these phases you can do it with two different strategies.",
    "titles": [
      "Suspense and Streaming",
      "Suspense differences between server/web components"
    ]
  },
  {
    "id": "/building-your-application/routing/suspense-and-streaming#first-strategy-using-store-signals-web-components",
    "title": "First strategy: Using store signals (Web Components)",
    "text": "The first strategy is to continue using the suspense offered by Brisa but use the store to communicate between the two phases. import type { WebContext } from \"brisa\";\n\nexport default async function WebComponent({}, { store }: WebContext) {\n  // Wait the delay (fetch, whatever)\n  const data = await fetch(/* */).then((r) => r.json());\n\n  // Start the animation to replace the content\n  await transitionOnSuspense(store, 200);\n\n  return <div class=\"start\">{data.content}</div>;\n}\n\nWebComponent.suspense = ({}, { store }: WebContext) => {\n  return (\n    <div class={store.get(\"content-ready\") ? \"exit\" : \"\"}>Loading ....</div>\n  );\n};\n\nasync function transitionOnSuspense(store: WebContext[\"store\"], duration) {\n  store.set(\"content-ready\", true);\n  // Wait for the suspense transition to finish\n  await new Promise((resolve) => setTimeout(resolve, duration));\n} Example of css: @keyframes start {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n\n@keyframes exit {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n\n.exit {\n  animation: exit 200ms;\n}\n.start {\n  animation: start 200ms;\n} Only works in Web Components.",
    "titles": [
      "Suspense and Streaming",
      "Suspense differences between server/web components",
      "Transitions between suspense-content"
    ]
  },
  {
    "id": "/building-your-application/routing/suspense-and-streaming#second-strategy-using-async-generators-server-components",
    "title": "Second strategy: Using async generators (Server Components)",
    "text": "The second strategy is instead of using the suspense that Brisa offers, to use the async generator together with the css helper to inject styles after the suspense phase to hide them with an animation. import type { RequestContext } from \"brisa\";\n\nasync function* ServerComponent({}, { css }: RequestContext) {\n  yield <div class=\"suspense\">Loading ....</div>;\n\n  // Wait the delay (fetch, whatever)\n  const data = await fetch(/* */).then((r) => r.json());\n\n  // Start the animation to replace the content\n  css`\n    @keyframes slideaway {\n      from {\n        display: block;\n      }\n      to {\n        transform: translateY(40px);\n        opacity: 0;\n      }\n    }\n\n    .suspense {\n      animation: slideaway 200ms;\n      display: none;\n    }\n\n    @keyframes slidein {\n      from {\n        transform: translateY(40px);\n        opacity: 1;\n      }\n      to {\n        display: block;\n      }\n    }\n\n    .content {\n      animation: slidein 200ms;\n    }\n  `;\n\n  // Yield the real content\n  yield <div class=\"content\">{data.content}</div>;\n} Only works in Server Components.",
    "titles": [
      "Suspense and Streaming",
      "Suspense differences between server/web components",
      "Transitions between suspense-content"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#real-time-communication-with-websockets",
    "title": "Real-time Communication with Websockets",
    "text": "Websockets provide a powerful mechanism for establishing a full-duplex communication channel between a client and a server. This enables real-time updates and interactions in your application. Brisa supports server-side WebSockets, with on-the-fly compression, TLS support, and a Bun-native publish-subscribe API. Bun's WebSockets are fast, ~700,000 messages sent per second. This WebSockets documentation only works with the Bun.js runtime. If you want to use Node.js as output you will have to implement it with some library in this same file, look here how to do it.",
    "titles": []
  },
  {
    "id": "/building-your-application/routing/websockets#start-a-websocket-server-api",
    "title": "Start a WebSocket server API",
    "text": "For this purpose it is necessary to create the file src/websocket.(ts|js) (or src/websocket/index.(ts|js)) and you can export these functions: import { ServerWebSocket } from \"bun\";\n\nexport function attach(request: Request) {\n  // attach contextual data to the ws.data\n  return { foo: \"foo\" }; // ws.data.foo\n}\n\nexport function message(ws: ServerWebSocket, message: string) {\n  // a message is received\n}\n\nexport function open(ws: ServerWebSocket) {\n  // a socket is opened\n}\n\nexport function close(ws: ServerWebSocket) {\n  // a socket is closed\n}\n\nexport function drain(ws: ServerWebSocket) {\n  // the socket is ready to receive more data\n} These handlers are declared once per server, instead of per socket. So, instead of using an event-based API it is reused for each connection, this leads to less memory usage and less time spent adding/removing event listeners.",
    "titles": [
      "Real-time Communication with Websockets"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#attach",
    "title": "attach",
    "text": "The attach function is responsible for attaching contextual data to the ws.data property of the WebSocket. Before a WebSocket connection is established, this function is invoked, providing access to the initial request (Request). You can use this function to associate relevant information or metadata with the WebSocket connection. export function attach(request: Request) {\n  const cookies = parseCookies(req.headers.get(\"Cookie\"));\n\n  return {\n    createdAt: Date.now(),\n    channelId: new URL(req.url).searchParams.get(\"channelId\"),\n    authToken: cookies[\"X-Token\"],\n  },\n} This information will be accessible through ws.data.",
    "titles": [
      "Real-time Communication with Websockets",
      "Start a WebSocket server API"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#message",
    "title": "message",
    "text": "The message function is triggered whenever a message is received on the WebSocket connection. It accepts two parameters: ws (the ServerWebSocket instance) and message (the received message as a string). You can implement logic within this function to handle and process incoming messages. The message function provides the means to respond to client messages in real-time and execute corresponding actions based on the content of the received message.",
    "titles": [
      "Real-time Communication with Websockets",
      "Start a WebSocket server API"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#open",
    "title": "open",
    "text": "The open function is called when a new WebSocket connection is established and opened. It accepts one parameters: ws (the ServerWebSocket instance). You can use this function to perform setup tasks or execute actions specific to the initiation of a WebSocket connection. This could include tasks such as logging, authentication, or broadcasting a welcome message to the connected client.",
    "titles": [
      "Real-time Communication with Websockets",
      "Start a WebSocket server API"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#close",
    "title": "close",
    "text": "The close function is invoked when a WebSocket connection is closed. It accepts one parameters: ws (the ServerWebSocket instance). It allows you to define cleanup procedures or perform actions specific to the closure of a WebSocket connection. For example, scenarios like logging disconnections, updating user statuses, or releasing resources related to the closed connection.",
    "titles": [
      "Real-time Communication with Websockets",
      "Start a WebSocket server API"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#drain",
    "title": "drain",
    "text": "The drain function is called when the WebSocket is ready to receive more data. It signifies that the underlying transport is available for sending additional messages. You can use this function to implement custom logic related to handling the readiness of the WebSocket to receive more data. This might include managing queues of messages to be sent or coordinating the flow of real-time updates based on the current state of the WebSocket connection.",
    "titles": [
      "Real-time Communication with Websockets",
      "Start a WebSocket server API"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#sending-messages",
    "title": "Sending messages",
    "text": "Each ServerWebSocket instance has a .send() method for sending messages to the client. It supports a range of input types. ws.send(\"Hello world\"); // string\nws.send(response.arrayBuffer()); // ArrayBuffer\nws.send(new Uint8Array([1, 2, 3])); // TypedArray | DataView You have access to the ServerWebSocket from any server-component, middleware, API route, etc. Since it is inside the RequestContext. This is an example of sending a message from an API route: src/api/hello-world.ts import { type RequestContext } from \"brisa\";\n\nexport function GET({ ws, i18n }: RequestContext) {\n  const message = i18n.t(\"hello-world\");\n\n  // Sending a WebSocket message from an API route\n  ws.send(message);\n\n  return new Response(message, {\n    headers: { \"content-type\": \"text/plain\" },\n  });\n}",
    "titles": [
      "Real-time Communication with Websockets",
      "Start a WebSocket server API"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#pubsub",
    "title": "Pub/Sub",
    "text": "Bun's ServerWebSocket implementation implements a native publish-subscribe API for topic-based broadcasting. Individual sockets can .subscribe() to a topic (specified with a string identifier) and .publish() messages to all other subscribers to that topic (excluding itself). This topic-based broadcast API is similar to MQTT and Redis Pub/Sub. src/websocket.ts export function open(ws) {\n  const msg = `${ws.data.username} has entered the chat`;\n  ws.subscribe(\"the-group-chat\");\n  ws.publish(\"the-group-chat\", msg);\n}\n\nexport function message(ws, message) {\n  // this is a group chat\n  // so the server re-broadcasts incoming message to everyone\n  ws.publish(\"the-group-chat\", `${ws.data.username}: ${message}`);\n}\n\nexport function close(ws) {\n  const msg = `${ws.data.username} has left the chat`;\n  ws.unsubscribe(\"the-group-chat\");\n  ws.publish(\"the-group-chat\", msg);\n} Calling ws.publish(data) will send the message to all subscribers of a topic except the socket that called ws.publish(). To send a message to all subscribers of a topic, use the server.publish() method on the Server instance. You can get the server instance via globalThis.brisaServer: const server = globalThis.brisaServer;\nserver.publish(\"send-message-to-all-subscribers\", msg);",
    "titles": [
      "Real-time Communication with Websockets",
      "Start a WebSocket server API"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#compression",
    "title": "Compression",
    "text": "Compression can be enabled for individual messages by passing a boolean as the second argument to .send() or as the third argument to .publish(). ws.send(message, true);\nws.publish(topic, message, true);",
    "titles": [
      "Real-time Communication with Websockets",
      "Start a WebSocket server API"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#backpressure",
    "title": "Backpressure",
    "text": "The .send(message) method of ServerWebSocket returns a number indicating the result of the operation. -1 â€” The message was enqueued but there is backpressure\n0 â€” The message was dropped due to a connection issue\n1+ â€” The number of bytes sent This gives you better control over backpressure in your server.",
    "titles": [
      "Real-time Communication with Websockets",
      "Start a WebSocket server API",
      "Compression"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#start-a-websocket-client-api",
    "title": "Start a WebSocket client API",
    "text": "Starting a WebSocket client in Brisa involves using the WebSocket Web API:",
    "titles": [
      "Real-time Communication with Websockets"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#connect-to-websocket-server",
    "title": "Connect to WebSocket Server",
    "text": "To establish a connection to the WebSocket server, you can use the standard WebSocket API in the browser. The following example demonstrates how to initiate a connection in a browser environment: const ws = new WebSocket(\"wss://your-server.com\");",
    "titles": [
      "Real-time Communication with Websockets",
      "Start a WebSocket client API"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#handle-websocket-events-inside-web-components",
    "title": "Handle WebSocket Events inside Web-components",
    "text": "WebSocket connections trigger various events during their lifecycle. To react to these events, you can attach event listeners to the WebSocket instance. Common events include open, message, close, and error. The following snippet illustrates how to handle these events: // Event listener for when the connection is established\nws.addEventListener(\"open\", (event) => {\n  console.log(\"WebSocket connection opened:\", event);\n});\n\n// Event listener for incoming messages\nws.addEventListener(\"message\", (event) => {\n  console.log(\"Received message:\", event.data);\n});\n\n// Event listener for when the connection is closed\nws.addEventListener(\"close\", (event) => {\n  console.log(\"WebSocket connection closed:\", event);\n});\n\n// Event listener for errors\nws.addEventListener(\"error\", (event) => {\n  console.error(\"WebSocket error:\", event);\n}); WebSocket connections may not persist indefinitely. Various factors, such as network issues, server restarts, or client-side disruptions, can lead to the termination of WebSocket connections. It is crucial to implement appropriate error handling and reconnection strategies on the client side to gracefully handle unexpected disconnections.",
    "titles": [
      "Real-time Communication with Websockets",
      "Start a WebSocket client API"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#send-messages-to-server",
    "title": "Send Messages to Server",
    "text": "You can send messages to the WebSocket server using the send method. The following example demonstrates how to send a simple text message: ws.send(\"Hello, server!\");",
    "titles": [
      "Real-time Communication with Websockets",
      "Start a WebSocket client API"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#close-websocket-connection",
    "title": "Close WebSocket Connection",
    "text": "When you want to close the WebSocket connection, you can call the close method. Optionally, you can provide a reason and code for the closure: ws.close();\n// or\nws.close(1000, \"Closing connection gracefully\");",
    "titles": [
      "Real-time Communication with Websockets",
      "Start a WebSocket client API"
    ]
  },
  {
    "id": "/building-your-application/routing/websockets#websockets-in-nodejs",
    "title": "WebSockets in Node.js",
    "text": "If you want to use WebSockets in a Node.js environment, you can use the ws library. Here is an example of how to create a WebSocket server using the ws library in the src/websocket.ts file: src/websocket.ts const WebSocket = require('ws');\n\n// Create a WebSocket server\nconst wss = new WebSocket.Server({ port: 8080 });\n\nwss.on('connection', function connection(ws) {\n  // Log a message when a new client connects\n  console.log('A new client connected!');\n  \n  // Receive messages from the client\n  ws.on('message', function incoming(message) {\n    console.log('Received:', message);\n    \n    // Send a response back to the client\n    ws.send(`You said: ${message}`);\n  });\n\n  // Log a message when the client disconnects\n  ws.on('close', () => {\n    console.log('Client has disconnected');\n  });\n}); This src/websocket.ts file is loaded once when the server is created, if the module exports the attach, message, open, close, and drain functions, they will only be used in Bun.js, but when the file is executed in Node.js, the ws functions can be used to create a WebSocket server in Node.js.",
    "titles": [
      "Real-time Communication with Websockets"
    ]
  },
  {
    "id": "/building-your-application/styling#styling",
    "title": "Styling",
    "text": "Brisa supports different ways of styling your application, including: Global styles\nCSS Template literal\nCSS inlined in JSX\nTailwind CSS\nCSS Modules (coming soon) In addition, you can also style your web components and server components: Styling web components",
    "titles": []
  },
  {
    "id": "/building-your-application/styling/css-inlined-in-jsx#css-inlined-in-jsx",
    "title": "CSS Inlined in JSX",
    "text": "In Brisa, you can add CSS styles directly to your JSX components using the style attribute. This allows you to define styles for individual elements without creating a separate CSS file.",
    "titles": []
  },
  {
    "id": "/building-your-application/styling/css-inlined-in-jsx#adding-css-styles",
    "title": "Adding CSS Styles",
    "text": "To add CSS styles to an element in JSX, use the style attribute and pass an object with the desired styles. For example, you can add a red background color to a <div> element like this: const MyComponent = () => {\n  return (\n    <div style={{ backgroundColor: \"red\" }}>\n      Hello, world!\n    </div>\n  );\n}; In the example above, the style attribute is set to an object with the backgroundColor property set to \"red\". This will apply a red background color to the <div> element. Using TypeScript with inline styles is a great way to ensure type safety and avoid common CSS errors.",
    "titles": [
      "CSS Inlined in JSX"
    ]
  },
  {
    "id": "/building-your-application/styling/css-template-literal#css-template-literal",
    "title": "CSS Template Literal",
    "text": "In Brisa, you can add CSS styles to your components using CSS template literals. This allows you to define styles for individual elements without creating a separate CSS file.",
    "titles": []
  },
  {
    "id": "/building-your-application/styling/css-template-literal#adding-css-styles",
    "title": "Adding CSS Styles",
    "text": "To add CSS styles to an element using a template literal, create a template string with the desired styles. For example, you can add a red background color to a <div> element like this: export default const MyWebComponent = ({}, { css }) => {\n  css`\n    div {\n      background-color: red;\n    }\n  `;\n\n  return (\n    <div>\n      Hello, world!\n    </div>\n  );\n}; In Brisa, you can use CSS template literals with both Web Components and Server Components. Web Components encapsulate their styles, while Server Components do not. This means that styles defined with CSS template literals in a Web Component will only apply to that component, while styles defined in a Server Component will apply globally to all components on the page.",
    "titles": [
      "CSS Template Literal"
    ]
  },
  {
    "id": "/building-your-application/styling/global-styles#global-styles",
    "title": "Global Styles",
    "text": "Global styles are CSS rules that apply to all elements on your website. You can use global styles to set the default font, color, and other styles for your website. In Brisa, you can add global styles to your website by creating a CSS file and importing it into your layout component.",
    "titles": []
  },
  {
    "id": "/building-your-application/styling/global-styles#adding-global-styles",
    "title": "Adding Global Styles",
    "text": "To add global styles to your website, create a CSS file in the src directory of your project. For example, you can create src/styles/global.css with the following content: body {\n  font-family: Arial, sans-serif;\n  color: #333;\n} Next, import the CSS file in the src/layout.tsx file: import \"@/styles/global.css\"; Now, the styles defined in the global.css file will be applied to all pages on your website.",
    "titles": [
      "Global Styles"
    ]
  },
  {
    "id": "/building-your-application/styling/tailwind-css#tailwind-css",
    "title": "Tailwind CSS",
    "text": "One option in Brisa is to integrate your app with Tailwind CSS, a CSS framework that lets you use utility classes instead of writing CSS. These utility classes are mostly one-to-one with a certain CSS property setting: for example, adding the text-lg to an element is equivalent to setting font-size: 1.125rem in CSS. You might find it easier to write and maintain your styles using these predefined utility classes! Then you can use in your .tsx: export default function Home() {\n  return (\n    <div className=\"text-lg\">Hello, world!</div>\n  );\n} To integrate Tailwind CSS into your Brisa project, take a look at the integration with Tailwind CSS in the integrations section.",
    "titles": []
  },
  {
    "id": "/building-your-application/styling/web-components#styling-web-components",
    "title": "Styling Web Components",
    "text": "Brisa provides a different ways to style your web components, including: Global Styles in Web Components: By default, Brisa adopts the global style sheets to the shadow DOM, so you don't need to worry about this.\nCSS Template String: A powerful way to create reactive styles to signals within web components.\nCSS inlined in JSX: You can use the style attribute to apply styles directly to the HTML element.\nTailwind CSS: A CSS framework that lets you use utility classes instead of writing CSS.",
    "titles": []
  },
  {
    "id": "/building-your-application/styling/web-components#global-styles-in-web-components",
    "title": "Global Styles in Web Components",
    "text": "Web components by default encapsulate their styles inside their shadow DOM, the downside of this is that you can't style them from the outside, so global styles won't affect them. In Brisa, we adopted by default the global style sheets to the shadow DOM, in this way works more like others frameworks like React or Vue and you don't need to worry about this. To apply global styles, you need to import the CSS file in the src/layout.tsx file: import \"./global.css\"; For more information about global styles, check the Global Styles page. However, if you want to disable the automatic adopted global style sheets, you can do it by resetting the adoptedStyleSheets property: import type { WebContext } from \"brisa\";\n\nexport default function MyWebComponent({}, { self, css }: WebContext) {\n  // Turn off the automatic adopted global style sheets (also work in SSR)\n  self.shadowRoot.adoptedStyleSheets = [];\n\n  // It only applies this encapsulated style:\n  css`\n    div {\n      color: red;\n    }\n  `;\n\n  // It doesn't apply the \"div\" styles defined in the\n  // global style sheets, only the ones defined in the\n  // CSS template literal will be applied\n  return <div>Hello World</div>;\n} You can use the self object to access the shadow DOM and manipulate it directly. During SSR, the self object is an object with an empty shadowRoot, but when you add an empty array on adoptedStyleSheets property, it will disable the automatic adopted global style sheets on Declarative Shadow DOM too.",
    "titles": [
      "Styling Web Components"
    ]
  },
  {
    "id": "/building-your-application/styling/web-components#css-template-string",
    "title": "CSS Template String",
    "text": "The CSS template string is a powerful way to create reactive styles to signals within web components. It allows you to define styles in a template literal and use the css tag to apply them to the shadow DOM. import type { WebContext } from \"brisa\";\n\nexport default function MyWebComponent({ color }, { css }: WebContext) {\n  css`\n    div {\n      color: ${color};\n    }\n  `;\n\n  return <div>Hello World</div>;\n} In this example, the color prop is reactive, so when it changes, the style will be updated accordingly. Also useful to create animations, hover effects, and more. You can use tag names directly in the CSS template string because is scoped to the shadow DOM, so you don't need to worry about naming conflicts with other components, or outside styles. For more information about CSS template string, check the CSS Template Literal page.",
    "titles": [
      "Styling Web Components"
    ]
  },
  {
    "id": "/building-your-application/styling/web-components#tailwind-css",
    "title": "Tailwind CSS",
    "text": "The shadow DOM is adapted to be possible to use Tailwind CSS classes in your elements. import type { WebContext } from \"brisa\";\n\nexport default function MyWebComponent() {\n  return <div className=\"bg-gray-100\">Hello World</div>;\n} Read more about how to integrate Tailwind CSS in your Brisa project in the Tailwind CSS page.",
    "titles": [
      "Styling Web Components"
    ]
  },
  {
    "id": "/building-your-application/testing/introduction#testing-introduction",
    "title": "Testing Introduction",
    "text": "Brisa utilizes the Bun test runner to execute tests, coupled with @happy-dom/global-registrator for DOM manipulation within the tests. Additionally, Brisa exposes a testing API and extends test matchers with to streamline integration with components in the tests. Take a look at the Bun test runner documentation for more information on how to run tests and the available options.",
    "titles": []
  },
  {
    "id": "/building-your-application/testing/introduction#getting-started",
    "title": "Getting started",
    "text": "To use tests in Brisa, you need to have the bunfig.toml file on the root of the project with this configuration: [test]\npreload = \"brisa/test\" This allows to preload all the matchers from Brisa and it will also take care of initializing happy-dom library to manipulate the DOM.",
    "titles": [
      "Testing Introduction"
    ]
  },
  {
    "id": "/building-your-application/testing/introduction#testing-server-actions",
    "title": "Testing Server Actions",
    "text": "After rendering the component, you can interact with it thanks to userEvent. For example, you can simulate a click event on a button: import { render, userEvent } from \"brisa/test\";\nimport { test, mock } from \"bun:test\";\n\ntest(\"server action test\", async () => {\n  const mockServerAction = mock(() => {});\n  const { container } = await render(\n    <button onClick={mockServerAction}>Click me</button>,\n  );\n  const button = container.querySelector(\"button\");\n\n  userEvent.click(button);\n\n  expect(mockServerAction).toHaveBeenCalled();\n}); It's very similar to browser events, but it has some differences, for example in onSubmit of a form, you can access directly to event.formData, because the browser event was already handled by the RPC layer and the form was submitted to the server, converting the SubmitEvent into a FormDataEvent. import { render, userEvent } from \"brisa/test\";\nimport { test, mock } from \"bun:test\";\n\ntest(\"server action test\", async () => {\n  const mockServerAction = mock(() => {});\n  const { container } = await render(\n    <form onSubmit={(e) => mockServerAction(e.formData.get(\"name\"))}>\n      <input type=\"text\" name=\"name\" value=\"foo\" />\n      <button type=\"submit\">Submit</button>\n    </form>,\n  );\n  const form = container.querySelector(\"form\");\n\n  userEvent.submit(form);\n\n  expect(mockServerAction).toHaveBeenCalledWith(\"foo\");\n}); rerenderInAction, navigate, and other actions that change the state of the application are not available in the test environment. You can use the mock function to simulate the server action and test the component behavior.",
    "titles": [
      "Testing Introduction"
    ]
  },
  {
    "id": "/building-your-application/testing/introduction#testing-web-components",
    "title": "Testing Web Components",
    "text": "You can also test Web Components after rendering them. For example, you can test a custom element: import { render, userEvent } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\n\ntest(\"web component\", async () => {\n  const { container } = await render(<custom-counter />);\n  const counter = container.querySelector(\"custom-counter\")!.shadowRoot!;\n  const [increment, decrement] = counter.querySelectorAll(\"button\");\n\n  expect(counter).toContainTextContent(\"0\");\n\n  userEvent.click(increment);\n\n  expect(counter).toContainTextContent(\"1\");\n\n  userEvent.click(decrement);\n\n  expect(counter).toContainTextContent(\"0\");\n}); You can use the shadowRoot property to access the shadow DOM of a custom element.",
    "titles": [
      "Testing Introduction"
    ]
  },
  {
    "id": "/building-your-application/testing/introduction#testing-api-endpoints",
    "title": "Testing API Endpoints",
    "text": "You can test API endpoints using the serveRoute function. This function allows you to request a Brisa route and return the Response. These routes can be API endpoints, pages, assets, or any other type of route. Example: import { serveRoute } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\n\ntest(\"route\", async () => {\n  const response = await serveRoute(\"/api/hello\");\n  const data = await response.json();\n\n  expect(data).toEqual({ message: \"Hello, world!\" });\n}); For the pages, you can use it with the render function to render the page: import { render, serveRoute } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\n\ntest(\"page\", async () => {\n  const response = await serveRoute(\"/about\");\n  const { container } = await render(response);\n\n  expect(container).toHaveTextContent(\"About us\");\n});",
    "titles": [
      "Testing Introduction"
    ]
  },
  {
    "id": "/building-your-application/testing/introduction#types-of-tests",
    "title": "Types of tests",
    "text": "",
    "titles": [
      "Testing Introduction"
    ]
  },
  {
    "id": "/building-your-application/testing/introduction#unit-testing",
    "title": "Unit testing",
    "text": "Involves testing individual units (or blocks of code) in isolation. In Brisa, a unit can be a single function or component. Example: import { sum } from \"./sum\";\nimport { test, expect } from \"bun:test\";\n\ntest(\"sum\", () => {\n  expect(sum(1, 2)).toBe(3);\n});",
    "titles": [
      "Testing Introduction",
      "Types of tests"
    ]
  },
  {
    "id": "/building-your-application/testing/introduction#component-testing",
    "title": "Component testing",
    "text": "Is a more focused version of unit testing where the primary subject of the tests is Brisa components. This may involve testing how components are rendered, their interaction with props, and their behavior in response to user events. Example: import { render, userEvent } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\n\nfunction Button() {\n  return <button onClick={() => console.log(\"clicked\")}>Click me</button>;\n}\n\ntest(\"component\", async () => {\n  const { container } = await render(<Button />);\n  const button = container.querySelector(\"button\");\n\n  expect(button).toHaveTextContent(\"Click me\");\n\n  await userEvent.click(button);\n  expect(console.log).toHaveBeenCalledWith(\"clicked\");\n});",
    "titles": [
      "Testing Introduction",
      "Types of tests",
      "Unit testing"
    ]
  },
  {
    "id": "/building-your-application/testing/introduction#integration-testing",
    "title": "Integration testing",
    "text": "Involves testing how multiple units work together. This can be a combination of components and functions. Example: import { render, userEvent, serveRoute } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\n\ntest(\"integration\", async () => {\n  const response = await serveRoute(\"/\");\n  const { container } = await render(response);\n  const button = container.querySelector(\"button\");\n\n  expect(button).toHaveTextContent(\"Click me\");\n\n  await userEvent.click(button);\n  expect(console.log).toHaveBeenCalledWith(\"clicked\");\n}); Brisa provides a testing API to help you interact with entrypoints and test their behavior. This is not considered full E2E testing because it doesn't simulate real user scenarios like a browser would do, but it can be used to test entrypoints of your application.",
    "titles": [
      "Testing Introduction",
      "Types of tests",
      "Unit testing"
    ]
  },
  {
    "id": "/building-your-application/testing/introduction#end-to-end-e2e-testing",
    "title": "End-to-End (E2E) Testing",
    "text": "Involves testing user flows in an environment that simulates real user scenarios, like the browser. This means testing specific tasks (e.g. signup flow) in a production-like environment. Example with Playwright: import { test, expect } from \"bun:test\";\nimport { webkit } from \"playwright\"; // Or 'chromium' or 'firefox'.\n\ntest(\"e2e\", async () => {\n  const browser = await webkit.launch();\n  const context = await browser.newContext();\n  const page = await context.newPage();\n  await page.goto(\"https://example.com\");\n  await page.screenshot({ path: \"screenshot.png\" });\n  await browser.close();\n}); Brisa does not provide built-in support for E2E testing. You can use any E2E testing library like Playwright, Cypress, or Puppeteer.",
    "titles": [
      "Testing Introduction",
      "Types of tests"
    ]
  },
  {
    "id": "/building-your-application/testing/introduction#snapshot-testing",
    "title": "Snapshot testing",
    "text": "Involves capturing the rendered output of a component and saving it to a snapshot file. When tests run, the current rendered output of the component is compared against the saved snapshot. Changes in the snapshot are used to indicate unexpected changes in behavior. Example: import { render } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\n\ntest(\"snapshot\", async () => {\n  const { container } = await render(<div>Hello, World!</div>);\n  expect(container.innerHTML).toMatchSnapshot();\n}); To update snapshots, use the --update-snapshots flag. bun test --update-snapshots",
    "titles": [
      "Testing Introduction",
      "Types of tests"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#matchers",
    "title": "Matchers",
    "text": "Brisa extends the Bun testing runner with custom matchers to streamline the testing process. These matchers are designed to simplify the testing of Brisa components and their behavior.",
    "titles": []
  },
  {
    "id": "/building-your-application/testing/matchers#tohaveattribute",
    "title": "toHaveAttribute",
    "text": "Verifies whether a specified attribute exists within the target element. Example: expect(element).toHaveAttribute(\"name\", \"value\"); Types: toHaveAttribute(name: string, value?: string): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tohavetagname",
    "title": "toHaveTagName",
    "text": "Checks if the target element has a specific HTML tag. Example: expect(div).toHaveTagName(\"div\"); // pass\nexpect(span).toHaveTagName(\"div\"); // fail Types: toHaveTagName(tagName: string): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tohavetextcontent",
    "title": "toHaveTextContent",
    "text": "Ensures that the target element renders the expected text content. Example: expect(text).toHaveTextContent(\"text\"); // pass\nexpect(text).toHaveTextContent(\"xt\"); // fail Types: toHaveTextContent(text: string): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tocontaintextcontent",
    "title": "toContainTextContent",
    "text": "Verifies if the rendered text content contains a specific string. Example: expect(text).toContainTextContent(\"text\"); // pass\nexpect(text).toContainTextContent(\"xt\"); // pass Types: toContainTextContent(text: string): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tohavestyle",
    "title": "toHaveStyle",
    "text": "Validates the styling properties of the target element. Example: expect(red).toHaveStyle(\"color\", \"red\"); // pass\nexpect(red).toHaveStyle(\"color\", \"blue\"); // fail Types: toHaveStyle(property: string, value: string): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tohaveclass",
    "title": "toHaveClass",
    "text": "Checks for the presence of a specified CSS class within the target element. Example: expect(input).toHaveClass(\"form-control\"); // pass\nexpect(button).toHaveClass(\"btn-primary\"); // pass Types: toHaveClass(className: string): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tohavevalue",
    "title": "toHaveValue",
    "text": "Verifies the current value of form elements such as input fields. Example: expect(input).toHaveValue(\"example\"); Types: toHaveValue(value: string): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tohavefocus",
    "title": "toHaveFocus",
    "text": "Indicates whether the target element currently has focus. Example: expect(input).toHaveFocus();\nexpect(input).not.toHaveFocus(); Types: toHaveFocus(): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tobevisible",
    "title": "toBeVisible",
    "text": "Checks if the target element is visible within the DOM. Example: expect(element).toBeVisible();\nexpect(element).not.toBeVisible(); Types: toBeVisible(): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tobeenabled",
    "title": "toBeEnabled",
    "text": "Verifies that the target element is enabled and interactive. Example: expect(button).toBeEnabled();\nexpect(button).not.toBeEnabled(); Types: toBeEnabled(): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tobedisabled",
    "title": "toBeDisabled",
    "text": "Indicates whether the target element is disabled and non-interactive. Example: expect(button).toBeDisabled();\nexpect(button).not.toBeDisabled(); Types: toBeDisabled(): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tobechecked",
    "title": "toBeChecked",
    "text": "Checks if the target element is checked. Example: expect(checkbox).toBeChecked();\nexpect(checkbox).not.toBeChecked(); Types: toBeChecked(): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tobeselected",
    "title": "toBeSelected",
    "text": "Indicates whether the target element is selected. Example: expect(option).toBeSelected();\nexpect(option).not.toBeSelected(); Types: toBeSelected(): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#toberequired",
    "title": "toBeRequired",
    "text": "Indicates whether the target element is required. Example: expect(input).toBeRequired();\nexpect(input).not.toBeRequired(); Types: toBeRequired(): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tobeinvalid",
    "title": "toBeInvalid",
    "text": "Indicates whether the target element is invalid. Example: expect(input).toBeInvalid();\nexpect(input).not.toBeInvalid(); Types: toBeInvalid(): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tobevalid",
    "title": "toBeValid",
    "text": "Checks if the target element is valid. Example: expect(input).toBeValid();\nexpect(input).not.toBeValid(); Types: toBeValid(): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tobeinputtypeof",
    "title": "toBeInputTypeOf",
    "text": "Verifies the target element type. Example: expect(input).toBeInputTypeOf(\"text\");\nexpect(input).not.toBeInputTypeOf(\"password\"); Types: toBeInputTypeOf(type: string): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tobeinthedocument",
    "title": "toBeInTheDocument",
    "text": "Checks if the target element is present in the DOM. Example: expect(element).toBeInTheDocument();\nexpect(element).not.toBeInTheDocument(); Types: toBeInTheDocument(): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#tohaveelementbynodename",
    "title": "toHaveElementByNodeName",
    "text": "Verifies the presence of an element with a specific node name. Example: expect(element).toHaveElementByNodeName(\"div\");\nexpect(element).not.toHaveElementByNodeName(\"span\"); Types: toHaveElementByNodeName(nodeName: string): void;",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/matchers#more-matchers-from-bun",
    "title": "More Matchers from Bun",
    "text": "In addition to the custom matchers provided by Brisa, you can also use the default matchers from Bun, such as toBe, toEqual, toBeTruthy, toBeFalsy... For more information on how to use these matchers, refer to the Bun documentation.",
    "titles": [
      "Matchers"
    ]
  },
  {
    "id": "/building-your-application/testing/test-api#testing-api",
    "title": "Testing API",
    "text": "Brisa exposes a testing API that extends the Bun test runner with custom APIs to streamline the testing process. These APIs are designed to simplify the testing of Brisa components and their behavior.",
    "titles": []
  },
  {
    "id": "/building-your-application/testing/test-api#render",
    "title": "render",
    "text": "Renders a Brisa component into a container and returns a set of actions to interact with the component. Example: import { render } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\n\nfunction Button() {\n  return <button onClick={() => console.log(\"clicked\")}>Click me</button>;\n}\n\ntest(\"component\", async () => {\n  const { container } = await render(<Button />);\n  const button = container.querySelector(\"button\");\n\n  expect(button).toHaveTextContent(\"Click me\");\n}); The second argument are the options to render the component: baseElement: The element where the component will be rendered. By default, it uses the document.documentElement.\nlocale: The locale to use when rendering the component when using i18n. By default, it uses the defaultLocale. Example: import { render } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\nimport { Component } from \"./Component\";\n\ntest(\"component\", async () => {\n  const baseElement = document.createElement(\"div\");\n  await render(<Component />, { baseElement, locale: \"es\" });\n\n  expect(baseElement.querySelector(\"button\")).toHaveTextContent(\"Clica aquÃ­\");\n}); Types: render(element: JSX.Element | Response |Â string, options?: {\n  baseElement?: HTMLElement;\n  locale?: string;\n}): Promise<{\n  container: HTMLElement;\n  unmount: () => void;\n  store: ReactiveMap;\n}>;",
    "titles": [
      "Testing API"
    ]
  },
  {
    "id": "/building-your-application/testing/test-api#container",
    "title": "container",
    "text": "The container where the component is rendered.",
    "titles": [
      "Testing API",
      "render"
    ]
  },
  {
    "id": "/building-your-application/testing/test-api#unmount",
    "title": "unmount",
    "text": "Unmounts the component from the container. Example: import { render } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\n\ntest(\"unmount\", async () => {\n  const { container, unmount } = await render(<button>Click me</button>);\n  expect(container.querySelector(\"button\")).toBeInTheDocument();\n  unmount();\n  expect(container.querySelector(\"button\")).not.toBeInTheDocument();\n});",
    "titles": [
      "Testing API",
      "render"
    ]
  },
  {
    "id": "/building-your-application/testing/test-api#store",
    "title": "store",
    "text": "The store from WebContext is useful for modifying the store to test how web components react to changes in it. Example: import { render } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\n\ntest(\"store\", async () => {\n  const { container, store } = await render(<counter-example />);\n  const counter = container.querySelector(\"counter-example\")?.shadowRoot;\n\n  expect(counter).toHaveTextContent(\"0\");\n\n  store.set(\"count\", 1);\n\n  expect(counter).toHaveTextContent(\"1\");\n});",
    "titles": [
      "Testing API",
      "render"
    ]
  },
  {
    "id": "/building-your-application/testing/test-api#serveroute",
    "title": "serveRoute",
    "text": "Request a Brisa route and return the Response. These routes can be API endpoints, pages, assets, or any other type of route. Example: import { serveRoute } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\n\ntest(\"route\", async () => {\n  const response = await serveRoute(\"/api/hello\");\n  const data = await response.json();\n\n  expect(data).toEqual({ message: \"Hello, world!\" });\n}); For the pages, you can use it with the render function to render the page: import { render, serveRoute } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\n\ntest(\"page\", async () => {\n  const response = await serveRoute(\"/about\");\n  const { container } = await render(response);\n\n  expect(container).toHaveTextContent(\"About us\");\n}); You can use render after serveRoute to render the page and interact with it, and you can pass the response or the response.text() directly to the render function. Types: serveRoute(route: string): Promise<Response>;",
    "titles": [
      "Testing API"
    ]
  },
  {
    "id": "/building-your-application/testing/test-api#cleanup",
    "title": "cleanup",
    "text": "Cleans up the document after each test. Example: import { cleanup } from \"brisa/test\";\nimport { afterEach } from \"bun:test\";\n\nafterEach(() => {\n  cleanup();\n}); Types: cleanup(): void;",
    "titles": [
      "Testing API"
    ]
  },
  {
    "id": "/building-your-application/testing/test-api#userevent",
    "title": "userEvent",
    "text": "Simulates user events on a target element. Example: import { render, userEvent } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\n\ntest(\"user event\", async () => {\n  const { container } = await render(<button>Click me</button>);\n  const button = container.querySelector(\"button\");\n\n  userEvent.click(button); // Simulate a click event\n}); Each method simulates a different user event: click: Simulates a click event.userEvent.click(button);\n\n\ndblClick: Simulates a double click event.userEvent.dblClick(button);\n\n\nsubmit: Simulates a submit event.userEvent.submit(form);\n\n\ntype: Simulates typing text into an input.userEvent.type(input, \"Hello, world!\");\n\n\nkeyboard: Simulates pressing a key.userEvent.keyboard(\"Enter\");\n\n\nhover: Simulates hovering over an element.userEvent.hover(element);\n\n\nunhover: Simulates unhovering an element.userEvent.unhover(element);\n\n\nfocus: Simulates focusing on an element.userEvent.focus(input);\n\n\nblur: Simulates blurring an element.userEvent.blur(input);\n\n\nselect: Simulates selecting an option from a dropdown.userEvent.select(select, \"option-1\");\n\n\ndeselect: Simulates deselecting an option from a dropdown.userEvent.deselect(select, \"option-1\");\n\n\nupload: Simulates uploading a file.userEvent.upload(input, file);\n\n\nclear: Simulates clearing an input.userEvent.clear(input);\n\n\ntab: Simulates pressing the tab key.userEvent.tab();\n\n\npaste: Simulates pasting text into an input.userEvent.paste(input, \"Hello, world!\"); Types: type userEvent = {\n  click(element: Element): void;\n  dblClick(element: Element): void;\n  submit(element: HTMLFormElement): void;\n  type(element: HTMLInputElement, text: string): void;\n  keyboard(key: string, element?: HTMLElement): void;\n  hover(element: Element): void;\n  unhover(element: Element): void;\n  focus(element: Element): void;\n  blur(element: Element): void;\n  select(element: HTMLSelectElement, value: string): void;\n  deselect(element: HTMLSelectElement, value: string): void;\n  upload(element: HTMLInputElement, file: File): void;\n  clear(element: HTMLInputElement): void;\n  tab(): void;\n  paste(element: Element, text: string): void;\n};",
    "titles": [
      "Testing API"
    ]
  },
  {
    "id": "/building-your-application/testing/test-api#waitfor",
    "title": "waitFor",
    "text": "Waits for a condition to be true before continuing with the test. This is useful when you need to wait for an element to be visible, for example, when testing animations or asynchronous behavior. Example: import { render, waitFor } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\n\ntest(\"wait for\", async () => {\n  const { container } = await render(<button>Click me</button>);\n  const button = container.querySelector(\"button\");\n\n  await waitFor(() => expect(button).toBeVisible());\n}); You can use waitFor to wait for an element to be visible, to have a specific text content, or to have a specific class name. Types: async function waitFor(\n  fn: () => unknown,\n  maxMilliseconds: number,\n): Promise<void>;",
    "titles": [
      "Testing API"
    ]
  },
  {
    "id": "/building-your-application/testing/test-api#debug",
    "title": "debug",
    "text": "Prints the HTML of the rendered component to the console in a readable format. Example: import { render, debug } from \"brisa/test\";\nimport { test, expect } from \"bun:test\";\n\ntest(\"debug a specific element\", async () => {\n  const { container } = await render(<button>Click me</button>);\n  debug(container);\n}); If no element is passed, it will debug the entire document. Example: import { debug, render, serveRoute } from \"brisa/test\";\nimport { test } from \"bun:test\";\n\ntest(\"debug all the document\", async () => {\n  const pageResponse = await serveRoute(\"/about\");\n  await render(pageResponse);\n\n  debug(); // Debug the entire document\n}); In the console, you will see the HTML of the document in a readable format: <html>\n  <body>\n    <button>Click me</button>\n  </body>\n</html> Types: debug(element?: HTMLElement | DocumentFragment | ShadowRoot | null): void;",
    "titles": [
      "Testing API"
    ]
  },
  {
    "id": "/getting-started#getting-started",
    "title": "Getting Started",
    "text": "",
    "titles": []
  },
  {
    "id": "/getting-started/project-structure#brisa-project-structure",
    "title": "Brisa Project Structure",
    "text": "This page provides an overview of the file and folder structure of a Brisa project.",
    "titles": []
  },
  {
    "id": "/getting-started/project-structure#src-level-folders",
    "title": "src-level folders",
    "text": "pages\nPages Router\n\n\napi\nApi Router\n\n\npublic\nStatic assets to be served\n\n\nmiddleware\nMiddleware\n\n\nlayout\nLayout / Layouts\n\n\nwebsocket\nWebsocket\n\n\ni18n\nInternationalization routing & translations\n\n\nweb-components\nClient components\n\n\nsitemap\nSpecify a Sitemap in an easy way",
    "titles": [
      "Brisa Project Structure"
    ]
  },
  {
    "id": "/getting-started/project-structure#top-level-files",
    "title": "Top-level files",
    "text": "brisa.config.js\nConfiguration file for Brisa.",
    "titles": [
      "Brisa Project Structure"
    ]
  },
  {
    "id": "/getting-started/project-structure#special-files-in-srcpages",
    "title": "Special Files in src/pages",
    "text": "_404\n.js .jsx .tsx\n404 Error Page\n\n\n_500\n.js .jsx .tsx\n500 Error Page",
    "titles": [
      "Brisa Project Structure",
      "Top-level files"
    ]
  },
  {
    "id": "/getting-started/project-structure#routes",
    "title": "Routes",
    "text": "Folder convention\n\n\n\n\nindex\n.js .jsx .tsx\nHome page\n\n\nfolder/index\n.js .jsx .tsx\nNested page\n\n\nFile convention\n\n\n\n\nindex\n.js .jsx .tsx\nHome page\n\n\nfile\n.js .jsx .tsx\nNested page",
    "titles": [
      "Brisa Project Structure",
      "Top-level files"
    ]
  },
  {
    "id": "/getting-started/project-structure#dynamic-routes",
    "title": "Dynamic Routes",
    "text": "Folder convention\n\n\n\n\n[folder]/index\n.js .jsx .tsx\nDynamic route segment\n\n\n[...folder]/index\n.js .jsx .tsx\nCatch-all route segment\n\n\n[[...folder]]/index\n.js .jsx .tsx\nOptional catch-all route segment\n\n\nFile convention\n\n\n\n\n[file]\n.js .jsx .tsx\nDynamic route segment\n\n\n[...file]\n.js .jsx .tsx\nCatch-all route segment\n\n\n[[...file]]\n.js .jsx .tsx\nOptional catch-all route segment",
    "titles": [
      "Brisa Project Structure",
      "Top-level files"
    ]
  },
  {
    "id": "/getting-started/quick-start#quick-start",
    "title": "Quick start",
    "text": "",
    "titles": []
  },
  {
    "id": "/getting-started/quick-start#system-requirements",
    "title": "System Requirements",
    "text": "Bun  or later\nmacOS, Windows (including WSL), and Linux are supported.",
    "titles": [
      "Quick start"
    ]
  },
  {
    "id": "/getting-started/quick-start#automatic-installation",
    "title": "Automatic Installation",
    "text": "We recommend starting a new Brisa app using bun create brisa, which sets up everything automatically for you. bun create brisa@latest After the prompts, it will create a folder with your project name and install the required dependencies.",
    "titles": [
      "Quick start"
    ]
  },
  {
    "id": "/getting-started/quick-start#manual-installation",
    "title": "Manual Installation",
    "text": "To manually create a new Brisa app, install the required packages: bun install brisa@latest Open your package.json file and add the following scripts: {\n  \"scripts\": {\n    \"dev\": \"brisa dev\",\n    \"build\": \"brisa build\",\n    \"start\": \"brisa start\"\n  }\n} These scripts refer to the different stages of developing an application: dev: runs next dev to start Brisa in development mode.\nbuild: runs next build to build the application for production usage.\nstart: runs next start to start a Brisa production server. You need to add the jsx-runtime of Brisa in your tsconfig.json file: {\n  \"compilerOptions\": {\n    // ...rest\n    \"jsx\": \"react-jsx\",\n    \"jsxImportSource\": \"brisa\"\n  }\n}",
    "titles": [
      "Quick start"
    ]
  },
  {
    "id": "/getting-started/quick-start#creating-directories",
    "title": "Creating directories",
    "text": "Brisa uses file-system routing (like Next.js pages) under the src folder. You can create a src/pages/ directory. Then, add an index.tsx file inside your src/pages folder. This will be your home page (/): export default function Page() {\n  return <h1>Hello, Brisa!</h1>;\n} Then, add an src/layout.tsx file or src/layout/index.tsx to define the global layout. To add more layouts depending on the pages, take a look at the layouts documentation.",
    "titles": [
      "Quick start"
    ]
  },
  {
    "id": "/getting-started/quick-start#the-public-folder-optional",
    "title": "The public folder (optional)",
    "text": "Create a public folder to store static assets such as images, fonts, etc. Files inside public directory can then be referenced by your code starting from the base URL (/).",
    "titles": [
      "Quick start",
      "Creating directories"
    ]
  },
  {
    "id": "/getting-started/quick-start#run-the-development-server",
    "title": "Run the Development Server",
    "text": "Run npm run dev to start the development server. Visit http://localhost:3000 to view your application.\nEdit src/layout/index.tsx (or src/pages/index.tsx) file and save it to see the updated result in your browser.",
    "titles": [
      "Quick start"
    ]
  },
  {
    "id": "/getting-started/what-is-brisa#what-is-brisa",
    "title": "What is Brisa?",
    "text": "The 0.x versions of Brisa are considered experimental, use it for experimentation, we do not recommend using it in production until 1.x. Please help us to improve it by testing and giving feedback, we are open to suggestions and contributions to make it better. Brisa is a web framework inspired by the others, taking the best of each one. Features âœ¨ âš›ï¸ ãƒ» Everything you need: JSX, TS, server/web components, server actions, optimistic updates, SSR, streaming, suspense, signals, websockets, middleware, layouts...\nðŸš€ ãƒ» Speed: Brisa is designed to start, build, test, deploy and run fast.\nðŸŒ ãƒ» i18n support: text translation and routing carrying only the translations you consume.\nðŸ“¦ ãƒ» Tiny: 0B by default, 2kB when you use server actions (RPC size), and 3kb when you need web components.\nðŸ“² ãƒ» Change the output: You can change your web from server to static, to desktop, android or ios app with just one configuration command.",
    "titles": []
  },
  {
    "id": "/getting-started/what-is-brisa#inspirations",
    "title": "Inspirations",
    "text": "",
    "titles": [
      "What is Brisa?"
    ]
  },
  {
    "id": "/getting-started/what-is-brisa#bunjs",
    "title": "Bun.js",
    "text": "Bun.js makes it easy for many new frameworks to emerge thanks to its API such as the Next.js style page system, TypeScript support and JSX by default. Besides, it is super fast and the DX of working with it is awesome. In Brisa we don't use Webpack, Turbopack, Vite or esbuild, we use directly Bun.build, which is faster than esbuild.",
    "titles": [
      "What is Brisa?",
      "Inspirations"
    ]
  },
  {
    "id": "/getting-started/what-is-brisa#nextjs",
    "title": "Next.js",
    "text": "Brisa's architecture is very much inspired by Next.js pages directory, the way of defining pages, middleware, layout, etc, we have also expanded its model to define websockets and web components. Although we like more how pages structures the files, also Next.js inspired us to use server components by default and server actions.",
    "titles": [
      "What is Brisa?",
      "Inspirations"
    ]
  },
  {
    "id": "/getting-started/what-is-brisa#react",
    "title": "React",
    "text": "Brisa was very inspired by React to work with JSX components, both for server components and web components. Our compiler transforms and optimizes the JSX in a different way so that writing web components is more React-like, and takes up much tiny than the original code.",
    "titles": [
      "What is Brisa?",
      "Inspirations"
    ]
  },
  {
    "id": "/getting-started/what-is-brisa#preact",
    "title": "Preact",
    "text": "The Preact team's focus on optimizing for small bundle code size motivated us to make Brisa 3kb as well. Although Brisa defaults to 0B, it is only 3kb if you use web components.",
    "titles": [
      "What is Brisa?",
      "Inspirations"
    ]
  },
  {
    "id": "/getting-started/what-is-brisa#solidjs",
    "title": "Solid.js",
    "text": "Solid.js here inspired us a lot with the signals. The idea that server components can react to web components through server actions and signals blew our minds, to the point that it motivated us to create the \"action signals\". The way web components are reactive without needing Virtual DOM or rerendering greatly improves performance.",
    "titles": [
      "What is Brisa?",
      "Inspirations"
    ]
  },
  {
    "id": "/getting-started/what-is-brisa#qwik",
    "title": "Qwik",
    "text": "The motivation to start with a new framework came from meeting Qwik. Misko came to Barcelona and talked about his baby, and I was motivated by Misko, Manu and Shai to talk about Qwik so I could also start creating my baby and try to make the web a little better. The resumability concept has motivated us to load code like server actions when the user interacts. We can't say that we have resumability because the web components need to be hydrated, but the motivation to improve this in the future is still open.",
    "titles": [
      "What is Brisa?",
      "Inspirations"
    ]
  },
  {
    "id": "/getting-started/what-is-brisa#lit",
    "title": "Lit",
    "text": "Brisa was inspired by Lit to use the platform more. Today we have web components and there is Declarative Shadow DOM, so we can SSR web components. If well abstracted, the code of a web component can be smaller than using a library. Moreover, it also makes it easier to control when a prop changes, when it is unmounted and to have web components mixed with server components without problems. We liked the idea of consuming web components as web components from JSX. That is, reading the code you know when a component is a server <Server /> or when it is a web component <web-component />. We want developers to be able to easily distinguish the use of both. The fact of using web components makes it more comfortable to debug the code as well, accessing directly to the web components from the DevTools elements, without any extension.",
    "titles": [
      "What is Brisa?",
      "Inspirations"
    ]
  },
  {
    "id": "/getting-started/what-is-brisa#htmx",
    "title": "HTMX",
    "text": "HTMX has inspired Brisa to make the use of web components less and less necessary and the rest of the components are server components. Here we mix the concept of server actions with HTMX ideas such as indicators, debounce, etc. Another thing that inspired us a lot is the fact of using more Hypermedia. Brisa's server actions respond with HTML that reactively updates the DOM. It also makes it easier to debug by looking at the Network tab in DevTools and see what the server action returns.",
    "titles": [
      "What is Brisa?",
      "Inspirations"
    ]
  },
  {
    "id": "/getting-started/what-is-brisa#tauri",
    "title": "Tauri",
    "text": "In Brisa we wanted to make a direct integration with Tauri. So that from the Brisa configuration you can define the output: server (by default), static, desktop, android and ios, and the Brisa CLI will take care of the integration adding the necessary Tauri files that you can then modify if you want to change the icons, the title or use more native things.",
    "titles": [
      "What is Brisa?",
      "Inspirations"
    ]
  },
  {
    "id": "/getting-started/what-is-brisa#vuejs",
    "title": "Vue.js",
    "text": "Finally, I want to thank An Phan, a co-worker who is in the core team of Vue.js and when he found out that I was starting to make a framework, he gave me a lot of support. The first version of the documentation was created with Vitepress, then we moved it to Brisa but inspired by Vitepress.",
    "titles": [
      "What is Brisa?",
      "Inspirations"
    ]
  }
]